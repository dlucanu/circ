***(

    This file includes a circular prover written in Maude 2.4.

    Copyright 2006-2010
      University of Alexandru Ioan Cuza, Iasi, Romania
      University of Illinois at Urbana-Champaign, IL, USA

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

***)
***  CIRC prover
***  Version 1.5

***(
Version 1.5:
===========
   16 Apr 2010: user input error handling
                improved parsing engine
                many bug-fixes
                added generalization & improved simplification rules
                added enumerable sorts & guarded equations for case analysis
                improved checking for special contexts

Version 1.4:
===========
   13 Feb 2010: internal modules extended in order to handle rules (rl)
                checkcond - checks for false conditions
   22 Jan 2009: special context can be automatically deduced
                a new induction engine implemented
                "induction" command can take 0 or more arguments
                if it takes 0 arguments, it automatically deduces the ind. vars.
                "apply" command added for specifying user defined strategies
   23 Sep 2008: special context declaration added
                modify/check the maximum number of steps
                (reduce .) command applies normalize and then eqRed
   19 May 2008: comm, assoc, id and idem goals can be proved
                proving rule "attr" added;
                  the rule obtains the goals needed to be proved when trying
                  to show that a certain property (comm, assoc, id...) holds
   12 May 2008: new way of using strategies
                (implemented the #, |> and ! operators)
                ( (a # b)  has the semantics of ((a |> id) o b) )
   5 May 2008: separated the proving rules so that each of them does only
               what it is designed for:
               normalize - normalizez an equation
               eqRed - reduces (removes) a goal equation of the LHS = RHS
               simplify - simplifies an equation
               ccstep - attempts to apply a circular coinduction step
               cistep - attempts to apply a circular induction step
   25 February 2008: extended fth, so that cth modules can be interpreted
   10 January 2008: major refactoring according to the paper
                    "Patterns for Maude Metalanguage Applications"
                    and fixed the "reversed order goals" bug


Version 1.3:
===========
   20 April 2007: added regular strategies and defined the proof tactic
                  "coinduction and simplification"; the full implementation
                  of the regular strategies is still in progress
   11 March 2007: added simplification rule


Version 1.2:
===========
   17 february 2007: short notations for induction and coinduction added
   12 february 2007: the 'show details' switch added
   26 october 2006: 'adding operation' command added; this command allows to
                   introduce the freezing operator under some "well-behaving"
                   operations
                   status: unfinished; the orientation relation for the new
                           equations must be changed (recursive path ordering?)
                           for now we changed a bit the initial definition
                           (check it!!!)
                           tested for distributivity of convolution product
                           over addition and for associativity of the
                           convolution product (it works fine)
   24 september 2006: changed to Full-Maude implementation
                   status: we should investigate why the goals are considered
                   in the reversed order than that we introduce
   01 august 2006: commutative goal command added only for coinduction proofs
                   tested only for addition of streams
                   status: unfinished
***)

set print attribute on .


fmod CONTAINERS is
  including  QID-LIST .
  including  CONVERSION .
  protecting VIEW-MAP-SET-APPL-ON-TERM .
  
  ------------------------------------------------------------------------------
  sort NsList{Equation} .
  subsort Equation < NsList{Equation} .
  
  op nsnil-E : -> NsList{Equation} [ctor] .
  op _:E:_   : NsList{Equation} NsList{Equation} -> NsList{Equation}
               [ctor assoc id: nsnil-E prec 25 format (d d ni d)] .
  op count : NsList{Equation} -> Nat .
  eq count(nsnil-E) = 0 .
  eq count(E:Equation :E: EL:NsList{Equation}) =
     1 + count(EL:NsList{Equation}) .

  ------------------------------------------------------------------------------
  sort NsSet{Constant} .
  subsort Constant < NsSet{Constant} .
  
  op nsempty-C : -> NsSet{Constant} [ctor] .
  op _;C;_     : NsSet{Constant} NsSet{Constant} -> NsSet{Constant}
                 [ctor assoc comm id: nsempty-C prec 121] .

  var C : Constant .
  
  eq C ;C; C = C .

  ------------------------------------------------------------------------------
  sort NsSet{Variable} .
  subsort Variable < NsSet{Variable} .
  
  op nsempty-V : -> NsSet{Variable} [ctor] .
  op _;V;_     : NsSet{Variable} NsSet{Variable} -> NsSet{Variable}
                 [ctor assoc comm id: nsempty-V prec 121] .

  op subset  : NsSet{Variable} NsSet{Variable} -> Bool .
  
  var VS VS' : NsSet{Variable} .
  var V V'   : Variable .
  
  eq subset(nsempty-V, nsempty-V)  = true .
  eq subset(nsempty-V, VS)         = true .
  eq subset((V ;V; VS), nsempty-V) = false .
  eq subset(V, (V' ;V; VS))        = V == V' or subset(V, VS) .
  eq subset((V ;V; VS), VS')       = subset(V, VS') and subset(VS, VS') .

  eq V ;V; V = V .

  ------------------------------------------------------------------------------
  sort Goal .
  
  op eq2goal : Equation -> Goal .
  op op2goal : OpDecl   -> Goal .
  
  --- we need Lists of Goals in order to handle conjunctive goals.
  --- we need Lists of Lists of Goals in order to handle disjunctions of
  --- conjunctive goals.
  sort NsList{Goal} NsList{NsList{Goal}} .
  subsort Goal < NsList{Goal} < NsList{NsList{Goal}} .
  
  op nsnil-G : -> NsList{Goal} [ctor] .
  op _:G:_   : NsList{Goal} NsList{Goal} -> NsList{Goal}
                 [ctor assoc id: nsnil-G prec 25 format (d d ni d)] .

  op _:GL:_  : NsList{NsList{Goal}} NsList{NsList{Goal}} -> NsList{NsList{Goal}}
               [ctor assoc id: nsnil-G prec 27 format (d d ni d)] .

  op count : NsList{Goal} -> Nat .
  eq count(nsnil-G) = 0 .
  eq count(G:Goal :G: GL:NsList{Goal}) =
     1 + count(GL:NsList{Goal}) .


  op convEL2GL : NsList{Equation} -> NsList{Goal} .
  eq convEL2GL(nsnil-E) = nsnil-G .
  eq convEL2GL(E:Equation :E: EL:NsList{Equation}) =
     eq2goal(E:Equation) :G: convEL2GL(EL:NsList{Equation})
  .
  
  op convGL2EL : NsList{Goal} -> NsList{Equation} .
  eq convGL2EL(nsnil-G) = nsnil-E .
  eq convGL2EL(eq2goal(E:Equation) :G: GL:NsList{Goal}) =
     E:Equation :E: convGL2EL(GL:NsList{Goal})
  .
  eq convGL2EL(G:Goal :G: GL:NsList{Goal}) =
     convGL2EL(GL:NsList{Goal}) [owise] .
  
  op convGLL2EL : NsList{NsList{Goal}} -> NsList{Equation} .
  eq convGLL2EL(GL:NsList{Goal}) = convGL2EL(GL:NsList{Goal}) .
  ceq convGLL2EL(GLL:NsList{NsList{Goal}} :GL: GLL':NsList{NsList{Goal}}) =
      convGLL2EL(GLL:NsList{NsList{Goal}}) :E:
      convGLL2EL(GLL':NsList{NsList{Goal}})
    if GLL:NsList{NsList{Goal}} =/= nsnil-G
    /\ GLL':NsList{NsList{Goal}} =/= nsnil-G
  .
  
  
  --- Removes the first I elements from the GL list.
  op remove : Int NsList{Goal} -> NsList{Goal} .
  ceq remove(I:Int, GL:NsList{Goal}) = GL:NsList{Goal} if I:Int <= 0 .
  eq  remove(I:Int, nsnil-G) = nsnil-G .
  eq  remove(I:Int, (G:Goal :G: GL:NsList{Goal})) =
      remove((I:Int + (-1)), GL:NsList{Goal}) .
  
  ------------------------------------------------------------------------------
  sort NsList{NsSet{Variable}} .
  subsort NsSet{Variable} < NsList{NsSet{Variable}} .
  
  --- Used for handling the priorities for the induction variables.
  --- The term is the selected variable; the list of sets
  --- denotes the priorities.
  sort TrmVarSetListUple .
  
  op TVSL<_,_> : Term NsList{NsSet{Variable}} -> TrmVarSetListUple .
  
  op _:VSL:_ : NsList{NsSet{Variable}} NsList{NsSet{Variable}} ->
             NsList{NsSet{Variable}} [assoc id: nsempty-V prec 125] .


  ------------------------------------------------------------------------------
  sort CasePair NsList{CasePair} .
  subsort CasePair < NsList{CasePair} .
  
  op <_|_> : Term Condition -> CasePair [format(g o g on g o)].

  op nsnil-CP : -> NsList{CasePair} .
  op _:CP:_ : NsList{CasePair} NsList{CasePair} -> NsList{CasePair}
              [assoc id: nsnil-CP prec 110 format(d d n d)] .
  op getTerms : NsList{CasePair} -> TermList .
  eq getTerms(nsnil-CP) = empty .
  eq getTerms((< T:Term | COND:Condition > :CP: CPL:NsList{CasePair})) =
     T:Term , getTerms(CPL:NsList{CasePair})
  .


  ------------------------------------------------------------------------------
  sort InductionUple NsList{InductionUple} .
  
  subsort InductionUple < NsList{InductionUple} .
  
  op nsnil-IU : -> NsList{InductionUple} .
  op _:IU:_ : NsList{InductionUple} NsList{InductionUple} ->
             NsList{InductionUple} [assoc id: nsnil-IU] .

  ------------------------------------------------------------------------------
  sort ProofStateUple .

  sort CallOrigin .
  sort RuleLabel .
  sort Action .

  subsort RuleLabel < Action .
  
  
  op base : -> CallOrigin .
  op user : -> CallOrigin .
  op disjunction : -> CallOrigin .

  sort IndSource .
  sort NsSet{IndSource} .
  subsort IndSource < NsSet{IndSource} .

  op `(_!_-o_`) : Variable Sort Variable -> IndSource [format (g o g o g o g o) prec 80].
  op nsempty-IS : -> NsSet{IndSource} [ctor] .
  op _;IS;_ : NsSet{IndSource} NsSet{IndSource} -> NsSet{IndSource}
              [ctor assoc comm id: nsempty-IS prec 100 format (d d ni d)] .
  eq IS:IndSource ;IS; IS:IndSource = IS:IndSource .

  --- In order to add a member to the proof state, you need enlarge the uple above,
  --- implement the getters and setters, and add corresponding variables throughout the code
  --- where the uple is used.
  ---
  --- push call origin
  --- conjectures
  --- operating goals
  --- work module
  --- induction variables
  --- induction uples
  --- induction sources
  --- current action
  --- number of steps left
  op PS<_,_,_,_,_,_,_,_,_> :
     CallOrigin NsList{Goal} NsList{NsList{Goal}} Module
     NsList{NsSet{Variable}} NsList{InductionUple} NsSet{IndSource} Action Int ->
     ProofStateUple
  .
 
  sort Stack{ProofStateUple} .
  subsort ProofStateUple < Stack{ProofStateUple} .

  op empty-PS : -> Stack{ProofStateUple} .
  op _;PS;_ : Stack{ProofStateUple} Stack{ProofStateUple} ->
              Stack{ProofStateUple} [assoc id: empty-PS format (d d ni d)] .
  
  var CO CO'     : CallOrigin .
  var CNJL CNJL' : NsList{Goal} .
  var GLL GLL'   : NsList{NsList{Goal}} .
  var M M'       : Module .
  var VSL VSL'   : NsList{NsSet{Variable}} .
  var IUL IUL'   : NsList{InductionUple} .
  var ISS ISS'     : NsSet{IndSource} .
  var NSL NSL'   : Int .
  var PS PS'     : ProofStateUple .
  var PSS PSS'   : Stack{ProofStateUple} .
  var A A'       : Action .

  op top : Stack{ProofStateUple} -> ProofStateUple .
  eq top(PS ;PS; PSS) = PS .
  op pop : Stack{ProofStateUple} -> Stack{ProofStateUple} .
  eq pop(PS ;PS; PSS) = PSS .
  eq pop(empty-PS) = empty-PS .
      
  op getTopCO : ProofStateUple -> CallOrigin .
  eq getTopCO(PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) = CO . 

  op getTopCNJL : ProofStateUple -> NsList{Goal} .
  eq getTopCNJL(PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) = CNJL .

  op getTopGLL : ProofStateUple -> NsList{NsList{Goal}} .
  eq getTopGLL(PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) = GLL .

  op getTopM : ProofStateUple -> Module .
  eq getTopM(PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) = M .

  op getTopVSL : ProofStateUple -> NsList{NsSet{Variable}} .
  eq getTopVSL(PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) = VSL .

  op getTopIUL : ProofStateUple -> NsList{InductionUple} .
  eq getTopIUL(PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) = IUL .

  op getTopISS : ProofStateUple -> NsSet{IndSource} .
  eq getTopISS(PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) = ISS .

  op getTopA : ProofStateUple -> Action .
  eq getTopA(PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) = A .
  
  op getTopNSL : ProofStateUple -> Int .
  eq getTopNSL(PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) = NSL .


  op setTopCO : CallOrigin ProofStateUple -> ProofStateUple .
  eq setTopCO(CO', PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) =
     PS< CO', CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS
  .
  op setTopCNJL : NsList{Goal} ProofStateUple -> ProofStateUple .
  eq setTopCNJL(CNJL', PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) =
     PS< CO, CNJL', GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS
  .
  op setTopGLL : NsList{NsList{Goal}} ProofStateUple -> ProofStateUple .
  eq setTopGLL(GLL', PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) =
     PS< CO, CNJL, GLL', M, VSL, IUL, ISS, A, NSL > ;PS; PSS
  .
  op setTopM : Module ProofStateUple -> ProofStateUple .
  eq setTopM(M', PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) =
     PS< CO, CNJL, GLL, M', VSL, IUL, ISS, A, NSL > ;PS; PSS
  .
  op setTopVSL : NsList{NsSet{Variable}} ProofStateUple -> ProofStateUple .
  eq setTopVSL(VSL', PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) =
     PS< CO, CNJL, GLL, M, VSL', IUL, ISS, A, NSL > ;PS; PSS
  .
  op setTopIUL : NsList{InductionUple} ProofStateUple -> ProofStateUple .
  eq setTopIUL(IUL', PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) =
     PS< CO, CNJL, GLL, M, VSL, IUL', ISS, A, NSL > ;PS; PSS
  .
  op setTopISS : NsSet{IndSource} ProofStateUple -> ProofStateUple .
  eq setTopISS(ISS', PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) =
     PS< CO, CNJL, GLL, M, VSL, IUL, ISS', A, NSL > ;PS; PSS
  .
  op setTopA : Action ProofStateUple -> ProofStateUple .
  eq setTopA(A', PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) =
     PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A', NSL > ;PS; PSS
  .
  op setTopNSL : Int ProofStateUple -> ProofStateUple .
  eq setTopNSL(NSL', PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL > ;PS; PSS) =
     PS< CO, CNJL, GLL, M, VSL, IUL, ISS, A, NSL' > ;PS; PSS
  .

  ------------------------------------------------------------------------------
  op _\/_ : EqCondition EqCondition -> EqCondition
            [ctor assoc prec 100 format(d g o d)] .
  op _\/_ : Condition Condition -> Condition
            [ctor assoc prec 100 format(d g o d)] .

endfm

***( ===========================================================================
*
* ============================================================================ )

fmod BASIC-DATA-TYPES is

  including CONTAINERS .

  sort SubstStrategy .
  op firstXMatch : -> SubstStrategy .
  op noTopXMatch : -> SubstStrategy .
  op noTopXMatch2 : -> SubstStrategy .
  op bottomXMatch : -> SubstStrategy .

  sort SwitchStatus .
  op on :  -> SwitchStatus .
  op off : -> SwitchStatus .
  
  op noVar : -> Variable .

  var AS AS'           : AttrSet .
  var C                : Constant .
  var E                : Equation .
  var COND COND1 COND2 : EqCondition .
  var ES ES'           : EquationSet .
  var FR               : FindResult .
  var IL               : ImportList .
  var N                : Int .
  var MP               : MatchPair? .
  var MAS              : MembAxSet .
  var M                : Module .
  var VS               : NsSet{Variable} .
  var EL EL' EL''      : NsList{Equation} .
  var Cs               : NsSet{Constant} .
  var OD               : OpDecl .
  var ODS ODS'         : OpDeclSet .
  var F Q              : Qid .
  var QL               : QidList .
  var RS               : RuleSet .
  var S S'             : Sort .
  var SS               : SortSet .
  var SSDS             : SubsortDeclSet .
  var theta            : Substitution .
  var theta1 theta2    : Substitution .
  var P T T' T'' T1 T2 : Term .
  var TL TL' TL''      : TermList .
  var TL1 TL1'         : TermList .
  var TL2 TL2'         : TermList .
  var TyL              : TypeList .
  var Ty               : Type .
  var V V'             : Variable .
  var VSL              : NsList{NsSet{Variable}} .


  op getVars : TermList         -> NsSet{Variable} .
  op getVars : Equation         -> NsSet{Variable} .
  op getVars : EquationSet      -> NsSet{Variable} .
  op getVars : NsList{Equation} -> NsSet{Variable} .
  op getVars : EqCondition      -> NsSet{Variable} .

  --- output the list of variables, except for the context variable *;
  --- terms and contexts

  --- The star is viewed as a variable .
  --- A context is a term with a distinguished variable (*).
  eq  getVars(V)       = V [owise] .
  eq  getVars(C)       = nsempty-V .
  eq  getVars(Q[TL])   = getVars(TL) .
  eq  getVars(empty)   = nsempty-V .
  ceq getVars((T, TL)) = getVars(T) ;V; getVars(TL)
    if TL =/= empty .

  --- equations
  eq getVars(eq T = T' [AS] .) =
     getVars(T) ;V; getVars(T') .
  eq getVars(ceq T = T' if COND [AS] .) =
     getVars(T) ;V; getVars(T') ;V; getVars(COND) .

  --- equation sets
  ceq getVars(E ES) = getVars(E) ;V; getVars(ES)
    if ES =/= (none).EquationSet .
  eq getVars((none).EquationSet) = nsempty-V .

  --- equation lists
  ceq getVars(E :E: EL) = getVars(E) ;V; getVars(EL)
    if EL =/= nsnil-E .
  eq getVars(nsnil-E) = nsempty-V .

  --- conditions
  eq getVars((T = T') /\ COND) =
     getVars(T) ;V; getVars(T') ;V; getVars(COND) .
  eq getVars((nil).EqCondition) = nsempty-V .

  --- outputs the number of symbols in a term
  op noSym : TermList -> Nat .

  eq  noSym(V)       = 1 .
  eq  noSym(C)       = 1 .
  eq  noSym(Q[TL])   = 1 + noSym(TL) .
  eq  noSym(empty)   = 0 .
  ceq noSym((T, TL)) = noSym(T) + noSym(TL)
    if TL =/= empty .

  --- substitutes a term in a context,
  --- i.e., in a term with a variable *
  op _<_> : TermList Term -> TermList .

  ceq V  < T >       = T if getName(V) = '* .
  eq  V  < T >       = V [owise] .
  eq  C  < T >       = C .
  eq  (Q[TL]) < T >  = Q[TL < T >] .
  eq  empty < T >    = empty .
  ceq (T', TL) < T > = T' < T > , TL < T >
    if TL =/= empty .

  ---
  op getSubterms : TermList -> TermList .
  eq getSubterms(V) = empty .
  eq getSubterms(C) = empty .
  eq getSubterms(Q[TL]) = (Q[TL], getSubterms(TL)) .
  eq getSubterms(empty) = empty .
  ceq getSubterms((T, TL)) = (getSubterms(T), getSubterms(TL))
    if TL =/= empty
  .
  
  --- Renames all variables in terms by appending a number N followed by
  --- "CC-RN" to their names
  op rename : TermList Int -> TermList .

  ceq rename(V, N)       = V if getName(V) = '* .
  eq  rename(V, N)       = qid(((string(getName(V)) + string(N, 10)) +
                                  "CC-RN:") + string(getType(V))) .
  eq  rename(C, N)       = C .
  eq  rename(Q[TL], N)   = Q[rename(TL, N)] .
  eq  rename(empty, N)   = empty .
  ceq rename((T, TL), N) = rename(T, N), rename(TL, N)
    if TL =/= empty .

  --- transforms variables in constants, whose names are the variables names
  --- followed by "CC-V2C";
  op v2c : Variable         -> Constant .
  op v2c : TermList         -> TermList .
  op v2c : Equation         -> Equation .
  op v2c : EquationSet      -> EquationSet .
  op v2c : NsList{Equation} -> NsList{Equation} .
  op v2c : EqCondition      -> EqCondition .
  op v2c : NsSet{Variable}  -> NsSet{Constant} .
  op v2c : Goal             -> Goal .
  
  --- goals
  eq v2c(eq2goal(E)) = eq2goal(v2c(E)) .

  --- terms
  eq  v2c(V)        = qid(string(getName(V)) + "CC-V2C." + string(getType(V))) .
  eq  v2c(C)        = C .
  eq  v2c(Q[TL])    = Q[v2c(TL)] .
  eq  v2c(empty)    = empty .
  ceq v2c((T, TL)) = (v2c(T), v2c(TL))
    if TL =/= empty  .

  --- equations
  eq v2c(eq T = T' [AS] .) = (eq v2c(T) = v2c(T') [AS] .) .
  eq v2c(ceq T = T' if COND [AS] .) =
    (ceq v2c(T) = v2c(T') if v2c(COND) [AS] .) .
  eq v2c((none).EquationSet) = none .

  --- equation sets
  eq  v2c((none).EquationSet) = none .
  ceq v2c(E ES) = v2c(E) v2c(ES)
    if ES =/= (none).EquationSet .
 
  --- equation lists
  eq  v2c(nsnil-E) = nsnil-E .
  ceq v2c(E :E: EL) = v2c(E) :E: v2c(EL)
    if EL =/= nsnil-E .

  --- conditions
  eq v2c((nil).EqCondition) = nil .
  eq v2c((T = T') /\ COND) = (v2c(T) = v2c(T')) /\ v2c(COND) .

  --- sets of variables
  eq v2c(nsempty-V)  = nsempty-C .
  eq v2c((V ;V; VS)) = v2c(V) ;C; v2c(VS) .

  --- turns the constants added by "vtc" back into variables; terms
  op c2v : TermList         -> TermList .
  op c2v : Equation         -> Equation .
  op c2v : EquationSet      -> EquationSet .
  op c2v : NsList{Equation} -> NsList{Equation} .
  op c2v : NsList{NsList{Goal}} -> NsList{NsList{Goal}} .
  op c2v : EqCondition      -> EqCondition .
  op c2v : Goal             -> Goal .
  
  
  --- goals
  var GLL GLL' : NsList{NsList{Goal}} .
  eq c2v(eq2goal(E)) = eq2goal(c2v(E)) .
  ceq c2v(GLL :GL: GLL') = c2v(GLL) :GL: c2v(GLL')
    if GLL  =/= nsnil-G
    /\ GLL' =/= nsnil-G
  .

  
  eq  c2v(V) = V .
  ceq c2v(C) = C
    if find(string(C),"CC-V2C.",0) = notFound .
  ceq c2v(C) = qid((substr(string(C),0,FR) + ":") +
               substr(string(C), FR + 7, length(string(C))))
    if FR := find(string(C), "CC-V2C.", 0) [owise] .
  eq  c2v(Q[TL])   = Q[c2v(TL)] .
  eq  c2v(empty)   = empty .
  ceq c2v((T, TL)) = c2v(T), c2v(TL) if TL =/= empty .

  --- equations
  eq c2v(eq T = T' [AS] .) = (eq c2v(T) = c2v(T') [AS] .) .
  eq c2v(ceq T = T' if COND [AS] .) =
    (ceq c2v(T) = c2v(T') if c2v(COND) [AS] .) .

  --- equation sets
  ceq c2v(E ES) = c2v(E) c2v(ES)
    if ES =/= (none).EquationSet .
  eq c2v((none).EquationSet) = none .

  --- equation lists
  ceq c2v(E :E: EL) = c2v(E) :E: c2v(EL)
    if EL =/= nsnil-E .
  eq c2v(nsnil-E) = nsnil-E .

  --- conditions
  eq c2v((T = T') /\ COND) = (c2v(T) = c2v(T')) /\ c2v(COND) .
  eq c2v((nil).EqCondition) = nil .

  --- transforms a condition into a set of unconditional equations
  op convCond2Eqs : EqCondition -> EquationSet .
  eq convCond2Eqs((T = T') /\ COND) =
    (eq T = T' [none] .) convCond2Eqs(COND) .
  eq convCond2Eqs((T := T') /\ COND) =
    (ceq T' = T if T := T' [none] .) convCond2Eqs(COND) .
  eq convCond2Eqs(nil) = none .


  --- Returns the list of types from a list of terms.
  op convTL2TyL : TermList Module -> TypeList .
  eq convTL2TyL(T, M) = getType(metaReduce(M, T)) .
  ceq convTL2TyL((T, TL), M) = (convTL2TyL(T, M) convTL2TyL(TL, M)) 
    if TL =/= empty
  .

  --- Inserts declarations for the constants in a module.
  op addCts : NsSet{Constant} Module -> Module .
  eq addCts(Cs, mod Q is IL sorts SS . SSDS ODS MAS ES RS endm) =
    (mod Q is IL sorts SS . SSDS (convCTS2ODS(Cs) ODS) MAS ES RS endm) .
  eq addCts(Cs, th Q is IL sorts SS . SSDS ODS MAS ES RS endth) =
    (th Q is IL sorts SS . SSDS (convCTS2ODS(Cs) ODS) MAS ES RS endth) .

  --- Gets the constants from an operator declaration set.
  op getCts : OpDeclSet -> OpDeclSet .
  eq getCts((op Q : nil -> TyL [AS] .) ODS) =
       (op Q : nil -> TyL [AS] .) getCts(ODS) .
  eq getCts(ODS) = none [owise] .
  
  op convCTS2ODS : NsSet{Constant} -> OpDeclSet .
  eq convCTS2ODS((C ;C; Cs)) =
     (op getName(C) : nil -> getType(C) [none] .)
     convCTS2ODS(Cs)
  .
  eq convCTS2ODS(nsempty-C) = none .

  --- Chooses only the variables that have sorts in the provided sort set.
  op filterVariables : NsSet{Variable} SortSet -> NsSet{Variable} .
  
  ceq filterVariables((V ;V; VS), (S ; SS)) =
      V ;V; filterVariables((VS), (S ; SS))
    if getType(V) == S
  .
  eq filterVariables(VS, SS) = nsempty-V [owise] .


  --- Gets the right-hand sorts from an operator declaration set.
  op getOpSorts : OpDeclSet -> SortSet .
  
  eq getOpSorts(none) = none .
  eq getOpSorts((op Q : TyL -> S [AS] .) ODS) = S ; getOpSorts(ODS) .

  --- Gets all supersorts for the specified sort set,
  --- including the sort set itself.
  op getSuperSorts : SortSet SubsortDeclSet -> SortSet .
  
  eq getSuperSorts((SS ; S), (SSDS (subsort S < S' .))) =
     getSuperSorts((SS ; S ; S'), (SSDS))
  .
  eq getSuperSorts(SS, SSDS) = SS [owise] .


  op appendVarSet : NsSet{Variable} TrmVarSetListUple -> TrmVarSetListUple .
  
  eq appendVarSet(VS, TVSL< V , VSL >) = TVSL< V , (VSL :VSL: VS) > .


  --- finds the sort of the "hole" *; we let the result be of type SortSet
  --- instead of Sort only for technical resons
  op getSortsHidden : TermList -> SortSet .

  ceq getSortsHidden(V)       = getType(V) if getName(V) = '* .
  eq  getSortsHidden(V)       = none [owise] .
  eq  getSortsHidden(C)       = none .
  eq  getSortsHidden(Q[TL])   = getSortsHidden(TL) .
  eq  getSortsHidden(empty)   = none .
  ceq getSortsHidden((T, TL)) = getSortsHidden(T) ; getSortsHidden(TL)
    if TL =/= empty .

  var GL GL' : NsList{Goal} .
  var G : Goal .

  --- sets the N-th element as the first in a list
  --- if N is greater than the length of the list,
  --- does nothing
  op setFirst : NsList{Goal} Int -> NsList{Goal} .

  eq setFirst(GL, N) = aux(GL, nsnil-G, N) .

  --- auxiliary function for setFirst()
  op aux : NsList{Goal} NsList{Goal} Int -> NsList{Goal} .
  eq aux(nsnil-G, GL', N) = GL' .
  ceq aux(G :G: GL, GL', N) = aux(GL, GL' :G: G, N + (-1))
    if N > 1 .
  eq aux(G :G: GL, GL', 1) = G :G: GL' :G: GL .

  --- replace(E, T, T') replaces in E
  --- the term T with the term T';
  op replace : Equation  Term Term -> Equation .
  op replace : EqCondition Term Term -> EqCondition .
  op replace : TermList  Term Term -> TermList .
  op replace : NsSet{IndSource}  Term Term -> NsSet{IndSource} .

  --- on terms:
  eq replace(T, T, T') = T' .
  eq replace(C, T, T') = C [owise] .
  eq replace(V, T, T') = V [owise] .
  eq replace(Q[TL], T, T') = Q[replace(TL, T, T')] [owise] .

  --- on term lists
  eq replace(empty, T, T') = empty .
  ceq replace((T'', TL), T, T') =
    replace(T'', T, T'), replace(TL, T, T')
    if TL =/= empty .

  --- conditions
  eq replace((nil).EqCondition, T1, T2) = (nil).EqCondition .
  eq replace((T = T') /\ COND, T1, T2) =
    (replace(T, T1, T2) = replace(T', T1, T2)) /\
    replace(COND, T1, T2) .

  --- equations
  eq replace((eq T = T' [AS] .), T1, T2) =
    (eq replace(T, T1, T2) = replace(T', T1, T2) [AS] .) .
  eq replace((ceq T = T' if COND [AS] .), T1, T2) =
    (ceq replace(T, T1, T2) = replace(T', T1, T2)
    if replace(COND, T1, T2) [AS] .) .
  eq replace(nsempty-IS, T1, T2) = nsempty-IS .

  --- indSources
  var IS : IndSource . var ISS1 ISS2 : NsSet{IndSource} .
  eq replace((T1 ! S -o V), T1, T2) = (T2 ! S -o V) .
  eq replace(IS, T1, T2) = IS [owise] .
  ceq replace((ISS1 ;IS; ISS2), T1, T2) = replace(ISS1, T1, T2) ;IS; replace(ISS2, T1, T2)
    if (ISS1 =/= nsempty-IS and ISS2 =/= nsempty-IS)
  .

  --- returns the set of constructors of a given module
  op getCtors : Module -> OpDeclSet .
  op getCtors : OpDeclSet -> OpDeclSet .

  eq getCtors(mod Q is IL sorts SS . SSDS ODS MAS ES RS endm) = getCtors(ODS) .
  eq getCtors((op Q : TyL -> S [ctor AS] .) ODS) =
    (op Q : TyL -> S [ctor AS] .) getCtors(ODS) .
  eq getCtors(ODS) = none [owise] .


  --- reduce a condition in a given module
  op metaReduceCond : Module EqCondition ~> Bool .
  eq metaReduceCond(M, nil) = true .
  eq metaReduceCond(M, (T1 = T2)) = (metaReduce(M, T1) == metaReduce(M, T2)) .
  eq metaReduceCond(M, (T : S)) = sortLeq(M, leastSort(M, T), S) .
  eq metaReduceCond(M, (COND1 /\ COND2)) = metaReduceCond(M, COND1) and
                                           metaReduceCond(M, COND2) .

  --- apply a pair of substitutions to a condition; the first substitution
--- is applied to lhs, and the second one to rhs of each equality in condition
  op applySubstCond : EqCondition Substitution  ~> EqCondition .
  eq applySubstCond(nil, theta1) = nil .
  eq applySubstCond((T1 = T2), theta1) =
     (applySubst(T1, theta1) = applySubst(T2, theta1)) .
  eq applySubstCond((COND1 /\ COND2), theta1) =
     (applySubstCond(COND1, theta1) /\
      applySubstCond(COND2, theta1)) .
      
  op removeDuplicates : TermList -> TermList .
  eq removeDuplicates((TL, T, TL', T, TL'')) = 
     removeDuplicates((TL, T, TL', TL'')) .
  eq removeDuplicates(TL) = TL [owise] .
  
  op removeDuplicates : NsList{Equation} -> NsList{Equation} .
  eq removeDuplicates(EL :E: E :E: EL' :E: E :E: EL'') =
     removeDuplicates(EL :E: E :E: EL' :E: EL'')
  .
  eq removeDuplicates(EL) = EL [owise] .
  
  var THETA : Substitution .

  --- Get the list of terms within a substituion.
  op substToTermList : Substitution -> TermList .
  eq substToTermList(none) = empty .
  eq substToTermList(V <- T ; THETA) = (T, substToTermList(THETA)) .
  
  --- Checks whether the first term meta-matches the second one in a
  --- given module.
  op doesMetaMatch : Term Term Module -> Bool .
  
  ceq doesMetaMatch(T, T', M) = true
    if sameKind(M, leastSort(M, T), leastSort(M, T'))
    /\ theta := metaMatch(M, T, T', nil, 0)
    /\ theta :: Substitution
  .
  eq doesMetaMatch(T, T', M) = false [owise] .


  --- Returns all the sorts with the same kind of the provided sort
  --- from a certain module. 
  op getSortsClosure : Sort Module -> SortSet .
  eq getSortsClosure(S, M) = getSortsClosure'(S, M, getSorts(M)) .

  op getSortsClosure' : Sort Module SortSet -> SortSet .
  ceq getSortsClosure'(S, M, (S' ; SS)) = getSortsClosure'(S, M, SS)
    if not sameKind(M, S, S')
  .  
  eq getSortsClosure'(S, M, SS) = SS [owise] .

  op convImportList2QidList : ImportList -> QidList .
  eq convImportList2QidList(nil) = nil .
  eq convImportList2QidList((protecting Q .) IL) = Q convImportList2QidList(IL) .
  eq convImportList2QidList((extending Q .) IL) = Q convImportList2QidList(IL) . 
  eq convImportList2QidList((including Q .) IL) = Q convImportList2QidList(IL) .
  eq convImportList2QidList(I IL) = convImportList2QidList(IL) [owise] .

  op convEqList2EqSet : NsList{Equation} -> EquationSet .
  eq convEqList2EqSet(E :E: EL) = (E convEqList2EqSet(EL)) .
  eq convEqList2EqSet(nsnil-E) = none .
  
  op convEqSet2EqList : EquationSet -> NsList{Equation} .
  eq convEqSet2EqList(E ES) = (E :E: convEqSet2EqList(ES)) .
  eq convEqSet2EqList(none) = nsnil-E .

  op convQidList2VarSet : QidList -> NsSet{Variable} .
  
  eq convQidList2VarSet(nil)  = nsempty-V . 
  eq convQidList2VarSet(Q QL) = Q ;V; convQidList2VarSet(QL) .

  --- Outputs a qid list representing a provided set of variables
  op printVariables : NsSet{Variable} -> QidList .
  
  eq printVariables(nsempty-V)  = nil .
  eq printVariables((V ;V; VS)) = V printVariables(VS) .

  var ES-W ES-W' ES-L ES-L' ES-R           : EquationSet .
  var H-R                                  : Header .
  var I                                    : Import .
  var IL-W IL-W' IL-L IL-L' IL-R           : ImportList .
  var MAS-R                                : MembAxSet .
  var M-W M-L M-R                          : Module .
  var ODS-W ODS-W' ODS-L ODS-L' ODS-R      : OpDeclSet .
  var RLS-R RLS-W RLS-W' RLS-L RLS-L'      : RuleSet .
  var SS-W SS-W' SS-L SS-L' SS-R           : SortSet .
  var SSD                                  : SubsortDecl .
  var SSDS-W SSDS-W' SSDS-L SSDS-L' SSDS-R : SubsortDeclSet .
  
  
  op emptyLogModule : -> Module .
  eq emptyLogModule = (th 'M-LOG is nil sorts none .
                       none none none none none endth) .
  
  --- Creates a fth module, when provided all the elements.
  op createModule-mod : Qid ImportList SortSet SubsortDeclSet 
                        OpDeclSet MembAxSet EquationSet RuleSet -> Module .
  eq createModule-mod(H-R, IL-R, SS-R, SSDS-R, ODS-R, MAS-R, ES-R, RLS-R) =
    mod H-R is IL-R sorts SS-R . SSDS-R ODS-R MAS-R ES-R RLS-R endm
  .
    
  --- Calculates the union of two modules.
  op calcModuleUnion : Module Module Header -> Module .
  ceq calcModuleUnion(M-W, M-L, H-R) = M-R
    if IL-R   := calcImportListUnion(getImports(M-W), getImports(M-L))
    /\ SS-R   := calcSortSetUnion(getSorts(M-W), getSorts(M-L))
    /\ SSDS-R := calcSubsortDeclSetUnion(getSubsorts(M-W), getSubsorts(M-L))
    /\ ODS-R  := calcOpDeclSetUnion(getOps(M-W), getOps(M-L))
    /\ ES-R   := calcEqSetUnion(getEqs(M-W), getEqs(M-L))
    /\ RLS-R  := calcRlSetUnion(getRls(M-W), getRls(M-L))
    /\ M-R    := createModule-mod(H-R, IL-R, SS-R, SSDS-R, ODS-R, none, ES-R, RLS-R)
  .
  
  --- Calculates the union of two import lists.
  op calcImportListUnion : ImportList ImportList -> ImportList .
  eq calcImportListUnion((IL-W I IL-W'), (IL-L I IL-L')) =
    (I calcImportListUnion((IL-W IL-W'), (IL-L IL-L'))) .
  eq calcImportListUnion(IL-W, IL-L) = (IL-W IL-L) [owise] .
  
  --- Calculates the union between two sort sets.
  op calcSortSetUnion : SortSet SortSet -> SortSet .
  eq calcSortSetUnion((SS-W ; S ; SS-W'), (SS-L ; S ; SS-L')) =
    (S ; calcSortSetUnion((SS-W ; SS-W'), (SS-L ; SS-L'))) .
  eq calcSortSetUnion(SS-W, SS-L) = (SS-W ; SS-L) [owise] .
  
  --- Calculates the union between two subsort declaration sets.
  op calcSubsortDeclSetUnion : SubsortDeclSet SubsortDeclSet -> SubsortDeclSet .
  eq calcSubsortDeclSetUnion((SSDS-W SSD ), (SSDS-L SSD )) =
    (SSD calcSubsortDeclSetUnion((SSDS-W ), (SSDS-L ))) .
  eq calcSubsortDeclSetUnion(SSDS-W, SSDS-L) = (SSDS-W SSDS-L) [owise] .
  
  --- Calculates the union between two operator declaration sets.
  op calcOpDeclSetUnion : OpDeclSet OpDeclSet -> OpDeclSet .
  eq calcOpDeclSetUnion((ODS-W OD ), (ODS-L OD )) = 
    (OD calcOpDeclSetUnion((ODS-W ), (ODS-L )))
    .
  eq calcOpDeclSetUnion(ODS-W, ODS-L) = (ODS-W ODS-L)
    [owise] .
  
  --- Calculates the union between two sets of equations.
  op calcEqSetUnion : EquationSet EquationSet -> EquationSet .
  eq calcEqSetUnion((ES-W E ), (ES-L E )) =
    (E calcEqSetUnion((ES-W ), (ES-L ))) .
  eq calcEqSetUnion(ES-W, ES-L) = (ES-W ES-L) [owise] .
  
  --- Calculates the union between two sets of rules.
  var R : Rule .
  op calcRlSetUnion : RuleSet RuleSet -> RuleSet .
  eq calcRlSetUnion((RLS-W R ), (RLS-L R )) =
    (R calcRlSetUnion((RLS-W ), (RLS-L))) .
  eq calcRlSetUnion(RLS-W, RLS-L) = (RLS-W RLS-L) [owise] .
  
  --- Calculates the union of two modules.
  op calcModuleUnion' : Module Module Header -> Module .
  ceq calcModuleUnion'(M-W, M-L, H-R) = M-R
    if M := calcModuleUnion(M-W, M-L, H-R)
    /\ M-R := setOps(M, calcOpDeclSetUnion'(getOps(M-W), getOps(M-L)))
  .
  
  --- Calculates the union between two operator declaration sets s.t.:
  --- union((op Q : TyL -> Ty [AS] .), (op Q : TyL -> Ty [AS'] .)) =
  ---       (op Q : TyL -> Ty [AS AS'] .) 
  op calcOpDeclSetUnion' : OpDeclSet OpDeclSet -> OpDeclSet .
  eq calcOpDeclSetUnion'((ODS-W (op Q : TyL -> Ty [AS] .) ),
                         (ODS-L (op Q : TyL -> Ty [AS'] .) )) = 
     (op Q : TyL -> Ty [AS AS'] .) calcOpDeclSetUnion'((ODS-W ), (ODS-L ))
  .
  eq calcOpDeclSetUnion'(ODS-W, ODS-L) = (ODS-W ODS-L) [owise] .
  
  --- Calculates the difference bewtween two modules.
  op calcModuleDiff : Module Module Header -> Module .
  ceq calcModuleDiff(M-W, M-L, H-R) = M-R
    if IL-R   := calcImportListDiff(getImports(M-W), getImports(M-L))
    /\ SS-R   := calcSortSetDiff(getSorts(M-W), getSorts(M-L))
    /\ SSDS-R := calcSubsortDeclSetDiff(getSubsorts(M-W), getSubsorts(M-L))
    /\ ODS-R  := calcOpDeclSetDiff(getOps(M-W), getOps(M-L))
    /\ ES-R   := calcEqSetDiff(getEqs(M-W), getEqs(M-L))
    /\ RLS-R  := calcRlSetDiff(getRls(M-W), getRls(M-L))
    /\ M-R    := createModule-mod(H-R, IL-R, SS-R, SSDS-R, ODS-R, none, ES-R, RLS-R)
  .
  
  --- Calculates the difference between two import lists.
  op calcImportListDiff : ImportList ImportList -> ImportList .
  eq calcImportListDiff((IL-W I IL-W'), (IL-L I IL-L')) = 
    calcImportListDiff((IL-W IL-W'), (IL-L IL-L')) .
  eq calcImportListDiff(IL-W, IL-L) = IL-W [owise] .
  
  --- Calculates the difference between two sort sets.
  op calcSortSetDiff : SortSet SortSet -> SortSet .
  eq calcSortSetDiff((SS-W ; S), (SS-L ; S)) =
    calcSortSetDiff((SS-W), (SS-L)) .
  eq calcSortSetDiff(SS-W, SS-L) = SS-W [owise] .
  
  --- Calculates the difference between two subsort declaration sets.
  op calcSubsortDeclSetDiff : SubsortDeclSet SubsortDeclSet -> SubsortDeclSet .
  eq calcSubsortDeclSetDiff((SSDS-W SSD), (SSDS-L SSD)) =
     calcSubsortDeclSetDiff((SSDS-W), (SSDS-L)) .
  eq calcSubsortDeclSetDiff(SSDS-W, SSDS-L) = SSDS-W [owise] .
  
  --- Calculates the difference between two operator declaration sets.
  op calcOpDeclSetDiff : OpDeclSet OpDeclSet -> OpDeclSet .
  eq calcOpDeclSetDiff((ODS-W OD), (ODS-L OD)) = 
     calcOpDeclSetDiff((ODS-W), (ODS-L)) .
  eq calcOpDeclSetDiff(ODS-W, ODS-L) = ODS-W [owise] .
  
  --- Calculates the difference between two sets of equations.
  op calcEqSetDiff : EquationSet EquationSet -> EquationSet .
  eq calcEqSetDiff((ES-W E), (ES-L E)) =
     calcEqSetDiff((ES-W), (ES-L)) .
  eq calcEqSetDiff(ES-W, ES-L) = ES-W [owise] .
  
  --- Calculates the difference between two sets of rules.
  op calcRlSetDiff : RuleSet RuleSet -> RuleSet .
  eq calcRlSetDiff((RLS-W R), (RLS-L R)) =
     calcRlSetDiff((RLS-W), (RLS-L)) .
  eq calcRlSetDiff(RLS-W, RLS-L) = RLS-W [owise] .
  
endfm --- BASIC-DATA-TYPES



***( ===========================================================================
*
* ============================================================================ )

fmod DATA-TYPES is

  including BASIC-DATA-TYPES .

  var AS             : AttrSet .
  var C              : Constant .
  var COND           : EqCondition .
  var I J            : Int .
  var T T' T1 T1'    : Term .
  var U U'           : Term .
  var V              : Variable .
  var TL             : TermList .
  var SUBST          : Substitution .
  var theta? theta'? : Substitution? .
  var theta''?       : Substitution? .
  var Q              : Qid .
  var M              : Module .

  --- substitution pairs
  sorts NeSubstPair SubstPair SubstPair? .
  subsort NeSubstPair < SubstPair < SubstPair? .
  op <_,_> : Substitution? Substitution? -> SubstPair? .
  cmb < theta?, theta'? > : SubstPair
    if theta? :: Substitution and theta'? :: Substitution .
  cmb < theta?, theta'? > : NeSubstPair
    if theta? :: Substitution and theta'? :: Substitution and
       theta? =/= none and theta'? =/= none .

  --- Tries to find a corresponding matching at top between the pairs (U, U')
  --- and (T, T') if a condition COND is reduced to true.
  --- Returns a pair of substitutions corresponding to the matchings
  --- U <? T and U' <? T'
  op metaMatchPairCond : Module Term Term Term Term EqCondition ->
                         Substitution? .
  op metaMatchPairCond : Module Term Term Term Term EqCondition Int Int ->
                         Substitution? .
  eq metaMatchPairCond(M, U, U', T, T', COND) =
     metaMatchPairCond(M, U, U', T, T', COND, 0, 0)
  ---[print U T]
  .
  ceq metaMatchPairCond(M, U, U', T, T', COND, I, J) = theta''?
    if theta?   := metaMatch(M, U, T, nil, I)
    /\ theta'?  := metaMatch(M, U', T', nil, J)
    /\ theta?   :: Substitution
    /\ theta'?  :: Substitution
    /\ theta''? := (theta? ; theta'?)
    /\ isFunctional(theta''?)
    /\ metaReduceCond(M, applySubstCond(COND, theta''?)) = true
    ---[print "repeat ---------------------"]
  .
  ceq metaMatchPairCond(M, U, U', T, T', COND, I, J) =
      metaMatchPairCond(M, U, U', T, T', COND, I + 1, J)
    if theta?  := metaMatch(M, U, T, nil, I)
    /\ theta'? := metaMatch(M, U', T', nil, J)
    /\ theta?  :: Substitution
    /\ theta'? :: Substitution
    /\ theta''? := (theta? ; theta'?)
    /\ isFunctional(theta''?)
    /\ metaReduceCond(M, applySubstCond(COND, theta''?)) =/= true
  .
  ceq metaMatchPairCond(M, U, U', T, T', COND, I, J) =
      metaMatchPairCond(M, U, U', T, T', COND, 0, J + 1)
    if theta?  := metaMatch(M, U, T, nil, I)
    /\ theta'? := metaMatch(M, U', T', nil, J)
    /\ theta?  :: Substitution = false
    /\ theta'? :: Substitution
    /\ theta''? := theta'?
    /\ isFunctional(theta''?)
    /\ metaReduceCond(M, applySubstCond(COND, theta''?)) =/= true
  .
  ceq metaMatchPairCond(M, U, U', T, T', COND, I, J) = none
    if theta?   := metaMatch(M, U, T, nil, I)
    /\ theta'?  := metaMatch(M, U', T', nil, J)
    ---[print "\n" U "\n" U' "\n" T "\n" T' "\n" theta? " " theta'? owise]
  .
  
  op isFunctional : Substitution -> Bool .
  ceq isFunctional(V <- T ; V <- T' ; SUBST) = false if T =/= T' .
  eq isFunctional(SUBST) = true [owise] .
  
  --- checks if the provided term is a constant
  op isConstant : Term -> Bool .
  eq isConstant(C) = true .
  eq isConstant(T) = false [owise] .
  
  --- checks if the provided term is a variable
  op isVariable : Term -> Bool .
  eq isVariable(V) = true .
  eq isVariable(T) = false [owise] .

endfm  --- DATA-TYPES


***( ===========================================================================
*
* ============================================================================ )

fmod EQ-MANAGER is

  including DATA-TYPES .

  var B              : Bool .
  var COND COND'     : EqCondition .
  var Q Q'           : Qid .
  var FrV FrV' FrV'' : Qid .
  var N I            : Int .
  var FnR FnR'       : FindResult .
  var STR            : String .
  var T T' T'' T1 T2 : Term .
  var TL             : TermList .
  var V V' V''       : Variable .
  var E              : Equation .
  var ES             : EquationSet .
  var SS SS'         : SortSet .
  var S S' SI S1 S2  : Sort .
  var SSDS           : SubsortDeclSet .
  var EL             : NsList{Equation} .
  var C              : Constant .
  var M              : Module .
  var IL             : ImportList .
  var ODS            : OpDeclSet .
  var MAS            : MembAxSet .
  var AS             : AttrSet .
  var SL             : TypeList .


  --- COINDUCTION
  -----------------------------------------------------------------------------
  
  --- adds for each sort s in SortSet an operation declaration
  --- to OpDeclSet, of an operation "#*_*# : s -> Frozen"
  op addCoFreezingSorts : SortSet OpDeclSet -> OpDeclSet .
  eq addCoFreezingSorts(none, ODS) = ODS .
  eq addCoFreezingSorts((S ; SS), ODS) =
    addCoFreezingSorts(SS, ((op '#*_*# : S -> 'Frozen [ strat(1 0) ] .) ODS)) .

  --- adds to a module a new sort "Frozen" and
  --- an operator "#*_*# : s -> Frozen" for each sort s
  var RS : RuleSet .
  op addCoFreezingSorts : Module -> Module .

  eq addCoFreezingSorts(mod Q is IL sorts SS . SSDS ODS MAS ES RS endm) =
    mod Q is IL sorts (SS ; 'Frozen) .
    SSDS addCoFreezingSorts(SS, ODS) MAS ES RS endm
  .

  --- adds the operator fr on top of terms in equations
  op coFreeze : EquationSet -> EquationSet .

  eq coFreeze((none).EquationSet) = (none).EquationSet .
  eq coFreeze((eq T = T' [AS] .) ES) =
     (eq '#*_*#[removeCoFreezing(T)] =
          '#*_*#[removeCoFreezing(T')] [AS] .)
     coFreeze(ES)
  .
  eq coFreeze((ceq T = T' if COND [AS] .) ES) =
     (ceq '#*_*#[removeCoFreezing(T)] =
          '#*_*#[removeCoFreezing(T')] if COND [AS] .)
     coFreeze(ES)
  .

  --- adds the operator fr on top of terms in equations
  op coFreezeCond : EqCondition -> EqCondition .
  eq coFreezeCond(T = T') = ('#*_*#[T] = '#*_*#[T']) .
  eq coFreezeCond(T : S) = (T : S) .
  eq coFreezeCond(T := T') = ('#*_*#[T] := '#*_*#[T']) .
  eq coFreezeCond(COND /\ COND') = coFreezeCond(COND) /\ coFreezeCond(COND') .
  eq coFreezeCond(nil) = nil .

  --- deletes the freezing operator from the top of a term or equation
  op removeCoFreezing : TermList -> TermList .
  op removeCoFreezing : NsList{Equation} -> NsList{Equation} .
  eq  removeCoFreezing(V)       = V .
  eq  removeCoFreezing(C)       = C .
  eq  removeCoFreezing('#*_*#[T])  = T .
  ceq removeCoFreezing(Q[TL])   = Q[TL] if Q =/= '#*_*# .
  eq  removeCoFreezing((T, TL)) = removeCoFreezing(T), removeCoFreezing(TL) .
  eq removeCoFreezing(nsnil-E) = nsnil-E .
  eq removeCoFreezing((eq T = T' [AS] .) :E: EL) =
     (eq removeCoFreezing(T) = removeCoFreezing(T') [AS] .) :E:
     removeCoFreezing(EL)
  .
  eq removeCoFreezing((ceq T = T' if COND [AS] .) :E: EL) =
     (ceq removeCoFreezing(T) = removeCoFreezing(T') if COND [AS] .) :E:
     removeCoFreezing(EL)
  .

  --- INDUCTION
  -----------------------------------------------------------------------------
  
  op indFreezer : -> String .
  eq indFreezer = "#" .

  op parseIndVar : Variable -> Variable .  
  ceq parseIndVar(V) = V
    if rfind(
         string(getName(V)),
         indFreezer,
         length(string(getName(V)))
       ) == notFound
  .
  ceq parseIndVar(V) = 
      qid(
        substr(string(getName(V)), 0, FR:FindResult) + ":" +
        string(getType(V))
      )
    if FR:FindResult := rfind(
                          string(getName(V)),
                          indFreezer,
                          length(string(getName(V)))
                        )
    /\ FR:FindResult =/= notFound
  .


  sort EqListNatUple GoalsNatUple .
  
  op ELN<_,_,_> : NsList{Equation} Nat NsSet{IndSource} -> EqListNatUple .
  op GLN<_,_,_> : NsList{Goal}     Nat NsSet{IndSource} -> GoalsNatUple .


  op indFreeze : Equation NsSet{Variable} Nat NsList{InductionUple} NsSet{IndSource} ->
                 EqListNatUple .
  ceq indFreeze(E, V, N, IUL, ISS) = ELN< E' , (N + 1) , ISS' >
    if ( IUL1 :IU: < V , S , S' > :IU: IUL2 ) := IUL
    /\ S := getType(V)
    /\ V' := qid(string(getName(V)) + indFreezer + string(N, 10) + ":" +
             string(S'))
    /\ E' := replace(E, V, V')
    /\ ISS' := (V' ! S -o V) ;IS; replace(ISS, V, V')
---[print "AAAAAAAAAAAAAAAAAAAAAAAA" V "    " V']
  .
  ceq indFreeze(E, (V ;V; VS), N, IUL, ISS) = indFreeze(E', V, N', IUL, ISS)
    if VS =/= nsempty-V
    /\ ELN< E', N', ISS' > := indFreeze(E, VS, N, IUL, ISS)
  .
***(
  ceq indFreeze(E, V, N, IUL, ISS) = ELN< E , (N + 1) , ISS >
    if true = true
[owise]
    ---[print IUL V owise]
  .
)
  
  var ISS' : NsSet{IndSource} .
  var GL GL'   : NsList{Goal} .
  
  op indFreeze : NsList{Goal} NsSet{Variable} Nat NsList{InductionUple} NsSet{IndSource} ->
                 GoalsNatUple .
  eq indFreeze(nsnil-G, VS, N, IUL, ISS) = GLN< nsnil-G , N , ISS > .
  ceq indFreeze(eq2goal(E) :G: GL, VS, N, IUL, ISS) = GLN< eq2goal(E') :G: GL' , N'' , ISS'' >
    if ELN< E' , N' , ISS' > := indFreeze(c2v(E), VS, N, IUL, ISS)
    /\ GLN< GL' , N'' , ISS'' > := indFreeze(GL, VS, N', IUL, ISS')
---[print VS ]
  .
***(
  ceq indFreeze(eq2goal(E) :G: GL, VS, N, IUL, ISS) = GLN< GL , N , ISS >
    if true = true 
    /\ ELN< E' , N' , ISS' > := indFreeze(c2v(E), VS, N, IUL, ISS)
    ---[print owise]
  .)
   
    
  var VSL VSL' : NsList{NsSet{Variable}} .
  var VS-EQ VS-EQ' VS-EQ'' : NsSet{Variable} .
  var V-EQ : Variable .
  var SS-IND : SortSet .

  --- Generates the induction uples for a given set of variables.
  --- Only inductive sorts are taken into consideration.
  op genIndsUples : NsSet{Variable} Module SortSet -> NsList{InductionUple} .
  eq genIndsUples(nsempty-V, M, SS-IND) = nsnil-IU .
  eq genIndsUples((V ;V; VS), M, SS-IND) =
      genIndUples(V, M, SS-IND) :IU: genIndsUples(VS, M, SS-IND)
  .
  
  --- Generates the induction uples for a given variable.
  --- genIndUples' receives the closure of the variable sort.
  op genIndUples : Variable Module SortSet -> NsList{InductionUple} .
  eq genIndUples(V, M, SS-IND) =
     genIndUples'(V, getSortsClosure(getType(V), M), SS-IND)
  .
  
  op genIndUples' : Variable SortSet SortSet -> NsList{InductionUple} .
  eq genIndUples'(V, none, SS-IND) = nsnil-IU .
  eq genIndUples'(V, (S ; SS), SS-IND) =
     if isSortInSortSet(S, SS-IND)
       then < V , S , qid(string(S) + "<" + string(getName(V)) + ">") >
       else nsnil-IU
     fi
     :IU: genIndUples'(V, SS, SS-IND)
  .


  --- Returns the prioritary variable for applying the induction and
  --- the new priority list.
  ---
  --- Input:
  ---   The variables from the equation
  ---   The induction variables
  ---   The priority list
  ---
  op getPrioIndVar : NsSet{Variable} NsList{NsSet{Variable}}
                     NsList{InductionUple} -> TrmVarSetListUple
  .

  --- If we have only one variable left, check if we find it in the
  --- induction uple list.
  ceq getPrioIndVar(V-EQ, VSL, IUL) = TVSL< V , VSL > 
    if (IUL' :IU: < V , S , S' > :IU: IUL'') := IUL
    /\ getName(parseIndVar(V-EQ)) == getName(V)
  .

  --- If we have more than one variable left and if one of the variables
  --- is prioritary, then lower its priority (Round Robin) and return it.
  ceq getPrioIndVar(VS-EQ, VSL, IUL) = TVSL< V , (V :VSL: VSL' :VSL: VS) > 
    if (VS-EQ' ;V; V-EQ) := VS-EQ
    /\ VS-EQ' =/= nsempty-V
    /\ (VSL' :VSL: (VS ;V; V)) := VSL
    /\ (IUL' :IU: < V , S , S' > :IU: IUL'') := IUL
    /\ S' := getType(V-EQ)
    /\ getName(parseIndVar(V-EQ)) == getName(V)
  .
  eq getPrioIndVar(VS-EQ, (VSL :VSL: (VS ;V; V)), IUL) =
     appendVarSet((VS ;V; V), getPrioIndVar(VS-EQ, VSL, IUL))
     [owise]
  .

  op getInductiveSorts : NsList{InductionUple} -> SortSet .
  eq getInductiveSorts(nsnil-IU) = none .
  eq getInductiveSorts(IUL :IU: < V , S , S' >) =
     S' ; getInductiveSorts(IUL)
  .

  op getNewSubsorts : NsList{InductionUple} -> SubsortDeclSet .
  
  eq getNewSubsorts(nsnil-IU) = none .
  eq getNewSubsorts(< V , S , S' > :IU: IUL) =
     (subsort S' < S .) getNewSubsorts(IUL)
  .
  
  op getNewSorts :  NsList{InductionUple} -> SortSet .
  eq getNewSorts(nsnil-IU) = none .
  eq getNewSorts(< V , S , S' > :IU: IUL) =
     S' ; getNewSorts(IUL)
  .
  
  --- Searches for the provided external variable (sort has no <>'s) in
  --- the set of inductive uples. The variable must be in the equation
  --- under a frozen form (i.e. it needs to have an ##indFreezer## ("#") ).
  op getIndVarInt : Equation Variable NsList{InductionUple} Module -> Variable .
  ceq getIndVarInt(E, V, IUL, M) = V'
    if (V' ;V; VS) := getVarsIndFrozen(E, IUL)
    /\ (IUL1 :IU: < V'' , S , S' > :IU: IUL2) := IUL
    /\ getType(V') == S'
    /\ getName(V) == getName(V'')
    /\ sameKind(M, getType(V), getType(V''))
  .
  
  op getVarsIndFrozen : Equation NsList{InductionUple} -> NsSet{Variable} .
  eq getVarsIndFrozen(E, IUL) = getVarsIndFrozen'(getVars(E), IUL) .
  
  op getVarsIndFrozen' : NsSet{Variable} NsList{InductionUple} ->
                         NsSet{Variable} .
  eq getVarsIndFrozen'(nsempty-V, IUL) = nsempty-V .
  ceq getVarsIndFrozen'((V ;V; VS), (IUL :IU: < V1 , S , S' > :IU: IUL')) =
      V ;V; getVarsIndFrozen'(VS, (IUL :IU: < V1 , S , S' > :IU: IUL'))
    if S' := getType(V)
  .
  eq getVarsIndFrozen'((V ;V; VS), (IUL :IU: < V1 , S , S' > :IU: IUL')) =
     getVarsIndFrozen'(VS, (IUL :IU: < V1 , S , S' > :IU: IUL'))
     [owise]
  .
  
  op calcIndHypo : Equation Variable -> Equation .
  ceq calcIndHypo(E, V) = replace(E, C, V)
    if C := v2c(V) 
  .

  sort TermPair .

  op  pair  : Term Term -> TermPair .
  ops p1 p2 : TermPair  -> Term .
  eq p1(pair(T,T')) = T .
  eq p2(pair(T,T')) = T' .

--- TBD : implement a new orientation algorithm
--- orients an equation according to two criteria, lexicographically:
--- first inclusion between the set of variables
--- then number of symbols
--- The case when there is no inclusion
--- between the sets of variables is irrelevant, and
--- treated randomnly, since then the equation would not
--- be accepted as a rewrite rule in Maude anyway.
---
--- true  ~ >=
--- false ~ <
  op orient : TermPair Bool -> TermPair .
  op orient : Equation Bool -> Equation .

 --- pairs of terms
  eq orient(pair(T,T'), B) =
    ---if not(getVars(T) eql getVars(T'))
    if not(subset(getVars(T ), getVars(T')) and --- equality check
           subset(getVars(T'), getVars(T ))
          )
      then
        if subset(getVars(T),getVars(T'))
          then (pair(T',T))
          else (pair(T,T'))
        fi
      else
        if (B == true)
          then
            if noSym(T) >= noSym(T')
              then (pair(T,T'))
              else (pair(T',T))
            fi
          else
            if noSym(T) < noSym(T')
              then (pair(T,T'))
              else (pair(T',T))
            fi
        fi
    fi .

  --- equations
  eq orient(ceq T = T' if COND [AS] ., B) =
    (ceq p1(orient(pair(T,T'), B)) = p2(orient(pair(T,T'), B))
    if COND [AS] .) .

  --- checks whether a term has a certain sort
  --- in a module;
  --- RIGHT NOW IT ONLY CHECKS EQUALITY OF
  --- leastSort(T) with S
  --- modified (DL):
  op isOfSort : Module Term Sort -> Bool .

  --- eq isOfSort(M, T, S) = leastSort(M,T) == S .
  eq isOfSort(M, T, S) = sameKind(M, leastSort(M,T), S) .


  --- coExpand(E, TL, M) expands the equation E to a list of equations,
  --- by adding appropriate outer star terms (i.e., contexts)
  --- from TL;
  op coExpand : Equation TermList Module -> NsList{Equation} .

  --- "appropriate" is w.r.t. the op. decl. list in the module;
  --- note also that equations are assumed frozen
  --- and '#*_*# is kept on top
  ceq coExpand((ceq '#*_*#[T] = '#*_*#[T'] if COND [AS] .), (T1, TL), M)
    = (ceq '#*_*#[T1 < T >] = '#*_*#[T1 < T' >] if COND [AS] .) :E:
      coExpand((ceq '#*_*#[T] = '#*_*#[T'] if COND [AS] .), TL, M)
    if isOfSort(M, T , getSortsHidden(T1))
    /\ isOfSort(M, T', getSortsHidden(T1))
  .
  eq coExpand(E, (T1, TL), M) = coExpand(E, TL, M) [owise] .
  eq coExpand(E, empty, M) = nsnil-E .
  
  --- Remove unbounded variables from the condition of an equation.
  op cleanEquation  : Equation Module -> Equation .
  op cleanEquations : NsList{Equation} Module -> Equation .
  eq cleanEquation((ceq T = T' if COND [AS] .), M) =
     ceq T = T' if cleanCondition(COND, T, M) [AS] .
  .
  eq cleanEquations(nsnil-E, M) = nsnil-E .
  eq cleanEquations(E :E: EL, M) =
     cleanEquation(E, M) :E: cleanEquations(EL, M) .
  
  --- Remove unbounded variables from the condition when provided a term.
  var T-LHS : Term .
  op cleanCondition : Condition Term Module -> Condition .
  
  ceq cleanCondition(COND /\ (T = T') /\ COND', T-LHS, M) =
      cleanCondition(COND /\ COND', T-LHS, M)
    if isDirty(T, T-LHS, M)
  .
  eq cleanCondition (COND, T-LHS, M) = COND [owise] .
  
  --- Checks if the first term is a constant & a subterm of the second one.
  op isDirty : Term Term Module -> Bool .
  ceq isDirty(C, T', M) = BB:Bool
    if MP? := metaXmatch(M, C, T', nil, 0, unbounded, 0)
    /\ BB:Bool := not(MP? :: MatchPair)
  .
  eq isDirty(T, T', M) = false [owise] .

  --- ----------------------------------
  --- Functions for induction expanding:
  --- ----------------------------------
  var SS1 SS2 : SortSet .
  var SSDS1 SSDS2 : SubsortDeclSet .
  var SSD         : SubsortDecl .
  
  --- Returns all the subsorts of any depth for a given sort when provided
  --- a subsort declaration set.
  op getSubsorts : SortSet SubsortDeclSet -> SortSet .
  
  ---eq getSubsorts(SS, none) = SS .
  eq getSubsorts((SS1 ; S ; SS2), (SSDS1 (subsort S1 < S .) SSDS2)) =
     getSubsorts((SS1 ; S ; SS2 ; S1), (SSDS1 SSDS2)) .
  eq getSubsorts(SS, SSDS) = SS [owise] .
  

  var VS : NsSet{Variable} .
  var IUL IUL' IUL'' IUL1 IUL2 : NsList{InductionUple} .
  var ISS ISS'' : NsSet{IndSource} .
  var IU       : InductionUple .
  var V1       : Variable .
  var EL1 EL2  : NsList{Equation} .
  var N1 N2 N' N''  : Nat .
  var E' : Equation .
 
  op isSortInSortSet : Sort SortSet -> Bool .
  eq isSortInSortSet(S, (S ; SS)) = true .
  eq isSortInSortSet(S, SS) = false [owise] .

  --- An induction uple consists of:
  ---   the induction variable
  ---   a sort S in the kind of the induction variable
  ---   an internal sort, generated as a subsort of S
  ---
  --- E.g.:  < N:List , NeList , NeList<N> >   
  op <_,_,_> : Variable Sort Sort -> InductionUple .
  
  --- Expands a frozen equation over the provided
  --- internal (frozen) induction variable.
  --- The constructors and all subsort declarations are provided.
  --- The set of inductive sorts is also provided.
  op indExpand : Equation Variable Nat OpDeclSet SubsortDeclSet
                 NsList{InductionUple} NsSet{IndSource} SortSet
                 ->
                 EqListNatUple .
  
  ceq indExpand(E, V, N, ODS, SSDS, IUL, ISS, SS) =
      ELN< EL1 :E: EL2 , N2 , (ISS ;IS; ISS' ;IS; ISS'') >
    if ELN< EL1, N1 , ISS' > := indExpandCtor(E, V, N, ODS, IUL, ISS)
    /\ ELN< EL2, N2 , ISS'' > := indExpandSubSort(E, V, N1, SSDS, IUL, SS, ISS)
    ---[print ISS']
  .
  
  sort TrmLstNatUple .
  op TLN<_,_> : TermList Nat -> TrmLstNatUple .
  
  op addTerm : Term TrmLstNatUple -> TrmLstNatUple .
  eq addTerm(T, TLN< TL , N >) = TLN< (T, TL) , N > .
  
  --- the constructor part of indExpand
  op indExpandCtor : Equation Variable Nat OpDeclSet 
                     NsList{InductionUple} NsSet{IndSource}
                     ->
                     EqListNatUple .


  --- constant constructor
  ceq indExpandCtor(E, V, N, (op Q : SL -> S [AS] .) ODS, IUL, ISS) =
      ELN< E' :E: EL , N' , ISS ;IS; ISS'' >
    if SL == nil
    /\ (IUL1 :IU: < V' , S , S1 > :IU: IUL2) := IUL
    /\ getType(V) == S1
    /\ getName(parseIndVar(V)) == getName(V')
    /\ T' := qid(string(Q) + "." + string(S))
    /\ E' := replace(E, V, T')
    /\ ELN< EL , N' , ISS'' > := indExpandCtor(E, V, N, ODS, IUL, ISS)
  .
  
  sort ISSTLUple .
  op ISSTL<_,_> : NsSet{IndSource} TermList -> ISSTLUple .

  --- non-constant constructor
  ceq indExpandCtor(E, V, N, (op Q : SL -> S [AS] .) ODS, IUL, ISS) =
      ELN< E' :E: EL , N'' , ISS ;IS; ISS' ;IS; ISS'' >
    if SL =/= nil
    /\ (IUL1 :IU: < V' , S , S1 > :IU: IUL2) := IUL
    /\ getType(V) == S1
    /\ getName(parseIndVar(V)) == getName(V')
    /\ TLN< TL , N' > := calcCtorParams(V, N, SL, IUL)
    /\ ISSTL< ISS' , TL' > := assignSources(V, TL, ISS, IUL, S)
    /\ T' := Q[TL']
    /\ E' := replace(E, V, T')
    /\ ELN< EL , N'' , ISS'' > := indExpandCtor(E, V, N', ODS, IUL, ISS)
    ---[print "Attempt: \n" "Q: " Q "\n" "V: " V "\n" "TL: " TL "\n" "TL':" TL' "\n" "IUL: "  IUL 
    ---"\n" "ISS: " ISS "\n" "ISS': " ISS' "\n\n"]
  .

  ***(
  --- add maps: {(L, List) |-> L , (T, List) |-> L , (T, Tree) |-> T}
  c(y1:s1, ... , yn:sn)
  foreach i = 1,n
    if (exists (v ! si -o z) in indSource)   v -> current expanding variable
    then add(indSource, (yi ! si -o z))
    else add(indSource, (yi ! si -o yi))
    fi
  add(indSource, (yi, s) |-> z), where (v ! s -o z) in indSource
  --- also, automatically add new variables when needed
  ***)

  var S-RES : Sort . --- result sort for op
  var TL' : TermList .
  var ISS1 : NsSet{IndSource} .

  --- initial variable
  --- new variables
  --- ISS
  --- IUL
  --- resulting sort
  op assignSources : Variable TermList NsSet{IndSource} NsList{InductionUple} Sort -> ISSTLUple .

  --- the variable has a direct source
  var V-IND : Variable .
  ---eq assignSources(V-IND, T, ISS, IUL, S-RES) = ISS ---[print "Unhandled: \n"  "=========" owise] .

  --- direct source
  ceq assignSources(V-IND, T, ISS, IUL, S-RES) = ISSTL< addAlternativeSource(V-IND, T, ISS', S-RES) , T >
    if ISS1 ;IS; (V-IND ! S -o V ) := ISS
    /\ parseIndVar(V-IND) == parseIndVar(T) --- direct source
    /\ ISS' :=  (T ! S -o V) ;IS; ISS
  .

  --- indirect source
  ceq assignSources(V-IND, T, ISS, IUL, S-RES) = ISSTL< addAlternativeSource(V-IND, Q, ISS', S-RES) , Q >
    if ISS1 ;IS; (V-IND ! S -o V ) := ISS
    /\ getType(T) == S
    /\ (IUL1 :IU: < V , S , S1 > :IU: IUL2) := IUL
    /\ Q := qid(string(getName(T)) + ":" + string(S1))
    /\ ISS' :=  (Q ! S -o V) ;IS; ISS
  .

  --- the variable is new
  ceq assignSources(V-IND, T, ISS, IUL, S-RES) = ISSTL< addAlternativeSource(V-IND, T, ISS', S-RES) , T >
    if ISS' :=  (T ! getType(T) -o T) ;IS; ISS
    [owise]
  .
  
  op addAlternativeSource : Variable TermList NsSet{IndSource} Sort -> NsSet{IndSource} .
  ceq addAlternativeSource(V-IND, T, ISS, S-RES) = ISS'
    if ISS1 ;IS; (V-IND ! S-RES -o V ) := ISS
    /\ ISS' := (T ! S-RES -o V) ;IS; ISS
  .
  eq addAlternativeSource(V-IND, T, ISS, S-RES) = ISS [owise] .

  
  var ISS2 : NsSet{IndSource} .
  var TL1 TL2 : TermList .
  ceq assignSources(V-IND:Variable, (TL , TL'), ISS, IUL, S-RES) =
      ISSTL< ISS1 ;IS; ISS2 , (TL1 , TL2) >
    if TL =/= empty
    /\ TL' =/= empty
    /\ ISSTL< ISS1, TL1 > := assignSources(V-IND:Variable, TL, ISS, IUL, S-RES)
    /\ ISSTL< ISS2, TL2 > := assignSources(V-IND:Variable, TL', ISS, IUL, S-RES)
  .

  
  eq indExpandCtor(E, V, N, ODS, IUL, ISS) = ELN< nsnil-E, N , ISS > [owise] .
  
  
  --- Generates internal variables for expanding non-constant constructors.
  op calcCtorParams : Variable Nat TypeList NsList{InductionUple} ->
                      TrmLstNatUple
  .

  eq calcCtorParams(V, N, nil, IUL) = TLN< empty , N > .
  
  --- when S is inductive
  ceq calcCtorParams(V, N, (S SL), IUL) =
      TLN< (T', TL) , N' >
    if (IUL1 :IU: < V' , S1 , S2 > :IU: IUL2) := IUL
    /\ S == S1
    /\ getName(parseIndVar(V)) == getName(V')
    /\ T' := qid(string(getName(V')) + indFreezer + string(N, 10) + ":" +
             string(S2))
    /\ TLN< TL , N' > := calcCtorParams(V, (N + 1), SL, IUL)
  .
  
  --- when S is not inductive
  eq calcCtorParams(V, N, (S SL), IUL) =
     addTerm(
       qid( 
         string(getName(parseIndVar(V)))+ indFreezer +
         string(N, 10) + ":" + string(S)
       ),
       calcCtorParams(V, N + 1, SL, IUL ))
     [owise]
  .
  
  var IUL1' IUL2' : NsList{InductionUple} .
  var S1' S2'     : Sort .
  
  
  op indExpandSubSort : Equation Variable Nat SubsortDeclSet
                        NsList{InductionUple} SortSet NsSet{IndSource}
                        ->
                        EqListNatUple .
   
  ceq indExpandSubSort(E, V, N, (subsort S1 < S .) SSDS, IUL, SS, ISS) =
      ELN< E' :E: EL , N' , ISS >
    if (IUL1 :IU: < V' , S1 , S2 > :IU: IUL2) := IUL
    /\ (IUL1' :IU: < V'' , S , S2' > :IU: IUL2') := IUL
    /\ getName(parseIndVar(V)) == getName(V')
    /\ V' == V''
    /\ getType(V) == S2'
    /\ T' := qid(string(getName(V')) + indFreezer + string(N, 10) + ":" + string(S2))
    /\ E' := replace(E, V, T')
    /\ ELN< EL , N' , ISS > := indExpandSubSort(E, V, (N + 1), SSDS, IUL, SS, ISS)
  .
  
  ceq indExpandSubSort(E, V, N, (subsort S1 < S .) SSDS, IUL, SS, ISS) =
      ELN< E' :E: EL , N' , ISS >
    if (not isSortInSortSet(S1, SS))
    /\ T' := qid(string(getName(parseIndVar(V))) + 
             indFreezer + string(N, 10) + ":" + string(S1))
    /\ E' := replace(E, V, T')
    /\ ELN< EL , N' , ISS > := indExpandSubSort(E, V, (N + 1), SSDS, IUL, SS, ISS)
    /\ (IUL1 :IU: < V' , S , S' > :IU: IUL2) := IUL
    /\ S' == getType(V)
  .
  
  eq indExpandSubSort(E, V, N, SSDS, IUL, SS, ISS) = ELN< nsnil-E , N , ISS > [owise] .

  
  
  
  --- AS U {comm}^{0..1} U {assoc}^{0..1} -> {comm}^{0..1} U {assoc}^{0..1}
  op filterIdemUnit : AttrSet -> AttrSet .
  
  eq filterIdemUnit(idem AS) = filterIdemUnit(AS) .
  eq filterIdemUnit(left-id(T) AS) = filterIdemUnit(AS) .
  eq filterIdemUnit(right-id(T) AS) = filterIdemUnit(AS) .
  eq filterIdemUnit(id(T) AS) = filterIdemUnit(AS) .
  eq filterIdemUnit(AS) = AS [owise] .
  

  var CNJL : NsList{Goal} .
  var M'   : Module .
  var OD   : OpDecl .
  var TyL   : TypeList .
  var Ty Ty' Ty''   : Type .
  var AS'   : AttrSet .
  var ODS'  : OpDeclSet .
  var Att  : Attr .

  op addTheorems : NsList{Goal} Module -> Module .
  eq addTheorems(nsnil-G, M) = M .
  ceq addTheorems(eq2goal(E) :G: CNJL, M) = addTheorems(CNJL, M')
    if M' := addEqs(E, M)
  .
  ---eq addTheorems(op2goal(OD) :G: CNJL, M) = M .
  ***()
  ceq addTheorems(op2goal(OD) :G: CNJL, M) = addTheorems(CNJL, M')
    if (op Q : Ty' Ty'' -> Ty [AS] .) := OD
    /\ ODS := getOps(M)
    /\ ((op Q : Ty' Ty'' -> Ty [AS'] .) ODS') := ODS
    /\ ES := calcEqsFromAtts((op Q : Ty' Ty'' -> Ty [AS] .))
    /\ M' := 
       addEqs(
         ES,
         setOps(M, ((op Q : Ty' Ty'' -> Ty [filterIdemUnit(AS AS')] .) ODS'))
       )
  .
  ***)
  op calcEqsFromAtts : OpDecl -> EquationSet .
  eq calcEqsFromAtts((op Q : Ty' Ty'' -> Ty [none] .)) = none .
  ceq calcEqsFromAtts((op Q : Ty' Ty'' -> Ty [Att AS] .)) =
      calcEqsFromAtts((op Q : Ty' Ty'' -> Ty [AS] .))
    if (Att == assoc) or (Att == comm)
  .
  ceq calcEqsFromAtts((op Q : Ty' Ty'' -> Ty [id(T) AS] .)) =
      (ceq Q[T1, T] = T1 if nil [none] .)
      (ceq Q[T, T2] = T2 if nil [none] .)
      calcEqsFromAtts((op Q : Ty' Ty'' -> Ty [AS] .))
    if T1 := (qid("X:" + string(Ty'))).Term 
    /\ T2 := (qid("Y:" + string(Ty''))).Term 
  .
  ceq calcEqsFromAtts((op Q : Ty' Ty'' -> Ty [left-id(T) AS] .)) =
      (ceq Q[T, T2] = T2 if nil [none] .)
      calcEqsFromAtts((op Q : Ty' Ty'' -> Ty [AS] .))
    if T2 := (qid("Y:" + string(Ty''))).Term
    /\ E := (ceq Q[T, T2] = T2 if nil [none] .)
    ---[print E]
  .
  ceq calcEqsFromAtts((op Q : Ty' Ty'' -> Ty [right-id(T) AS] .)) =
      (ceq Q[T1, T] = T1 if nil [none] .)
      calcEqsFromAtts((op Q : Ty' Ty'' -> Ty [AS] .))
    if T1 := (qid("X:" + string(Ty'))).Term 
  .
  ceq calcEqsFromAtts((op Q : Ty' Ty'' -> Ty [idem AS] .)) =
      (ceq Q[T1, T1] = T1 if nil [none] .)
      calcEqsFromAtts((op Q : Ty' Ty'' -> Ty [AS] .))
    if T1 := (qid("X:" + string(Ty'))).Term 
  .
  
  
  --- Generalization ---
  var CTX CTX1 CTX2     : Context .
  var MP?               : MatchPair? .
  var T-T T-U T-C T-CTX : Term .
  var V-NEW             : Variable .
  
  sort TermTermVarUple .
  op TTV<_`,_`,_> : Term Term Variable -> TermTermVarUple .
    
  --- T1, T2 - the terms being generalized
  --- TL - the list of subterms for T1
  --- returns the generalized forms for T1 and T2
  op generalizeTerms : Term Term TermList Module Nat -> TermTermVarUple .
  eq generalizeTerms(T1, T2, empty, M, N) = TTV< T1 , T2 , noVar > .
  ceq generalizeTerms(T1, T2, (T, TL), M, N) =
      if (T'' == T2 or T' == T1)
        then generalizeTerms(T1, T2, TL, M, N)
        else TTV< T' , T'' , V-NEW >
      fi
    if V-NEW := generateFreshVar((c2v(T1), c2v(T2)), leastSort(M, T))
    /\ T'    := graftTree(M, T1, T, V-NEW)
    /\ true
    /\ T''   := graftTree(M, T2, T, V-NEW)
    ---[print T " :\n" T' "\n" T'' "\n"]
  .
  
  --- Replaces all the occurences of a pattern (T-U)
  --- in the provided term (T-T) with the term T.
  op graftTree : Module Term Term Term -> Term .
  ceq graftTree(M, T-T, T-U, T) = graftTree(M, T-CTX, T-U, T)
    if MP?   := metaXmatch(M, T-U, T-T, nil, 0, unbounded, 0)
    /\ MP?   :: MatchPair
    /\ CTX   := getContext(MP?)
    /\ T-CTX := CTX[T]
  .
  eq graftTree(M, T-T, T-U, T) = T-T [owise] .
  
  
  --- Generates a fresh variable starting with "V" when provided a sort and a list of terms.
  op generateFreshVar :  TermList Sort -> Variable .
  op generateFreshVar :  TermList Sort Nat -> Variable .
  eq generateFreshVar(TL, S) = generateFreshVar(TL, S, 0) .
  ceq generateFreshVar(TL, S, N) =
      if (subset(V, getVars(TL)))
        then generateFreshVar(TL, S, (N + 1))
        else V
      fi
    if V := qid("V" + string(N, 10) + ":" + string(S))
    ---[print  VARS:NsSet{Variable} " " B]
  .
  
endfm --- EQ-MANAGER

***( ===========================================================================
*
* ============================================================================ )

fmod PRE-OUTPUT is

  ---including DATA-TYPES .
  including EQ-MANAGER .
  including DECL-META-PRETTY-PRINT .

  vars T T'       : Term .
  vars COND COND' : EqCondition .
  vars ES ES'     : EquationSet .

  var M     : Module .
  var V V' V''  : Variable .
  var S S1  : Sort . 
  var AS    : AttrSet .
  var E     : Equation .
  var EL    : NsList{Equation} .
  var GL    : NsList{Goal} .
  var G     : Goal .
  var N     : Nat .
  var OD    : OpDecl .
  var ODS   : OpDeclSet .
  var Q     : Qid .
  var SUBST : Substitution .
  var Ty    : Type .
  var TyL   : TypeList .
  var IUL IUL' IUL'' : NsList{InductionUple} .
  var VS : NsSet{Variable} .

  --- Replaces the internal sort (needed for induction) of a variable
  --- by the original sort. E.g.: N:Nat<N> ----replaced----> N:Nat
  op prettyVar : Variable NsList{InductionUple} -> Variable .

***()
  ceq prettyVar(V, IUL) = V''
    if (IUL' :IU: < V', S, S1 > :IU: IUL'') := IUL
    ---/\ getName(parseIndVar(V)) == getName(parseIndVar(V')) ---g(p(V')) should be replaced by < ? > from S1
    /\ getType(V) == S1
    /\ V'' := qid(string(getName(V)) + ":" + string(S))
  .
***)
  eq prettyVar(V, IUL) = V [owise] .

  
  --- Replaces the internal sorts needed by induction with the original sorts
  --- inside an equation.
  op prettyEq : NsList{Equation} NsList{InductionUple} -> NsList{Equation} .
  eq prettyEq(nsnil-E, IUL) = nsnil-E .
  eq prettyEq((E :E: EL), IUL) = (prettyEq'(c2v(E), getVars(c2v(E)), IUL)) :E: (prettyEq(EL, IUL)) . 
  
  op prettyEq' : Equation NsSet{Variable} NsList{InductionUple} ->
                 NsList{Equation} .
  eq prettyEq'(E, nsempty-V, IUL) = E .
  eq prettyEq'(E, (V ;V; VS), IUL) =
     prettyEq'(replace(E, V, prettyVar(V, IUL)), VS, IUL)
---[print "!!!!!!!!!!!!" V "  " IUL]
  .
  
  
  var GLL1 GLL2 : NsList{NsList{Goal}} .
  op prettyGoal : NsList{NsList{Goal}} NsList{InductionUple} -> NsList{NsList{Goal}} .
  ceq prettyGoal((GLL1 :GL: GLL2), IUL) =
     prettyGoal(GLL1, IUL) :GL:
     prettyGoal(GLL2, IUL)
     if GLL1 =/= nsnil-G
     /\ GLL2 =/= nsnil-G
  .
  
  op prettyGoal : NsList{Goal} NsList{InductionUple} -> NsList{Goal} .
  eq prettyGoal(nsnil-G, IUL) = nsnil-G .
  eq prettyGoal((eq2goal(E) :G: GL), IUL) =
     eq2goal(prettyEq(E, IUL)) :G: prettyGoal(GL, IUL) .
  eq prettyGoal((op2goal(OD) :G: GL), IUL) =
     op2goal(OD) :G: prettyGoal(GL, IUL) .


  op printTopTerm : Module Term -> QidList .
  eq printTopTerm(M, '#*_*#[T]) =
     '\b qid("[") '* '\s '\o metaPrettyPrint(M, T) '\b '\s '* qid("]") '\o .
  eq printTopTerm(M, T) =
     metaPrettyPrint(M, T) [owise] .

  --- meta pretty print conditions
  op myOneMetaPrettyPrint : Module EqCondition -> QidList .
  eq myOneMetaPrettyPrint(M, (nil).EqCondition) = nil .
  eq myOneMetaPrettyPrint(M, (T = T')) =
     printTopTerm(M, c2v(T)) '\s '\m '= '\o '\s
     printTopTerm(M, c2v(T'))
  .
  ceq myOneMetaPrettyPrint(M, (T = T') /\ COND) =
      myOneMetaPrettyPrint(M, (T = T')) '\s '\m '/\ '\o
      myOneMetaPrettyPrint(M, COND)
    if COND =/= nil
  .

  --- Meta pretty print equations
  --- by turning the artificial constants back into variables.
  op myOneMetaPrettyPrint : Module Equation -> QidList .
  eq myOneMetaPrettyPrint(M, (ceq T = T' if COND [AS] .)) =
     printTopTerm(M, c2v(T)) '\s '\m '= '\o '\s
     printTopTerm(M, c2v(T'))
     if (COND == nil)
       then nil
       else '\s '\m 'if '\o myOneMetaPrettyPrint(M, COND)
     fi
  .
  eq myOneMetaPrettyPrint(M, (eq T = T' [AS] .)) =
     printTopTerm(M, c2v(T)) '\s '\m '= '\o '\s
     printTopTerm(M, c2v(T'))
  .
  
  var QL : QidList .
  
  --- Meta pretty print operators
  op myOneMetaPrettyPrint : Module Goal -> QidList .
  eq myOneMetaPrettyPrint(M, op2goal(OD)) = eMetaPrettyPrint(M, OD) .
  eq myOneMetaPrettyPrint(M, eq2goal(E)) = myOneMetaPrettyPrint(M, E) .

  --- Meta pretty print a list of equations
  op myMetaPrettyPrint : Module NsList{Equation} -> QidList .
  op myMetaPrettyPrint : Module NsList{Equation} QidList -> QidList .
  op myMetaPrettyPrint : Module NsList{Equation} QidList Nat -> QidList .
  
  eq myMetaPrettyPrint(M, EL) = myMetaPrettyPrint(M, EL, nil) .
  
  eq myMetaPrettyPrint(M, EL, QL) = 
     myMetaPrettyPrint(M, EL, QL, if (count(EL) > 1) then 1 else 0 fi) .
  eq myMetaPrettyPrint(M, nsnil-E, QL, N) = nil .
  eq myMetaPrettyPrint(M, (E :E: EL), QL, N) = 
     if (N > 0) then qid(string(N, 10) + ".") '\s else nil fi QL
     myOneMetaPrettyPrint(M, E) '\n
     myMetaPrettyPrint(M, EL, QL, N + 1)
  .
  
  op myMetaPrettyPrint : Module NsList{Goal} -> QidList .
  op myMetaPrettyPrint : Module NsList{NsList{Goal}} -> QidList .
  op myMetaPrettyPrint : Module NsList{Goal} Nat -> QidList .
  
  ceq myMetaPrettyPrint(M, GLL1 :GL: GLL2) =
      myMetaPrettyPrint(M, GLL1) '\b 'or '\o '\n 
      myMetaPrettyPrint(M, GLL2)
    if GLL1 =/= nsnil-G
    /\ GLL2 =/= nsnil-G
  .
  
  eq myMetaPrettyPrint(M, GL) = myMetaPrettyPrint(M, GL, 1) .
  eq myMetaPrettyPrint(M, nsnil-G, N) = nil .
  eq myMetaPrettyPrint(M, (G :G: GL), N) = 
     qid(string(N, 10) + ".") '\s '\s
     myOneMetaPrettyPrint(M, G) '\n
     myMetaPrettyPrint(M, GL, N + 1)
  .

endfm --- PRE-OUTPUT

***( ===========================================================================
*
* ============================================================================ )

fmod CIRC-SPEC-LANG-SORTS is

  including FULL-MAUDE-SIGN .

  sort @CModule@ . --- modules including beh and circular proving specs
  sort @CDecl@ . --- declarations in a @CModule@

  sort @CDeclList@ .
  sort @DerDecl@ .
  sort @SimpRlDecl@ .
  sort @SpeCtxDecl@ .
  sort @EnumSortDecl@ .
  sort @CaseEqDecl@ .
  sort @GrdEqDecl@ .


  subsort @DerDecl@ < @FDeclList@ .
  subsort @SimpRlDecl@ < @FDeclList@ .
  subsort @SpeCtxDecl@ < @FDeclList@ .
  subsort @EnumSortDecl@ < @FDeclList@ .
  subsort @GrdEqDecl@ < @FDeclList@ .
  subsort @CaseEqDecl@ < @FDeclList@ .

  subsort @FDeclList@ < @CDeclList@ .

endfm --- CIRC-SPEC-LANG-SORTS



***( ===========================================================================
*
* ============================================================================ )

fmod CIRC-SPEC-LANG-SIGN is

  protecting CIRC-SPEC-LANG-SORTS .
  including  F&S-MODS&THS .

  --- External cth declaration operators.
  ***( ! deprecated ! ) op cth_is_endcth       : @Interface@ @CDeclList@ -> @Module@ .
  ***( ! deprecated ! ) op ctheory_is_endctheory : @Interface@ @CDeclList@ -> @Module@ .
  op theory_is_endtheory : @Interface@ @CDeclList@ -> @Module@ .
  op der_.               : @Bubble@ -> @DerDecl@ .
  op derivative_.        : @Bubble@ -> @DerDecl@ .
  op scx_.               : @Bubble@ -> @SpeCtxDecl@ .
  op special-context_.   : @Bubble@ -> @SpeCtxDecl@ .
  op enum_is_.           : @Token@ @Bubble@ -> @EnumSortDecl@ .
  op geq_=_.             : @Bubble@ @Bubble@ -> @GrdEqDecl@ .
  op cases`pattern`=_if_. : @Bubble@ @Bubble@ -> @CaseEqDecl@ .  
  op csrl_=>_if_.        : @Bubble@ @Bubble@ @Bubble@ -> @SimpRlDecl@ .
  op srl_=>_.            : @Bubble@ @Bubble@ -> @SimpRlDecl@ .
  
endfm --- CIRC-SPEC-LANG-SIGN


***( ===========================================================================
*
* ============================================================================ )

fmod CIRC-CMD-LANG-SIGN is

  including COMMANDS .
  including SIGNATURES .
  protecting CIRC-SPEC-LANG-SORTS .
  
  op initialize`. : -> @Command@ .
  op init`.       : -> @Command@ .


  op add`goal_=_.        : @Bubble@ @Bubble@          -> @Command@ .
  op add`goal_.          : @OpDecl@                   -> @Command@ .
  op add`cgoal_=_if_.    : @Bubble@ @Bubble@ @Bubble@ -> @Command@ .
  op add`lemma_=_.       : @Bubble@ @Bubble@          -> @Command@ .
  op set`max`no`steps_.  : @Token@                    -> @Command@ .
  op show`max`no`steps`. :                            -> @Command@ .
  op show`proof`.        :                            -> @Command@ .
  op show`last`proof`.   :                            -> @Command@ .
  ***( ! deprecated ! ) op show`history`.  :          -> @Command@ .
  op check`scx_using_.   : @Bubble@ @Bubble@          -> @Command@ .
  op check`proof`.       :                            -> @Command@ .

  op coinduction`.                    :                  -> @Command@ .
  ---op coinduction-grlz`.               :                  -> @Command@ .
  op induction`on_.                   : @Bubble@         -> @Command@ .
  op induction`.                      :                  -> @Command@ .
  op apply_.                          : @Bubble@         -> @Command@ .

  op show`goals`.         :                  -> @Command@ .
  op focus_.              : @Token@          -> @Command@ .
  op reduce`.             :                  -> @Command@ .
  ***( ! deprecated ! ) op ccstep`.             :                  -> @Command@ .
  op derive`.             :                  -> @Command@ .
  op cases`.              :                  -> @Command@ .
  op generalize`.         :                  -> @Command@ .
  op checkcond`.          :                  -> @Command@ .
  op set`induction`vars_. : @Bubble@         -> @Command@ .
  op cistep_.             : @Bubble@         -> @Command@ .
  op cistep`.             :                  -> @Command@ .
  op simplify`.           :                  -> @Command@ .
  op save`proof`state`.   :                  -> @Command@ .
  op undo`.               :                  -> @Command@ .
  op quit`proof`.         :                  -> @Command@ .
  op clear`log`.          :                  -> @Command@ .

  op show`flat`module`.   :                  -> @Command@ .

  op set`show`details`on`.  : -> @Command@ .
  op set`show`details`off`. : -> @Command@ .

  op set`show`proved`properties`on`. : -> @Command@ .
  op set`show`proved`properties`off`. : -> @Command@ .

  op set`auto`contexts`on`.   : -> @Command@ .
  op set`auto`contexts`off`.  : -> @Command@ .
  
  *** TODO: remove these 2
  op set`all`contexts`special`.  : -> @Command@ .
  op set`all`scx`off`.  : -> @Command@ .
  
  op set`auto`add`conj`on`. : -> @Command@ .
  op set`auto`add`conj`off`. : -> @Command@ .
  
  op set`generalization`on`. : -> @Command@ .
  op set`generalization`off`. : -> @Command@ .
  

endfm --- CIRC-CMD-LANG-SIGN


***( ===========================================================================
* Language and Commands signature.
* ============================================================================ )

fmod CIRC-LANG-SIGN is

  including CIRC-CMD-LANG-SIGN .
  including CIRC-SPEC-LANG-SIGN .

  subsort @CModule@ < @Input@ .

endfm --- CIRC-LANG-SIGN


***( ===========================================================================
*
* ============================================================================ )

fmod META-CIRC-LANG-SIGN is

  including META-LEVEL .
  protecting META-FULL-MAUDE-SIGN .
  protecting UNIT .

  op CIRC-GRAMMAR : -> FModule .

  eq CIRC-GRAMMAR = addImports((including 'CIRC-LANG-SIGN .), GRAMMAR) .

endfm --- META-CIRC-LANG-SIGN


***( ===========================================================================
*
* ============================================================================ )

fmod CIRC-DECL is

  protecting META-MODULE .

--- derivatives
  sort DerDecl DerDeclList .
  subsort DerDecl < DerDeclList .

  op der_. : TermList -> DerDecl [format(g o g o)] .
  op none : -> DerDeclList .
  op __ : DerDeclList DerDeclList -> DerDeclList [assoc id: none format(d ni d)] .

--- special contexts
  sort SpeCtxDecl SpeCtxDeclList .
  subsort SpeCtxDecl < SpeCtxDeclList .

  op scx_. : TermList -> SpeCtxDecl [format(g o g o)] .
  op none : -> SpeCtxDeclList .
  op __ : SpeCtxDeclList SpeCtxDeclList -> SpeCtxDeclList [assoc id: none format (d ni d)] .

--- enum sorts
  sort EnumSortDecl EnumSortDeclList .
  subsort EnumSortDecl < EnumSortDeclList .

  op enum_is_. : Sort QidList -> EnumSortDecl [format(g o g o g o)].

  op none : -> EnumSortDeclList .
  op __ : EnumSortDeclList EnumSortDeclList -> EnumSortDeclList
          [assoc id: none format (d ni d)] .

--- guarded equations with case analysis

  sort GrdEqDecl GrdEqDeclList .
  subsort GrdEqDecl < GrdEqDeclList .

  op geq_=_. : Term Term -> GrdEqDecl [format(g o g o g o)] .

  op none : -> GrdEqDeclList .
  op __ : GrdEqDeclList GrdEqDeclList -> GrdEqDeclList
          [assoc id: none format (d ni d)] .

  sort Case CaseList .
  subsort Case < CaseList .

  op _if_`[`]   : Term     EqCondition -> Case [format(d g o sg d o)] .
  op _`[owise`] : Term                 -> Case [format(d sg d d o)] .
  op __         : CaseList CaseList    -> CaseList [assoc format(d ni d)] .
  op geq_=_.    : Term     CaseList    -> GrdEqDecl [format(g o g ++oni --nig o)] .
  
--- case equations

  sort CaseEqDecl CaseEqDeclList .
  subsort CaseEqDecl < CaseEqDeclList .

  op none : -> CaseEqDeclList .
  op __ : CaseEqDeclList CaseEqDeclList -> CaseEqDeclList
          [assoc id: none format (d ni d)] .
  
  op cases`pattern`=_if_. : Term Term -> CaseEqDecl [format(g o g o g ++oni --nig o)] .
  op cases`pattern`=_if_. : Term EqCondition -> CaseEqDecl [format(g o g o g ++oni --nig o)] .
  
--- simplification rules
  sort SimpRlDecl SimpRlDeclList .
  subsort SimpRlDecl < SimpRlDeclList .

  op none    : -> SimpRlDeclList .
  op __      : SimpRlDeclList SimpRlDeclList -> SimpRlDeclList [assoc id: none format(d ni d)] .
  
  op csrl_:_=>_if_. : Qid Term Term Term -> SimpRlDecl .
  op csrl_:_=>_if_. : Qid EqCondition EqCondition EqCondition -> SimpRlDecl 
                      [format(g o g o g o g o g o)].

endfm



***( ===========================================================================
*
* ============================================================================ )

fmod ALGORITHMS is

  including EQ-MANAGER .
  including UNIT-DECL-PARSING .

  sorts NsNeSet{ResultPair} NsNeSet{ResultPair?} .
  subsort NsNeSet{ResultPair} < NsNeSet{ResultPair?} .
  subsort ResultPair          < NsNeSet{ResultPair} .
  subsort ResultPair?         < NsNeSet{ResultPair?} .

  var Att Att'        : Attr .
  var AS AS' AttS     : AttrSet .
  var AS1 AS2 AS3     : AttrSet .
  var C               : Constant .
  var E               : Equation .
  var N               : Int .
  var K               : Kind .
  var KS              : KindSet .
  var T1 T2 T3 T4     : Term .
  var T T' T1'        : Term .
  var X Y             : Term .
  var T-F T-G         : Term .
  var M               : Module .
  var EL EL' EL''     : NsList{Equation} .
  var RPS RPS1 RPS2   : NsNeSet{ResultPair?} .
  var OD              : OpDecl .
  var ODS ODS'        : OpDeclSet .
  var Q Q' F G        : Qid . 
  var QLT QLT1 QLT2   : QidList .
  var QL QL'          : QidList .
  var QLCOND QLTS     : QidList .
  var RP RP1 RP2      : ResultPair? .
  var Srt             : Sort .
  var SS              : SortSet .
  var Sb? theta       : Substitution? .
  var SW              : SwitchStatus .
  var TL TL' TL''     : TermList .
  var TL1 TL2 TL3 TL4 : TermList .
  var TL-SCXS-CAND    : TermList .
  var TL-SCXS         : TermList .
  var TL1' TL2' TL3'  : TermList .
  var Ty Ty' Ty'' Ty1 : Type .
  var TyL TyL1 TyL2   : TypeList .
  var V               : Variable .
  

  op _;RP;_ : NsNeSet{ResultPair?} NsNeSet{ResultPair?} ->
             NsNeSet{ResultPair?} [assoc] .
  op _;RP;_ : NsNeSet{ResultPair} NsNeSet{ResultPair} ->
             NsNeSet{ResultPair} [assoc] .

--- checks if the qid is in a list of qid's
  op hasQid : QidList Qid -> Bool .

  eq hasQid(nil, Q)   = false .
  eq hasQid(Q QL, Q') = Q == Q' or hasQid(QL, Q') . 


  op unwrap : Term -> Term .
  eq unwrap('@wrapper[T]) = T .
  
  op getUnwrappedTerm : ResultPair? -> Term .
  eq getUnwrappedTerm(RP) = unwrap(getTerm(RP)) . 
  

  --- Tries to parse a qid list in a module.
  --- In order to get the term from the returned RP, use: getUnwrappedTerm(RP))
  op parseInModule : Module QidList -> ResultPair? .
  
  op addParserWrapper : Module -> Module .
  eq addParserWrapper(M) =
     addOps((op '@wrapper : 'Universal -> '@@@ [poly(1)] .), addSorts('@@@, M))
  .

  eq parseInModule(M, QL) =
     metaParse(addParserWrapper(M), '@wrapper '`( QL '`), '@@@)
  . 
  
  
  --- Tries to parse a qid list representing a term set in a module;
  --- Return a set of ResultPairs
  op parseForSetOfTermsInModule : Module QidList -> NsNeSet{ResultPair?} .
  eq parseForSetOfTermsInModule(M, nil) = noParse(999) .
  ceq parseForSetOfTermsInModule(M, QLT) = RP
    if RP := parseInModule(M, QLT)
    /\ RP :: ResultPair --- a single term
  .

  ceq parseForSetOfTermsInModule(M, QLT QLTS) = RP ;RP; RPS
    if RP := parseInModule(M, QLT)
    /\ RP :: ResultPair
    /\ RPS := parseForSetOfTermsInModule(M, QLTS)
    /\ RPS :: NsNeSet{ResultPair}
  .

  eq parseForSetOfTermsInModule(M, QLTS) = noParse(999) [owise] .

  --- Extracts the list of terms from a set of ResultPairs.
  op getUnwrappedTermList : NsNeSet{ResultPair} -> TermList .
 
  eq getUnwrappedTermList(RP) = getUnwrappedTerm(RP) .
  eq getUnwrappedTermList(RP ;RP; RPS) = getUnwrappedTerm(RP), getUnwrappedTermList(RPS) .
  eq getUnwrappedTermList(RPS ;RP; RP) = getUnwrappedTermList(RPS), getUnwrappedTerm(RP) .
  eq getUnwrappedTermList(RPS1 ;RP; RP ;RP; RPS2) =
      getUnwrappedTermList(RPS1), getUnwrappedTerm(RP), getUnwrappedTermList(RPS2) .
      
  op unToken : Term -> Term .
  ceq unToken(T) = T' if 'token[T'] := T .
  
  op unBubble : Term -> Term .
  ceq unBubble(T) = T' if 'bubble[T'] := T .
                                     
  --- Creates a similar name for a certain binary operator, by adding a prefix.
  --- E.g. : +__ ~> prefix+__
  ---        _+_ ~> _prefix+_
  ---        __+ ~> __prefix+
  ---        +   ~> prefix+
  op createSimilarBinOpName : String String Nat -> Qid .
  eq createSimilarBinOpName(S:String, Spref:String, posCrt:Nat) = 
        if (length(S:String) =/= 0)
        then if (substr(S:String, posCrt:Nat, 1) == "_")
             then createSimilarBinOpName(S:String,Spref:String,(posCrt:Nat + 1))
             else qid(substr(S:String, 0, posCrt:Nat) +
                      Spref:String +
                      substr(S:String, posCrt:Nat, length(S:String))
                     ) 
             fi
        else qid(Spref:String) 
        fi . 
  eq createSimilarBinOpName(S:String, Spref:String, posCrt:Nat) = 
                                                         qid(S:String) [owise] .
  
  
  --- Gets a similar operator according to a given binary operator attribute set.
  --- E.g. : op _+_ : Stream Stream -> Stream [assoc comm id: zero] . ~~>
  ---        op _assoc#comm#id#+_ : Stream Stream -> Stream [assoc comm id: zero] .
  op getOpFromOpAtts : OpDecl -> OpDecl .
  ceq getOpFromOpAtts(op Q : TyL -> Ty [AS] .) = (op Q' : TyL -> Ty [AS] .)
        if Prefix:String := getPrefixFromOpAtts(op Q : TyL -> Ty [AS] .) /\
           Q' := createSimilarBinOpName(string(Q), Prefix:String, 0) .
  
  --- Gets a prefix according to an operator attribute set.
  --- Recursively calls getPrefixFromOpAtt(...).
  --- E.g. : op _+_ : Stream Stream -> Stream [assoc comm id: zero]
  ---        prefix ~ assoc#comm#id 
  op getPrefixFromOpAtts : OpDecl -> String .
  eq getPrefixFromOpAtts(op Q : TyL -> Ty [Att AS] .) =
       getPrefixFromOpAtt(Att) + "#" +
       getPrefixFromOpAtts(op Q : TyL -> Ty [AS] .) .
  eq getPrefixFromOpAtts(op Q : TyL -> Ty [none] .) = "" .
  
  --- Gets a string according to an operator attribute.
  --- E.g. : [assoc] ~ "assoc"
  ---        [id: zero] ~ "id" ...
  op getPrefixFromOpAtt : Attr -> String .
  eq getPrefixFromOpAtt(assoc)       = "a" .
  eq getPrefixFromOpAtt(comm)        = "c" .
  eq getPrefixFromOpAtt(id(T))       = "u" .
  eq getPrefixFromOpAtt(left-id(T))  = "li" .
  eq getPrefixFromOpAtt(right-id(T)) = "ri" .
  eq getPrefixFromOpAtt(idem)        = "i" .
  eq getPrefixFromOpAtt(Att)         = "" [owise] .
  
  
  --- Gets a set of equations according to a given binary operator attribute set.
  --- The equations are needed in order to satisfy the Church-Rosser property.
  --- A Church-Rosser checker tool was used to determine the needed equations.
  ---     http://www.lcc.uma.es/%7Eduran/CRC/
  --- E.g. : op _+_ : Stream Stream -> Stream [assoc comm] .
  ---        ceq '#*_*#(X assoc#comm#+ (Y + Z)) = 
  ---            '#*_*#(X assoc#comm#+ (Y assoc#comm#+ Z)) if nil [none] .
  op getEqsFromOpAttsForCRosser : OpDecl OpDecl -> EquationSet .
  ceq getEqsFromOpAttsForCRosser((op Q : Ty' Ty'' -> Ty [Att Att' AS] .),
                                 (op Q' : Ty' Ty'' -> Ty [Att Att' AS] .)) =
        (getEqsFromOpAttsForCRosser((op Q : Ty' Ty'' -> Ty [Att Att'] .),
                                    (op Q' : Ty' Ty'' -> Ty [Att Att'] .))
         getEqsFromOpAttsForCRosser((op Q : Ty' Ty'' -> Ty [Att AS] .),
                                    (op Q' : Ty' Ty'' -> Ty [Att AS] .))
         getEqsFromOpAttsForCRosser((op Q : Ty' Ty'' -> Ty [Att' AS] .),
                                    (op Q' : Ty' Ty'' -> Ty [Att' AS] .))
        )
        if (AS =/= none)
        .
  ceq getEqsFromOpAttsForCRosser((op Q : Ty' Ty'' -> Ty [assoc comm] .),
                                 (op Q' : Ty' Ty'' -> Ty [assoc comm] .)) =
      
        (ceq '#*_*#[Q'[T1, Q[T2, T3]]] = 
             '#*_*#[Q'[T1, Q'[T2, T3]]] if nil [none] .)
        if T1  := (qid("X:" + string(Ty'))).Term 
        /\ T2  := (qid("Y:" + string(Ty''))).Term /\ true --- TEMP
        /\ T3  := (qid("Z:" + string(Ty''))).Term 
        .
  ceq getEqsFromOpAttsForCRosser((op Q : Ty' Ty'' -> Ty [assoc id(T)] .),
                                 (op Q' : Ty' Ty'' -> Ty [assoc id(T)] .)) =
      
        ((ceq '#*_*#[Q'[Q[T1, T2], T3]] = 
              '#*_*#[Q'[Q'[T1, T2], T3]] if nil [none] .)
         (ceq '#*_*#[Q'[T1, Q[T2, T3]]] = 
              '#*_*#[Q'[T1, Q'[T2, T3]]] if nil [none] .)
        )
        if T1  := (qid("X:" + string(Ty'))).Term 
        /\ T2  := (qid("Y:" + string(Ty''))).Term /\ true --- TEMP
        /\ T3  := (qid("Z:" + string(Ty''))).Term 
        .
  ceq getEqsFromOpAttsForCRosser((op Q : Ty' Ty'' -> Ty [assoc left-id(T)] .),
                                 (op Q' : Ty' Ty'' -> Ty [assoc left-id(T)] .)) =
      
        ((ceq '#*_*#[Q'[Q[T1, T2], T3]] = 
              '#*_*#[Q'[Q'[T1, T2], T3]] if nil [none] .)
         (ceq '#*_*#[Q'[T1, Q[T2, T3]]] = 
              '#*_*#[Q'[T1, Q'[T2, T3]]] if nil [none] .)
        )
        if T1  := (qid("X:" + string(Ty'))).Term 
        /\ T2  := (qid("Y:" + string(Ty''))).Term /\ true --- TEMP
        /\ T3  := (qid("Z:" + string(Ty''))).Term 
        .
  ceq getEqsFromOpAttsForCRosser((op Q : Ty' Ty'' -> Ty [assoc right-id(T)] .),
                                 (op Q' : Ty' Ty'' -> Ty [assoc right-id(T)] .)) =
      
        ((ceq '#*_*#[Q'[Q[T1, T2], T3]] = 
              '#*_*#[Q'[Q'[T1, T2], T3]] if nil [none] .)
         (ceq '#*_*#[Q'[T1, Q[T2, T3]]] = 
              '#*_*#[Q'[T1, Q'[T2, T3]]] if nil [none] .)
        )
        if T1  := (qid("X:" + string(Ty'))).Term 
        /\ T2  := (qid("Y:" + string(Ty''))).Term /\ true --- TEMP
        /\ T3  := (qid("Z:" + string(Ty''))).Term 
        .
  eq getEqsFromOpAttsForCRosser((op Q : Ty' Ty'' -> Ty [AS] .),
                                (op Q' : Ty' Ty'' -> Ty [AS] .)) = none [owise] .

  --- Gets a set of equations according to a given binary operator (attribute set).
  --- E.g. :  op _+_ : Stream Stream -> Stream [assoc comm] . ~~>
  --- Creates the similar binary operator 
  ---   op _assoc#comm#+_ : Stream Stream -> Stream [assoc comm] .
  --- Builds the equations
  ---   ceq '#*_*#((x + y) + z) = '#*_*#((x assoc#comm#+ y) assoc#comm#+ z) if nil [none] .
  ---   ceq '#*_*#(x + (y + z)) = '#*_*#(x assoc#comm#+ (y assoc#comm#+ z)) if nil [none] .
  ---   ceq '#*_*#(x + y) = '#*_*#(x assoc#comm#+ y) if nil [none] .
  --- Recursively calls getEqsFromOpAtts(opDecl, opDeclSimilar).
  op getEqsFromOpAtts : OpDecl -> EquationSet .
  ceq getEqsFromOpAtts(op Q : TyL -> Ty [AS] .) = 
        (getEqsFromOpAtts((op Q : TyL -> Ty [AS] .), ODSimilar:OpDecl)
         getEqsFromOpAttsForCRosser((op Q : TyL -> Ty [AS] .), ODSimilar:OpDecl)
        )
        if ODSimilar:OpDecl := getOpFromOpAtts(op Q : TyL -> Ty [AS] .) .
  
  op getEqsFromOpAtts : OpDecl OpDecl -> EquationSet .
  eq getEqsFromOpAtts((op Q : TyL -> Ty [Att AS] .), (op Q' : TyL -> Ty [AS'] .)) =
       (getEqsFromOpAtt((op Q : TyL -> Ty [Att] .), (op Q' : TyL -> Ty [AS'] .)) 
        getEqsFromOpAtts((op Q : TyL -> Ty [AS] .), (op Q' : TyL -> Ty [AS'] .))
       ) .
  eq getEqsFromOpAtts((op Q : TyL -> Ty [none] .),
                      (op Q' : TyL -> Ty [AS'] .)) = none .
  
  --- Gets a set of equations according to a given binary operator attribute Att.
  --- The binary operator may be characterized by a set of attributes AS.
  --- The equations are built by use of a similar binary operator only for Att.
  op getEqsFromOpAtt : OpDecl OpDecl -> EquationSet .
  ceq getEqsFromOpAtt((op Q : Ty' Ty'' -> Ty [comm] .),
                      (op Q' : Ty' Ty'' -> Ty [AS] .)) =
        (ceq '#*_*#[Q[T1, T2]] = '#*_*#[Q'[T1, T2]] if nil [none] .)
        if T1  := (qid("X:" + string(Ty'))).Term 
        /\ T2  := (qid("Y:" + string(Ty''))).Term 
        .
   ceq getEqsFromOpAtt((op Q : Ty' Ty'' -> Ty [assoc] .),
                      (op Q' : Ty' Ty'' -> Ty [AS] .)) =
        ((ceq '#*_*#[Q[Q[T1, T2], T3]] = '#*_*#[Q'[Q'[T1, T2], T3]] if nil [none] .) 
         (ceq '#*_*#[Q[T1, Q[T2, T3]]] = '#*_*#[Q'[T1, Q'[T2, T3]]] if nil [none] .))
        if T1  := (qid("X:" + string(Ty'))).Term 
        /\ T2  := (qid("Y:" + string(Ty''))).Term /\ true --- TEMP
        /\ T3  := (qid("Z:" + string(Ty''))).Term 
        .
  ceq getEqsFromOpAtt((op Q : Ty' Ty'' -> Ty [right-id(T)] .),
                      (op Q' : Ty' Ty'' -> Ty [AS] .)) =
        (ceq '#*_*#[Q[T1, T2]] = '#*_*#[Q'[T1, T2]] if nil [none] .)
        if T1  := (qid("X:" + string(Ty'))).Term 
        /\ T2  := (qid("Y:" + string(Ty''))).Term 
        .
  ceq getEqsFromOpAtt((op Q : Ty' Ty'' -> Ty [left-id(T)] .),
                      (op Q' : Ty' Ty'' -> Ty [AS] .)) =
        (ceq '#*_*#[Q[T1, T2]] = '#*_*#[Q'[T1, T2]] if nil [none] .)
        if T1  := (qid("X:" + string(Ty'))).Term 
        /\ T2  := (qid("Y:" + string(Ty''))).Term 
        .
  ceq getEqsFromOpAtt((op Q : Ty' Ty'' -> Ty [id(T)] .),
                      (op Q' : Ty' Ty'' -> Ty [AS] .)) =
        (ceq '#*_*#[Q[T1, T2]] = '#*_*#[Q'[T1, T2]] if nil [none] .)
        if T1  := (qid("X:" + string(Ty'))).Term 
        /\ T2  := (qid("Y:" + string(Ty''))).Term 
        .
  ceq getEqsFromOpAtt((op Q : Ty' Ty'' -> Ty [idem] .),
                      (op Q' : Ty' Ty'' -> Ty [AS] .)) =
        (ceq '#*_*#[Q[T1, T2]] = '#*_*#[Q'[T1, T2]] if nil [none] .)
        if T1  := (qid("X:" + string(Ty'))).Term 
        /\ T2  := (qid("Y:" + string(Ty''))).Term 
        .
  
  --- Gets a list of frozen goals according to a given binary operator attribute.
  --- E.g. : op _+_ : Stream Stream -> Stream [assoc] . ~~>
  ---        ceq der|(x + y) + z| = der|x + (y + z)| if nil [none] .
  op getGoalsFrozenFromOpAtt : OpDecl TermList Nat Module -> NsList{Equation} .
  ceq getGoalsFrozenFromOpAtt((op Q : Ty' Ty'' -> Ty [comm] .), TL, N, M) =
        coExpand(E, rename(TL, N), M)
        if T1  := (qid("X:" + string(Ty'))).Term 
        /\ T2  := (qid("Y:" + string(Ty''))).Term
        /\ E   := (ceq '#*_*#[Q[T1, T2]] = '#*_*#[Q[T2, T1]] if nil [none] .) 
        .
  ceq getGoalsFrozenFromOpAtt((op Q : Ty' Ty'' -> Ty [assoc] .), TL, N, M) =
        coExpand(E, rename(TL, N), M) 
        if T1  := (qid("X:" + string(Ty'))).Term 
        /\ T2  := (qid("Y:" + string(Ty''))).Term /\ true --- TEMP
        /\ T3  := (qid("Z:" + string(Ty''))).Term
        /\ E   := (ceq '#*_*#[Q[Q[T1, T2], T3]] = '#*_*#[Q[T1, Q[T2, T3]]] if nil [none] .)
        .
  eq getGoalsFrozenFromOpAtt((op Q : Ty' Ty'' -> Ty [id(T)] .), TL, N, M) =
        (getGoalsFrozenFromOpAtt((op Q : Ty' Ty'' -> Ty [left-id(T)] .), TL, N, M) :E:
         getGoalsFrozenFromOpAtt((op Q : Ty' Ty'' -> Ty [right-id(T)] .), TL, N, M)
        )
        .
  ceq getGoalsFrozenFromOpAtt((op Q : Ty' Ty'' -> Ty [left-id(T)] .), TL, N, M) =
      coExpand(E, rename(TL, N), M)
    if T1 := (qid("X:" + string(Ty''))).Term
    /\ E  := (ceq '#*_*#[Q[T, T1]] = '#*_*#[T1] if nil [none] .)
  .
  ceq getGoalsFrozenFromOpAtt((op Q : Ty' Ty'' -> Ty [right-id(T)] .), TL, N, M) =
      coExpand(E, rename(TL, N), M)
    if T1 := (qid("X:" + string(Ty'))).Term
    /\ E  := (ceq '#*_*#[Q[T1, T]] = '#*_*#[T1] if nil [none] .)
  .
  ceq getGoalsFrozenFromOpAtt((op Q : Ty' Ty'' -> Ty [idem] .), TL, N, M) =
      coExpand(E, rename(TL, N), M)
    if T1  := (qid("X:" + string(Ty'))).Term 
    /\ E   := (ceq '#*_*#[Q[T1, T1]] = '#*_*#[T1] if nil [none] .) 
  .


  --- Gets a list of frozen goals according to a given binary operator attribute set.
  --- Recursively calls getGoalsFrozenFromOpAtt(...)
  op getGoalsFrozenFromOpAtts : OpDecl TermList Nat Module -> NsList{Equation} .
  eq getGoalsFrozenFromOpAtts((op Q : Ty' Ty'' -> Ty [Att AS] .), TL, N, M) =
       (getGoalsFrozenFromOpAtt((op Q : Ty' Ty'' -> Ty [Att] .), TL, N, M) :E:
        getGoalsFrozenFromOpAtts((op Q : Ty' Ty'' -> Ty [AS] .), TL, N, M)
       ) .
  eq getGoalsFrozenFromOpAtts((op Q : TyL -> Ty [none] .), TL, N, M) = nsnil-E .
  
  
  --- Transforms a set of equations into a list of equations.
  op eqSetToNsListEq : EquationSet -> NsList{Equation} .
  eq eqSetToNsListEq(E:Equation ES:EquationSet) =
       (E:Equation :E: eqSetToNsListEq(ES:EquationSet)) .
  eq eqSetToNsListEq(none) = nsnil-E .
  
          
  --- Checks whether the operator domain sorts and range sort satisfy
  --- the kind restrictions, according the operator attribute set.
  --- Recursively calls isSatisfyingKindRestriction(...). 
  op isSatisfyingKindRestrictions : OpDecl Module -> Bool .
  eq isSatisfyingKindRestrictions((op Q : Ty' Ty'' -> Ty [Att AS] .), M) = 
       isSatisfyingKindRestriction((op Q : Ty' Ty'' -> Ty [Att] .), M) and 
       isSatisfyingKindRestrictions((op Q : Ty' Ty'' -> Ty [AS] .), M) .
  eq isSatisfyingKindRestrictions((op Q : Ty' Ty'' -> Ty [none] .), M) = true .
  
  --- Checks whether the operator domain sorts and range sort satisfy
  --- the kind restrictions, according to an operator attribute. 
  op isSatisfyingKindRestriction : OpDecl Module -> Bool .
  ceq isSatisfyingKindRestriction((op Q : Ty' Ty'' -> Ty [Att] .), M) = 
      sameKind(M, Ty', Ty) and sameKind(M, Ty'', Ty)
    if ((Att == assoc) or
        (Att == comm)  or
        (Att == idem)
       )
  .
  eq isSatisfyingKindRestriction((op Q : Ty' Ty'' -> Ty [id(T)] .), M) = 
       sameKind(M, Ty', Ty) and sameKind(M, Ty'', Ty) .
  eq isSatisfyingKindRestriction((op Q : Ty' Ty'' -> Ty [left-id(T)] .), M) = 
       sameKind(M, Ty'', Ty) .
  eq isSatisfyingKindRestriction((op Q : Ty' Ty'' -> Ty [right-id(T)] .), M) = 
       sameKind(M, Ty', Ty) .
  eq isSatisfyingKindRestriction((op Q : Ty' Ty'' -> Ty [Att] .), M) =
       false [owise] .
  
  
  --- Used for parsing operator attributes.
  --- Needed when trying to prove [id: smth] or [left id: smth] or [right id: smth].
  --- Could not use the Full Maude parseAttrs(...) ~ see full-maude.maude .
  op parseAttrCirc : Term Module Nat -> AttrSet .
  ceq parseAttrCirc(T, M, N) = AS
    if AS := parseAttrCirc(parsePreAttrs(T, N), M)
  .

  op parseAttrCirc : AttrSet Module -> AttrSet .
  ceq parseAttrCirc((id(T) AS), M) =
    (id(TNeuEl:Term) parseAttrCirc(AS, M))
    if Qen:Qid := downTerm(unBubble(T), 'nil)
    /\ RP      := metaParse(M, Qen:Qid, anyType)
    /\ RP      :: ResultPair
    /\ TNeuEl:Term := getTerm(RP)
  .
  ceq parseAttrCirc((right-id(T) AS), M) =
      (right-id(TNeuEl:Term) parseAttrCirc(AS, M))
    if Qen:Qid := downTerm(unBubble(T), 'nil)
    /\ RP      := metaParse(M, Qen:Qid, anyType)
    /\ RP      :: ResultPair
    /\ TNeuEl:Term := getTerm(RP)
  .
  ceq parseAttrCirc((left-id(T) AS), M) =
      (left-id(TNeuEl:Term) parseAttrCirc(AS, M))
    if Qen:Qid     := downTerm(unBubble(T), 'nil)
    /\ RP          := metaParse(M, Qen:Qid, anyType)
    /\ RP          :: ResultPair
    /\ TNeuEl:Term := getTerm(RP)
  .
  eq parseAttrCirc(AS, M) = AS .
        
  

  var T2' T3' T4' : Term .
  var COND1 COND2 : Condition .
  var RP3 RP4 : ResultPair .

  
  
  --- Checks whether a condition is reduced to false
  op isConditionFalse : Condition Module OpDeclSet -> Bool .
---  eq isConditionFalse(nil, M, ODS) = false .
  ceq isConditionFalse(COND1 /\ (T1 = T2) /\ COND2, M, ODS) = true
    if RP1 := metaReduce(M, T1)
    /\ RP2 := metaReduce(M, T2)
    /\ T1' := getTerm(RP1)
    /\ T2' := getTerm(RP2)
    /\ B1:Bool := isCtorDefined(T1', M, ODS)
    /\ B2:Bool := isCtorDefined(T2', M, ODS)
    /\ B3:Bool := T1' =/= T2' 
	/\ B1:Bool and B2:Bool and B3:Bool
    ---[print T1' "  " T2' "   " B1:Bool " " B2:Bool " " B3:Bool]
  .

  ceq isConditionFalse(COND1 /\ (T1 = T2) /\ (T3 = T4) /\ COND2, M, ODS) = true
    if RP1 := metaReduce(M, T1)
    /\ RP2 := metaReduce(M, T2)
    /\ RP3 := metaReduce(M, T3)
    /\ RP4 := metaReduce(M, T4)
    /\ T1' := getTerm(RP1)
    /\ T2' := getTerm(RP2)
    /\ T3' := getTerm(RP3)
    /\ T4' := getTerm(RP4)
    /\ B1:Bool := isCtorDefined(T2', M, ODS)
    /\ B2:Bool := isCtorDefined(T4', M, ODS)
    /\ B3:Bool := T1' == T3'
    /\ B4:Bool := T2' =/= T4'
	/\ B1:Bool and B2:Bool and B3:Bool
    ---[print T1' "  " T2' "   " B1:Bool " " B2:Bool " " B3:Bool]
  .

  ceq isConditionFalse(COND1 /\ (T1 = T2) /\ (T3 = T4) /\ COND2, M, ODS) = true
    if RP1 := metaReduce(M, T1)
    /\ RP2 := metaReduce(M, T2)
    /\ RP3 := metaReduce(M, T3)
    /\ RP4 := metaReduce(M, T4)
    /\ T1' := getTerm(RP1)
    /\ T2' := getTerm(RP2)
    /\ T3' := getTerm(RP3)
    /\ T4' := getTerm(RP4)
    /\ B1:Bool := isCtorDefined(T1', M, ODS)
    /\ B2:Bool := isCtorDefined(T3', M, ODS)
    /\ B3:Bool := T2' == T4'
    /\ B4:Bool := T1' =/= T3'
	/\ B1:Bool and B2:Bool and B3:Bool
    ---[print T1' "  " T2' "   " B1:Bool " " B2:Bool " " B3:Bool]
  .

  eq isConditionFalse(COND, M, ODS) = false [owise] .
  
  ---  eq isConditionFalse((COND1 /\ COND2), M, ODS) =
---     isConditionFalse(COND1, M, ODS) or isConditionFalse(COND2, M, ODS) .
  
  --- Checks whether a term is defined only using constructors.
  op isCtorDefined : TermList Module OpDeclSet -> Bool .

  eq  isCtorDefined(V, M, ODS)    = false .
  ceq isCtorDefined(C, M, ODS)    = B:Bool
    if B:Bool := isOinODS(getName(C), nil, getType(C), ODS)
    ---[print C "  " B:Bool]
  .
  ceq isCtorDefined(Q[TL], M, ODS)   =
      isCtorDefined(TL, M, ODS)
    if TyL := convTL2TyL(TL, M)
    /\ B:Bool := isOinODS(Q, TyL, getType(metaReduce(M, Q[TL])), ODS)
    ---[print Q "[" TL "]  ~  " B:Bool ]
  .
  
  eq  isCtorDefined(empty, M, ODS)   = true .
  ceq isCtorDefined((T, TL), M, ODS) =
      isCtorDefined(T, M, ODS) and isCtorDefined(TL, M, ODS)
    if TL =/= empty
  .
  
  --- Checks whether an operator is in an op. decl. set. when provided
  --- the signature of the op
  op isOinODS : Qid TypeList Type OpDeclSet -> Bool .
  ceq isOinODS(Q, TyL, Ty, ODS) = true
    if (op Q : TyL -> Ty [AS] .) ODS' := ODS
  .
  eq isOinODS(Q, TyL, Ty, ODS) = false [owise] .
  
  

  --- Checks whether a given term is a ground term (does not contain variables) or not.
  op isGroundTerm : Term -> Bool .
  eq isGroundTerm(C) = true .
  eq isGroundTerm(V) = false .
  eq isGroundTerm(Q[TL]) = areGroundTerms(TL) .
  
  op areGroundTerms : TermList -> Bool .
  eq areGroundTerms(empty) = true .
  eq areGroundTerms((T, TL)) = isGroundTerm(T) and areGroundTerms(TL) .

  
  var MP? : MatchPair? .

  --- Finds a substitution when provided:
  ---   the module
  ---   the pattern
  ---   the term
  ---   the substitution strategy
  ---   the index of the needed substition (0 is a good value)
  op findCasesSubst : Module Term Term SubstStrategy Nat -> Substitution .

  --- noTopXMatch
  ceq findCasesSubst(M, T-PTRN, T, noTopXMatch, N) = THETA
    if MP?   := metaXmatch(M, T-PTRN, T, nil, 2, unbounded, N)
    /\ MP?   :: MatchPair
    /\ (V-TH:Variable <- T-TH:Term) := getSubstitution(MP?)
    /\ C2VT:Term := c2v(T-TH:Term)
    /\ THETA := if (isGroundTerm(C2VT:Term))
                  then findCasesSubst(M, T-PTRN, T, noTopXMatch, (N + 1))
                  else (V-TH:Variable <- T-TH:Term)
                fi
  .
  
  --- noTopXMatch2
  ceq findCasesSubst(M, T-PTRN, T, noTopXMatch2, N) = THETA
    if MP?   := metaXmatch(M, T-PTRN, T, nil, 1, unbounded, N)
    /\ MP?   :: MatchPair
    /\ (V-TH:Variable <- T-TH:Term) := getSubstitution(MP?)
    /\ C2VT:Term := c2v(T-TH:Term)
    /\ THETA := if (isGroundTerm(C2VT:Term))
                  then findCasesSubst(M, T-PTRN, T, noTopXMatch2, (N + 1))
                  else (V-TH:Variable <- T-TH:Term)
                fi
  .
  
  --- firstXMatch
  ceq findCasesSubst(M, T-PTRN, T, firstXMatch, N) = THETA
    if MP?   := metaXmatch(M, T-PTRN, T, nil, 0, unbounded, N)
    /\ MP?   :: MatchPair
    /\ THETA := getSubstitution(MP?)
  .
  
  --- bottomXMatch
  --- do all the metaXmatch'es and choose the shortest term.
  ***()
  ceq findCasesSubst(M, T-PTRN, T, bottomXMatch, N) = THETA
    if MP?   := metaXmatch(M, T-PTRN, T, nil, 0, unbounded, N)
    /\ MP?   :: MatchPair
    /\ (V-TH:Variable <- T-TH:Term) := getSubstitution(MP?)
    /\ C2VT:Term                    := c2v(T-TH:Term)
    /\ RECURSIVE-THETA:Substitution := findCasesSubst(M, T-PTRN, T, bottomXMatch, (N + 1)) 
    /\ B-IS-GROUND:Bool             := isGroundTerm(C2VT:Term)
    /\ B-CAN-GO-DEEPER:Bool         := (RECURSIVE-THETA:Substitution =/= none)
    /\ THETA := if (B-IS-GROUND:Bool or B-CAN-GO-DEEPER:Bool)
                  then RECURSIVE-THETA:Substitution
                  else (V-TH:Variable <- T-TH:Term)
                fi
  .
  ***)
  ***(
  ceq findCasesSubst(M, T-PTRN, T, bottomXMatch, N) = THETA
    if THETA := findCasesSubst(M, T-PTRN, T, bottomXMatch, N, none)
  .
  ***)
  
  
  op findCasesSubst : Module Term Term SubstStrategy Nat Substitution ->
                      Substitution .
  
  ceq findCasesSubst(M, T-PTRN, T, bottomXMatch, N, THETA) =
      findCasesSubst(M, T-PTRN, T, bottomXMatch, (N + 1), THETA')
    if MP?   := metaXmatch(M, T-PTRN, T, nil, 0, unbounded, N)
    /\ MP?   :: MatchPair
    /\ (V-TH:Variable <- T-TH:Term) := getSubstitution(MP?)
    /\ C2VT:Term                    := c2v(T-TH:Term)
    /\ B-IS-GROUND:Bool             := isGroundTerm(C2VT:Term)
    /\ I-HEIGHT-OLD:Int := if (THETA =/= none)
                             then calcHeight(substToTermList(THETA))
                             else 1000000 
                           fi
    /\ I-HEIGHT-NEW:Int := if (B-IS-GROUND:Bool)
                             then (I-HEIGHT-OLD:Int + 1)
                             else calcHeight(T-TH:Term)
                           fi
    /\ THETA' := if (I-HEIGHT-NEW:Int < I-HEIGHT-OLD:Int)
                   then (V-TH:Variable <- T-TH:Term)
                   else THETA
                 fi
  .
  eq findCasesSubst(M, T-PTRN, T, bottomXMatch, N, THETA) = THETA [owise] .
  

  eq findCasesSubst(M, T-PTRN, T, S-STR:SubstStrategy, N) = none [owise] .
  
--------------------------------------------------------------------------------  
  --- RECOGNITION OF SPECIAL CONTEXTS
  --- Circular Reasoning in Behavioral Logics [CRBL]
  ---  G. Rosu, D. Lucanu
  

  var M-WITH-CTS                     : Module .
  var K-DEPTH                        : Nat .
  var TL-COBASIS TL-COBASIS-FILTR    : TermList .
  var TL-ATTR-FILTR                  : TermList .
  var TL-METH-FILTR                  : TermList .
  var TL-DERS                        : TermList .
  var TL-F1 TL-F2 TL-QF1 TL-QF2 TL-F : TermList .
  var SS-HIDDEN                      : SortSet .
  var T-COBASIS T-COBASIS-FILTR      : Term .
  
  --- Get the set of special (depth preserving) contexts.
  --- Input:
  ---   The set of candidate operations to be tested.
  ---   The set of candidate operations.
  ---     Intially -> the whole set of contexts from the specification.
  ---   The derivatives.
  ---   The hidden sorts.
  ---   The current theory module.
  --- Output:
  ---   The special (depth preserving) contexts.
  op calcOpsDepthPreserving : TermList TermList TermList SortSet NsList{CasePair} Module -> TermList .
  
  eq  calcOpsDepthPreserving(empty, TL-F, TL-DERS, SS, CPL, M) = TL-F .
  ceq calcOpsDepthPreserving((TL-QF1, T-F, TL-QF2), (TL-F1, T-F, TL-F2), TL-DERS, SS-HIDDEN, CPL, M) =
      if isDepthPreserving(T-F, (TL-F1, T-F, TL-F2), TL-COBASIS-FILTR, TL-DERS, SS-HIDDEN, CPL, M-WITH-CTS)
        then calcOpsDepthPreserving((TL-QF1, TL-QF2), (TL-F1, T-F, TL-F2), TL-DERS, SS-HIDDEN, CPL, M)
        else calcOpsDepthPreserving((TL-F1, TL-F2), (TL-F1, TL-F2), TL-DERS, SS-HIDDEN, CPL, M)
      fi
    if M-WITH-CTS := addCts(v2c(getVars(T-F)), M)
    /\ TL-COBASIS-FILTR := filterCobasis(TL-DERS, T-F, M)
  .


  --- Check whether a given context is depth preserving.
  --- Input:
  ---   The operation under test.
  ---   The list of candidate operations.
  ---   The filtered cobasis.
  ---   The cobasis.
  ---   The hidden sorts.
  ---   The current theory module.
  --- Output:
  ---   True - if the context is depth preserving, false - otherwise.
  op isDepthPreserving : Term TermList TermList TermList SortSet NsList{CasePair} Module -> Bool .
  
  eq isDepthPreserving(T-F, TL-F, empty, TL-DERS, SS-HIDDEN, CPL, M) = true .
  var TL-CANDIDATE-PIECES : TermList .
  
  eq isDepthPreserving(T-F, TL-F, (T-COBASIS-FILTR, TL-COBASIS-FILTR), TL-DERS, SS-HIDDEN, CPL, M) =
     isComposite(T-COBASIS-FILTR, T-F, TL-F, TL-DERS, SS-HIDDEN, CPL, M) and
     isDepthPreserving(T-F, TL-F, TL-COBASIS-FILTR, TL-DERS, SS-HIDDEN, CPL, M)
  .

  op isComposite : Term Term TermList TermList SortSet NsList{CasePair} Module -> Bool .
  
  ceq isComposite(T-COBASIS-FILTR, T-F, TL-SCXS, TL-DERS, SS-HIDDEN, CPL, M) = 
      B-IS-COMPOSITE:Bool
    if T                   := getTerm(metaReduce(M, (T-COBASIS-FILTR < T-F >)))
    /\ TL-CANDIDATE-PIECES := breakDepthPreservingCandidate(T, CPL, M)
    /\ B-IS-COMPOSITE:Bool := 
       areComposites(T-COBASIS-FILTR, TL-CANDIDATE-PIECES, TL-SCXS, TL-DERS, SS-HIDDEN, M)
  .

  op areComposites : Term TermList TermList TermList SortSet Module -> Bool .
  eq areComposites(T-COBASIS-FILTR, empty, TL-SCXS, TL-DERS, SS-HIDDEN, M) = true .
  eq areComposites(T-COBASIS-FILTR, (T, TL), TL-SCXS, TL-DERS, SS-HIDDEN, M) =
     isComposite(T-COBASIS-FILTR, T, TL-SCXS, TL-DERS, SS-HIDDEN, M) and
     areComposites(T-COBASIS-FILTR, TL, TL-SCXS, TL-DERS, SS-HIDDEN, M)
  .
  
  op isComposite : Term Term TermList TermList SortSet Module -> Bool .
  ceq isComposite(T-COBASIS-FILTR, T, TL-SCXS, TL-DERS, SS-HIDDEN, M) = 
      B-IS-COMPOSITE:Bool
    if I-HIDDEN-DEPTH      := calcHiddenDepth(T-COBASIS-FILTR, SS-HIDDEN, M)
    /\ I-COMPOSITE-DEPTH   := calcCompositeDepth(T, TL-SCXS, TL-DERS, SS-HIDDEN, M)
    /\ B-IS-COMPOSITE:Bool := I-COMPOSITE-DEPTH <= I-HIDDEN-DEPTH
  .
  
  eq isComposite(T-COBASIS-FILTR, T, TL-SCXS, TL-DERS, SS-HIDDEN, M) = false [owise] .
  
  op breakDepthPreservingCandidate : Term NsList{CasePair} Module -> TermList .
  eq breakDepthPreservingCandidate(T-F, CPL, M) =
     getTerms(breakDepthPreservingCandidate'(< T-F | nil >, CPL, M))
  . 
  
  var CPL1 CPL2 CPL1' CPL2' : NsList{CasePair} .
  var CPL-CASES : NsList{CasePair} .
  var CPL-PIECES : NsList{CasePair} .
  var CPL-TERMS CPL'-TERMS : NsList{CasePair} .
  var CP-TERM : CasePair .
  var CP-CASE : CasePair .
  var COND-SANTA : Condition . --- Santa because its sack growes bigger.
  var COND' : Condition .
  var T-PTRN : Term .
  var THETA THETA' : Substitution .
  var ES : EquationSet .
  var M' : Module .
  
  op breakDepthPreservingCandidate' : NsList{CasePair} NsList{CasePair} Module -> NsList{CasePair} .
  ceq breakDepthPreservingCandidate'(CPL-TERMS, CPL-CASES, M) = CPL'
    if CPL1 :CP: CP-TERM :CP: CPL2 := CPL-TERMS
    /\ CPL-PIECES  := calcCases(CP-TERM, CPL-CASES, M)
    /\ CPL-PIECES  =/= nsnil-CP
    /\ CPL'  := CPL1 :CP: CPL-PIECES :CP: CPL2
    
  .
  eq breakDepthPreservingCandidate'(CPL, CPL-CASES, M) = CPL
    [owise]
  .
  
  op calcCases  : CasePair NsList{CasePair} Module -> NsList{CasePair} .
  
  eq calcCases(CP-TERM, nsnil-CP, M) = nsnil-CP .
  ceq calcCases(CP-TERM, (CP-CASE :CP: CPL-CASES), M) =
      if (CPL-TERMS =/= nsnil-CP)
        then CPL-TERMS
        else calcCases(CP-TERM, CPL-CASES, M)
      fi
    if CPL-TERMS := calcCases'(CP-TERM, CP-CASE, M)
    ---[print CP-TERM " \n  " CP-CASE " :CP: " CPL-CASES "\n\n"]
  .

  op calcCases' : CasePair CasePair Module -> NsList{CasePair} .
  ceq calcCases'(CP-TERM, CP-CASE, M) = CPL-PIECES
    if < T-PTRN | COND > := CP-CASE
    /\ < T | COND-SANTA > := CP-TERM
    /\ THETA := if (isVariable(T-PTRN))
                  then findCasesSubst(M, T-PTRN, v2c(T), noTopXMatch2, 0)
                  else findCasesSubst(M, T-PTRN, v2c(T), firstXMatch, 0)
                fi
    /\ THETA =/= none
    /\ CPL-PIECES  := expandCases(M, CP-TERM, THETA, COND)
    ---[print CP-TERM "\n" CPL-PIECES "\n\n"]
  .
  eq calcCases'(CP-TERM, CP-CASE, M) = nsnil-CP [owise] .
  
  op expandCases : Module CasePair Substitution Condition -> NsList{CasePair} .
  eq expandCases(M, CP-TERM, THETA, (COND \/ COND')) =
     expandCases(M, CP-TERM, THETA, COND) :CP:
     expandCases(M, CP-TERM, THETA, COND')
  .
  ceq expandCases(M, < T | COND-SANTA >, THETA, COND') =
     < T' | COND >
    if COND  := COND-SANTA /\ applySubstCond(COND', THETA) 
    /\ ES    := convCond2Eqs(COND)
    /\ M'    := addEqs(ES, M)
    /\ T'    := c2v(getTerm(metaReduce(M', v2c(T))))
     [owise]
  .
  
  var I-HIDDEN-DEPTH I-COMPOSITE-DEPTH : Int .
  
  op EXC-COMPOSITE : -> [Int] .
  
  
  
  ---
  op calcCompositeDepth : TermList TermList TermList SortSet Module -> [Int] .
  
  --- =/= '* variable or constant
  ceq calcCompositeDepth(T, TL-SCXS, TL-DERS, SS-HIDDEN, M) = (-1)
    if (isVariable(T) and getName(T) =/= '*)
    or isConstant(T)
  .

  --- delta-context
  ceq calcCompositeDepth(T, TL-SCXS, TL-DERS, SS-HIDDEN, M) = 
      I-HIDDEN-DEPTH
    if (isDeltaContext(T, TL-DERS, M) or (isVariable(T) and getName(T) == '*))
    /\ I-HIDDEN-DEPTH := calcHiddenDepth(T, SS-HIDDEN, M)
  .

  --- data operation / generalized constant
  ceq calcCompositeDepth(Q[TL], TL-SCXS, TL-DERS, SS-HIDDEN, M) =
      calcCompositeDepth(TL, TL-SCXS, TL-DERS, SS-HIDDEN, M)
    if isVisible(TL, SS-HIDDEN, M)
  .

  --- context  
  ceq calcCompositeDepth(T-F, TL-SCXS, TL-DERS, SS-HIDDEN, M) =
      calcCompositeDepth(TL, TL-SCXS, TL-DERS, SS-HIDDEN, M)
    if (TL1, T, TL2) := TL-SCXS
    /\ sameKind(M, leastSort(M, T), leastSort(M, T-F))
    /\ theta := metaMatch(M, T, T-F, nil, 0)
    /\ theta :: Substitution
    /\ TL    := substToTermList(theta)
  .
  

  --- smart delta-context for T-F (a (k, Gamma)-Composite)
  ceq calcCompositeDepth(T-F, TL-SCXS, TL-DERS, SS-HIDDEN, M) =
      I-COMPOSITE-DEPTH
    if (TL', T, TL'') := TL-DERS
    /\ sameKind(M, leastSort(M, T), leastSort(M, T-F))
    /\ theta := metaMatch(M, T, T-F, nil, 0)
    /\ theta :: Substitution
    /\ TL3 := substToTermList(theta)
    /\ I-COMPOSITE-DEPTH :=
       calcCompositeDepth'(TL3, TL-SCXS, TL-DERS, SS-HIDDEN, M)
  .
  
  eq calcCompositeDepth(empty, TL-SCXS, TL-DERS, SS-HIDDEN, M) = (-1) .
  ceq calcCompositeDepth((T, TL), TL-SCXS, TL-DERS, SS-HIDDEN, M) = 
      max(
        calcCompositeDepth(T, TL-SCXS, TL-DERS, SS-HIDDEN, M),
        calcCompositeDepth(TL, TL-SCXS, TL-DERS, SS-HIDDEN, M)
      )
    if TL =/= empty
  .
  eq calcCompositeDepth(TL, TL-SCXS, TL-DERS, SS-HIDDEN, M) = EXC-COMPOSITE [owise] .


  ---
  op calcCompositeDepth' : TermList TermList TermList SortSet Module -> Int .
  
  --- derivative
  ceq calcCompositeDepth'(T-F, TL-SCXS, TL-DERS, SS-HIDDEN, M) =
      I-COMPOSITE-DEPTH
    if (TL', T, TL'') := TL-DERS
    /\ sameKind(M, leastSort(M, T), leastSort(M, T-F))
    /\ theta := metaMatch(M, T, T-F, nil, 0)
    /\ theta :: Substitution
    /\ TL3 := substToTermList(theta)
    /\ I-COMPOSITE-DEPTH :=
       calcCompositeDepth'(TL3, TL-SCXS, TL-DERS, SS-HIDDEN, M)
  .
  
  --- generalized constant
  ceq calcCompositeDepth'(T-F, TL-SCXS, TL-DERS, SS-HIDDEN, M) =
      I-COMPOSITE-DEPTH
    if isGeneralizedConst(T-F, SS-HIDDEN, M)
    /\ I-COMPOSITE-DEPTH :=
       calcCompositeDepth(T-F, TL-SCXS, TL-DERS, SS-HIDDEN, M)
  .
  
  --- a (-1, Gamma) context
  ceq calcCompositeDepth'(T-F, TL-SCXS, TL-DERS, SS-HIDDEN, M) =
      I-COMPOSITE-DEPTH
    if I-COMPOSITE-DEPTH :=
       calcCompositeDepth(T-F, TL-SCXS, TL-DERS, SS-HIDDEN, M)
    /\ I-COMPOSITE-DEPTH == (-1)
  .
  
  eq calcCompositeDepth'(TL, TL-SCXS, TL-DERS, SS-HIDDEN, M) = EXC-COMPOSITE [owise] .
  

  ---
  var I-STAR-DEPTH : Int .
  var B-NO-STAR    : Bool .
  var B-IS-HIDDEN  : Bool .
  
  --- Computes the depth until * for a term. Returns -1
  op calcStarDepth : TermList SortSet Module -> Int .
  
  ceq calcStarDepth(V, SS-HIDDEN, M) = 0
    if (getName(V) == '*) and (getType(V) in SS-HIDDEN)
  .
  eq calcStarDepth(V, SS-HIDDEN, M) = (-1) [owise] .
  eq calcStarDepth(C, SS-HIDDEN, M) = (-1) .
  ceq calcStarDepth(Q[TL], SS-HIDDEN, M) =
      if B-NO-STAR then 0 else 1 fi + I-STAR-DEPTH
    if I-STAR-DEPTH := calcStarDepth(TL, SS-HIDDEN, M)
    /\ B-NO-STAR    := (I-STAR-DEPTH < 0) --- if there is no *, leave -1
  .
  eq calcStarDepth(empty, SS-HIDDEN, M) = (-1) .
  ceq calcStarDepth((T, TL), SS-HIDDEN, M) = 
      max(
        calcStarDepth(T, SS-HIDDEN, M),
        calcStarDepth(TL, SS-HIDDEN, M)
      )
    if TL =/= empty
  .

  --- Computes the hidden depth of a term.
  op calcHiddenDepth : TermList SortSet Module -> Int .
  
  ceq calcHiddenDepth(Q[TL], SS-HIDDEN, M) =
      if B-IS-HIDDEN then 1 else 0 fi + I-STAR-DEPTH
    if I-STAR-DEPTH := calcStarDepth(TL, SS-HIDDEN, M)
    /\ B-IS-HIDDEN  := leastSort(M, Q[TL]) in SS-HIDDEN
  .
  eq calcHiddenDepth(T, SS-HIDDEN, M) = calcStarDepth(T, SS-HIDDEN, M) [owise] .
  eq calcHiddenDepth(empty, SS-HIDDEN, M) = 0 .
  ceq calcHiddenDepth((T, TL), SS-HIDDEN, M) =
      max(calcHiddenDepth(T, SS-HIDDEN, M), calcHiddenDepth(TL, SS-HIDDEN, M))
    if (TL =/= empty)
  .
  
  --- Computes the height (depth) of a term.
  op calcHeight : TermList -> Int .
  
  eq calcHeight(V) = 1 .
  eq calcHeight(C) = 1 .
  eq calcHeight(Q[TL]) = 1 + calcHeight(TL) .
  eq calcHiddenDepth(T, SS-HIDDEN, M) = calcStarDepth(T, SS-HIDDEN, M) [owise] .
  eq calcHeight(empty) = 0 .
  ceq calcHeight((T, TL)) = max(calcHeight(T), calcHeight(TL))
    if (TL =/= empty)
  .
  
  
  --- Check whether an operation is a generalized constant.
  ---  (returns hidden sort and has visible arguments)
  op isGeneralizedConst : Term SortSet Module -> Bool .
  
  ceq isGeneralizedConst(F[TL], SS-HIDDEN, M) = true
    if (leastSort(M, F[TL]) in SS-HIDDEN) and
       isVisible(TL, SS-HIDDEN, M)
  .
  eq isGeneralizedConst(T, SS-HIDDEN, M) = false [owise] .
  

  --- Filter the cobasis according to a given term.
  --- Input:
  ---   The cobasis.
  ---   The given term.
  ---   The current theory module.
  --- Used for preventing an error when trying to do "derivative < term >" .
     
  op filterCobasis : TermList Term Module -> TermList .
  
  eq filterCobasis(empty, T-F, M) = empty .
  eq filterCobasis((T, TL), T-F, M) =
     if sameKind(M, leastSort(M, T-F), getSortsHidden(T))
     then (T, filterCobasis(TL, T-F, M))
     else filterCobasis(TL, T-F, M)
     fi
  .
  
  ---
  op isDeltaContext : TermList TermList Module -> Bool .
  
  ceq isDeltaContext(T, TL-DERS, M) = true
    if (isVariable(T) or isConstant(T))
  .
  
  ceq isDeltaContext(Q[TL], TL-DERS, M) = true
    if (TL', T, TL'') := TL-DERS
    /\ doesMetaMatch(T, Q[TL], M)
    /\ isDeltaContext(TL, TL-DERS, M)
  .
  
  eq isDeltaContext(empty, TL-DERS, M) = true .
  ceq isDeltaContext((T, TL), TL-DERS, M) =
      isDeltaContext(T, TL-DERS, M) and
      isDeltaContext(TL, TL-DERS, M)
    if (TL =/= empty)
  .
  eq isDeltaContext(TL, TL-DERS, M) = false [owise] .
  
  
  --- Check whether a given term is data term.
  --- Input: the term to be tested,
  ---        the set of hidden sorts.
  --- Output: true - if the term is data term, false - otherwise.
  op isDataTerm : Term SortSet Module -> Bool .
  
  eq isDataTerm(C, SS-HIDDEN, M)     = not (getType(C) in SS-HIDDEN) .
  eq isDataTerm(V, SS-HIDDEN, M)     = not (getType(V) in SS-HIDDEN) .
  eq isDataTerm(Q[TL], SS-HIDDEN, M) = 
     areDataTerms(TL, SS-HIDDEN, M) and
     not (leastSort(M, Q[TL]) in SS-HIDDEN) .
  eq isDataTerm(T, SS-HIDDEN, M)     = false [owise] .
  
  
  --- Check whether a given term is data operator.
  --- Input: the term,
  ---        the hidden sorts,
  ---        The current theory module.
  op isDataOp : Term SortSet Module -> Bool .
  
  eq isDataOp(Q[TL], SS-HIDDEN, M) = areDataTerms(TL, SS-HIDDEN, M) and
                              not (leastSort(M, Q[TL]) in SS-HIDDEN) .
  eq isDataOp(T, SS-HIDDEN, M)     = false [owise] .
  
  
  --- Check whether a given term list contains only data terms.
  --- Input:
  ---   The term list.
  ---   The hidden sorts.
  ---   The current theory module.
  op areDataTerms : TermList SortSet Module -> Bool .
  
  eq areDataTerms((T, TL), SS-HIDDEN, M) =
     isDataTerm(T, SS-HIDDEN, M) and
     areDataTerms(TL, SS-HIDDEN, M) .
  eq areDataTerms(empty, SS-HIDDEN, M) = true .
  
  
  --- Check whether all the terms in a term list are of visible sorts.
  --- Input:
  ---   The term list.
  ---   The hidden sorts.
  ---   The current theory module.
  
  op isVisible : TermList SortSet Module -> Bool .
  eq isVisible(empty, SS-HIDDEN, M) = true .
  eq isVisible(C, SS-HIDDEN, M) = not (getType(C) in SS-HIDDEN) .
  eq isVisible(V, SS-HIDDEN, M) = not (getType(V) in SS-HIDDEN) .
  eq isVisible(Q[TL], SS-HIDDEN, M) =
     not (leastSort(M, Q[TL]) in SS-HIDDEN) .
  ceq isVisible((T, TL), SS-HIDDEN, M) =
      isVisible(T, SS-HIDDEN, M) and
      isVisible(TL, SS-HIDDEN, M)
    if (TL =/= empty)
  .
  
  var COND : EqCondition .
  op isVisible : Equation SortSet Module -> Bool .
  eq isVisible((eq T = T' [AS] .), SS-HIDDEN, M) =
     isVisible(T, SS-HIDDEN, M) and isVisible(T', SS-HIDDEN, M) .
  eq isVisible((ceq T = T' if COND [AS] .), SS-HIDDEN, M) =
     isVisible(T, SS-HIDDEN, M) and isVisible(T', SS-HIDDEN, M) .
    
  sort TermListTuple .
  op TL<_,_> : TermList TermList -> TermListTuple .

  var TL-TRANSFORMED  TL-RESULT  : TermList .
  var TL-TRANSFORMED' TL-RESULT' : TermList .



  var T-SIGN                     : Term .
  var TL-SIGN TL-SIGN' TL-SIGN'' : TermList .
  
  
  var V-STAR : Variable .
  
  
  --- Special contexts - set auto contexts on/off . implementation ---
  
  var USR-MSG-SCX : QidList .
  var TL-SCXS-SPEC TL-SCXS-AUTO
      TL-SCXS-VALID TL-SCXS-WARNING : TermList .
  var CPL CPL' : NsList{CasePair} .
  var CP CP' : CasePair .
  
  --- Determines the list of special contexts,
  ---   from the specification or/and automatically computed.
  --- Input:
  ---   The candidate contexts from the specification.
  ---   The current theory module.
  ---   The derivatives.
  ---   The hidden sorts.
  ---   A switch indicating whether to automatically compute the contexts or not.
  --- Output:
  ---   The list of special contexts and a special message for the user.   
  op calcValidScxs : TermList Module TermList SortSet NsList{CasePair} SwitchStatus -> TermListTuple .
  
  eq calcValidScxs(empty, M, TL-DERS, SS-HIDDEN, CPL, off) = TL< empty, ('\n) > .
  ceq calcValidScxs(TL-SCXS-SPEC, M, TL-DERS, SS-HIDDEN, CPL, off) =
      TL< TL-SCXS-SPEC, ('\n USR-MSG-SCX) >
    if TL-SCXS-SPEC =/= empty
    /\ TL-SCXS-AUTO       := calcCandidateScxs(getOps(M), M, TL-DERS, SS-HIDDEN)
    /\ TL-SCXS-CAND       := union(TL-SCXS-SPEC, TL-SCXS-AUTO, M)
    /\ true
    /\ TL-SCXS-VALID      := filterScxs(TL-SCXS-CAND, TL-DERS, SS-HIDDEN, CPL, M)
    /\ TL-SCXS-WARNING    := difference(TL-SCXS-SPEC, TL-SCXS-VALID, M)
    /\ true
    /\ TL-SCXS            := calcCandidateScxs(getOps(M), M, TL-DERS, SS-HIDDEN)
    /\ USR-MSG-SCX        := if TL-SCXS-WARNING == empty
                               then ('\g 'All 'the 'specified 'contexts 'are 'special: '\o '\n
                                     ---printTermList(M, TL-SCXS)
                                     printTermList(M, TL-SCXS-SPEC)
                                    )
                               else ('\g 'The 'following 'specified 'contexts
                                     'may 'not 'be 'special: '\o '\n
                                     printTermList(M, TL-SCXS-WARNING)
                                    )
                             fi
   ---[print TL-SCXS-SPEC]
  .

  ceq calcValidScxs(empty, M, TL-DERS, SS-HIDDEN, CPL, on) =
      TL< TL-SCXS, ('\n USR-MSG-SCX) >
    if TL-SCXS-CAND := calcCandidateScxs(getOps(M), M, TL-DERS, SS-HIDDEN)
    /\ TL-SCXS      := filterScxs(TL-SCXS-CAND, TL-DERS, SS-HIDDEN, CPL, M)
    /\ true
    /\ QL           := printTermList(M, TL-SCXS)
    /\ USR-MSG-SCX  := ('\g 'The 'special 'contexts 'are: '\o '\n QL)
  .

  ceq calcValidScxs(TL-SCXS-SPEC, M, TL-DERS, SS-HIDDEN, CPL, on) =
      TL< TL-SCXS, ('\n USR-MSG-SCX) >
    if TL-SCXS-SPEC =/= empty
    /\ TL-SCXS-AUTO       := calcCandidateScxs(getOps(M), M, TL-DERS, SS-HIDDEN)
    /\ TL-SCXS-CAND       := union(TL-SCXS-SPEC, TL-SCXS-AUTO, M)
    /\ true
    /\ TL-SCXS-VALID      := filterScxs(TL-SCXS-CAND, TL-DERS, SS-HIDDEN, CPL, M)
    /\ TL-SCXS-WARNING    := difference(TL-SCXS-SPEC, TL-SCXS-VALID, M)
    /\ true
    /\ TL-SCXS            := union(TL-SCXS-VALID, TL-SCXS-SPEC, M)
    /\ USR-MSG-SCX        := if TL-SCXS-WARNING == empty
                               then ('\g 'All 'the 'specified 'contexts 'are 'special '\o '\n
                                     printTermList(M, TL-SCXS)
                                    )
                               else ('\g 'The 'following 'specified 'contexts
                                     'may 'not 'be 'special: '\o '\n
                                     printTermList(M, TL-SCXS-WARNING)
                                    )
                             fi
  .
  
  eq calcValidScxs(TL, M, TL-DERS, SS-HIDDEN, CPL, SW) =
    TL< empty, ('\n 'SCX: 'Should 'not 'reach 'this 'state) > [owise] .
  
  
  --- Determines the union of two lists of operations.
  op union : TermList TermList Module -> TermList .
  
  ceq union((TL1, Q[TL'], TL2), (TL3, Q[TL''], TL4), M) =
    (Q[TL'], union((TL1, TL2), (TL3, TL4), M))
    if sameOp(Q[TL'], Q[TL''], M)
  .
  ceq union((TL1, Q[TL'], TL2), TL, M) =
    (Q[TL'], union((TL1, TL2), TL, M))
    if not opInOpList(Q[TL'], TL, M)
  .
  ceq union(empty, TL, M) = TL
    if TL =/= empty
  .
  eq union(TL1, TL2, M) = empty [owise] .
  
  
  --- Determines the difference between two lists of operations.
  op difference : TermList TermList Module -> TermList .
  
  ceq difference((Q[TL'], TL1), TL, M) =
    if (not opInOpList(Q[TL'], TL, M))
      then (Q[TL'], difference(TL1, TL, M))
      else difference(TL1, TL, M)
    fi
    if TL =/= empty
  .
  eq difference(empty, empty, M) = empty .
  ceq difference(TL, empty, M) = TL
    if TL =/= empty
  .
  ceq difference(empty, TL, M) = empty
    if TL =/= empty
  . 
  
  
  --- Checks whether a list of operations contains a given operation. 
  op opInOpList : Term TermList Module -> Bool .
  
  eq opInOpList(Q[TL], (T, TL'), M) =
    sameOp(Q[TL], T, M) or
    opInOpList(Q[TL], TL', M)
  .
  eq opInOpList(Q[TL], empty, M) = false .
  
  
  --- Checks whether two operations are equal.
  op sameOp : Term Term Module -> Bool .
  
  ceq sameOp(Q[TL], Q[TL'], M) = true
    if leastSort(M, Q[TL]) == leastSort(M, Q[TL'])
    /\ sameType(TL, TL', M)
  .
  eq sameOp(T, T', M) = false [owise] .
  
  
  --- Checks whether the terms on the same position from
  --- two separate lists of terms have the same type.
  op sameType : TermList TermList Module -> Bool .
  
  eq sameType((T, TL), (T', TL'), M) =
     (leastSort(M, T) == leastSort(M, T')) and
     sameType(TL, TL', M)
  .
  eq sameType(empty, empty, M) = true .

  ceq sameType((T, TL), (T', TL'), M) = false
    if leastSort(M, T) =/= leastSort(M, T')
  . 
  ceq sameType(empty, TL, M) = false
    if TL =/= empty
  .
  ceq sameType(TL, empty, M) = false
    if TL =/= empty
  .
  
  op hasTypes : TermList TypeList Module -> Bool .
  
  eq hasTypes((T, TL), (Ty TyL), M) =
     (leastSort(M, T) == Ty) and
     hasTypes(TL, TyL, M)
  .
  eq hasTypes(empty, nil, M) = true .
  eq hasTypes(TL, TyL, M) = false [owise] .
  
  
  --- Filters the special contexts when provided a list of candidate contexts.
  --- Input:
  ---   The candidate contexts.
  ---   The derivatives.
  ---   The hidden sorts.
  ---   The current theory module.
  --- Output:
  ---   The special contexts.
  op filterScxs : TermList TermList SortSet NsList{CasePair} Module -> TermList .
  
  eq filterScxs(TL-SCXS-CAND, TL-DERS, SS-HIDDEN, CPL, M) =
     calcOpsDepthPreserving(
       TL-SCXS-CAND,
       TL-SCXS-CAND,
       TL-DERS,
       SS-HIDDEN,
       CPL,
       M
     )
  .
  
  ---
  op checkScx : Term TermList TermList TermList SortSet NsList{CasePair} Module -> Bool .
  
  eq checkScx(T-F, TL-SCXS, TL-COBASIS, TL-DERS, SS-HIDDEN, CPL, M) =
    isDepthPreserving(T-F, (T-F, TL-SCXS), TL-COBASIS, TL-DERS, SS-HIDDEN, CPL, M)
  .
  
  op isDerivative : OpDecl TermList Module -> Bool .
  
  ceq isDerivative((op Q : TyL -> Ty [AS] .), TL-DERS, M) = true
    if (TL1, T, TL2) := TL-DERS
    /\ Q[TL] := T
    /\ hasTypes(TL, TyL, M)
    /\ sameKind(M, Ty, leastSort(M, T))
  .
  
  eq isDerivative(OD, TL-DERS, M) = false [owise] .
  
  --- Deduce the candidate special contexts.
  --- Input:
  ---   The set of operations within the specification module.
  ---   The current theory module.
  ---   The derivatives.
  ---   The hidden sorts.
  --- Output:
  ---   The candidate special contexts, computed from
  ---     operations of hidden type, that receive at least one hidden argument.
  op calcCandidateScxs : OpDeclSet Module TermList SortSet -> TermList .
  
  eq calcCandidateScxs(none, M, TL-DERS, SS-HIDDEN) = empty .
  eq calcCandidateScxs((OD ODS), M, TL-DERS, SS-HIDDEN) =
      (
      if (not isDerivative(OD, TL-DERS, M))
        then calcScxsFromOp(OD, M, SS-HIDDEN)
        else empty
      fi
      ,
      calcCandidateScxs(ODS, M, TL-DERS, SS-HIDDEN)
      )
  .
  
  
  sort NsList{Nat} .
  subsort Nat < NsList{Nat} .
  op nsnil-N : -> NsList{Nat} .
  op _:N:_ : NsList{Nat} NsList{Nat} -> NsList{Nat} [assoc id: nsnil-N] .
             
  var STAR-POS : NsList{Nat} .
  
  
  --- Determines a list of candidate contexts when provided an operator.
  --- E.g.: from (op zip : Stream Stream -> Stream)
  ---       deduce (zip[*:Stream, V:Stream], zip[V:Stream, *:Stream])
  --- Input:
  ---   The operator declaration.
  ---   The current theory module.
  ---   The hidden sorts.
  --- Output:
  ---   The list of candidate contexts.
  --- Stars for every hidden variable V:HiddenSort
  op calcScxsFromOp : OpDecl Module SortSet -> TermList .
  
  ceq calcScxsFromOp((op Q : TyL -> Ty [AS] .), M, SS-HIDDEN) = 
      generateScx((op Q : TyL -> Ty [AS] .), STAR-POS)
    if (Ty in SS-HIDDEN) --- true
    /\ STAR-POS := calcStarPos(TyL, M, SS-HIDDEN, 0)
  .
  eq calcScxsFromOp(OD, M, SS-HIDDEN) = empty [owise] .
  
  --- Determines the positions of the hidden types, when provided a type list.
  --- E.g.: (Stream Nat Nat Stream Nat) => (1, 4)
  --- Input:
  ---   The list of types.
  ---   The current theory module.
  ---   The hidden sorts.
  ---   The last hidden sort position.
  --- Output:
  ---   The hidden types positions.
  op calcStarPos : TypeList Module SortSet Nat -> NsList{Nat} .
  
  eq calcStarPos((Ty TyL), M, SS-HIDDEN, N) =
    if (Ty in SS-HIDDEN)
      then ((N + 1) :N: calcStarPos(TyL, M, SS-HIDDEN, (N + 1)))
      else calcStarPos(TyL, M, SS-HIDDEN, (N + 1))
    fi
  .
  eq calcStarPos(nil, M, SS-HIDDEN, N) = nsnil-N .
  
  
  --- Generates a list of contexts when provided
  ---   an operator
  ---   the hidden sorts' positions
  --- E.g. generateScx(zip, (Stream Stream), (1 :N: 2)) =>
  ---   (zip[*:Stream, V#2:Stream], zip[V#1:Stream, *:Stream])
  op generateScx : OpDecl NsList{Nat} -> TermList .
  
  ceq generateScx((op Q : TyL -> Ty [AS] .), (N :N: STAR-POS)) =
    (Q[TL], generateScx((op Q : TyL -> Ty [AS] .), STAR-POS))
    if (TyL1 Ty1 TyL2) := TyL
    /\ getLength(TyL1) == (N + (-1))
    /\ Star:Qid := qid("*:" + string(Ty1))
    /\ TL := (newVars(TyL1, 1), Star:Qid, newVars(TyL2, (N + 1)))
  .
  eq generateScx(OD, STAR-POS) = empty [owise] .
  
  
  --- Determines the length of a type list.
  op getLength : TypeList -> Nat .
  
  eq getLength(Ty TyL) = (1 + getLength(TyL)) .
  eq getLength(nil) = 0 .
  
  
  --- Builds a list of new variables, when provided a list of types.
  op newVars : TypeList Nat -> TermList .
  
  eq newVars(nil, N) = empty .
  eq newVars((Ty TyL), N) = (newVar(Ty, N), newVars(TyL, (N + 1))) .
  
  
  --- Prints a list of terms when provided the spec. module and the terms.
  op printTermList : Module TermList -> QidList .
  
  eq printTermList(M, empty) = '\n .
  eq printTermList(M, (T, TL)) =
     (metaPrettyPrint(M, T) '\n
      printTermList(M, TL))
  . 
  
endfm --- ALGORITHMS

***( ===========================================================================
*
* ============================================================================ )

mod CIRC-UNIT is

  including ALGORITHMS .
  protecting DATABASE-HANDLING .
  protecting META-CIRC-LANG-SIGN  .
  protecting CIRC-DECL .

  sort CTheory .

  subsorts FTheory < CTheory < Module .
  subsorts STheory < CTheory < Module .
  

  var B          : Bool .
  var CDS CDS'   : ClassDeclSet .
  var DB         : Database .
  var DDL DDL'   : DerDeclList .
  var ESDL ESDL' : EnumSortDeclList .
  var GEDL GEDL' : GrdEqDeclList .
  var CEDL CEDL' : CaseEqDeclList .
  var COND       : EqCondition .
  var EqS EqS'   : EquationSet .
  var H H'       : Header .
  var I I'       : Import .
  var IL IL'     : ImportList .
  var MAS MAS'   : MembAxSet .
  var M M'       : Module .
  var U U' PU    : Module .
  var ME ME'     : ModuleExpression .
  var MN MN'     : ModuleName .
  var MDS MDS'   : MsgDeclSet .
  var OPDS OPDS' : OpDeclSet .
  var VDS        : OpDeclSet .
  var OPDS?      : [OpDeclSet] .
  var PD PD'     : ParameterDecl .
  var PDL PDL'   : ParameterDeclList .
  var PL PL'     : ParameterList .
  var RPS        : NsNeSet{ResultPair?} .
  var Q V        : Qid .
  var QL QL'     : QidList .
  var QL1 QL2    : QidList .
  var RP1 RP2    : ResultPair? .
  var RlS RlS'   : RuleSet .
  var SRDL SRDL' : SimpRlDeclList .
  var SS SS'     : SortSet .
  var SCDL SCDL' : SpeCtxDeclList .
  var SSDS SSDS' : SubsortDeclSet .
  var T T' T''   : Term .
  var T1' T2'    : Term .
  var T1 T2 T3   : Term .
  var TL TL'     : TermList .
  var SCD SCD'   : SubclassDecl .
  var SCDS SCDS' : SubclassDeclSet .
  var CTH CTH'   : CTheory .


  --- Gets the flattened form of a theory. It also enhances the GEDL.
  op getFlatCth   : Qid Database          -> [Module] .
  op getFlatCth'  : Qid Database [Module] -> [Module] .
  op getFlatCth'' : QidList Database [Module] -> [Module] .
  
  eq getFlatCth(ME, DB) = (getFlatCth'(ME, DB, emptyCTheory(ME))) .
  
  ceq getFlatCth'(Q, DB, 
        theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) =
      getFlatCth''(QL, DB,
        theory H is calcImportListUnion(IL', IL) sorts (SS' ; SS) .
          (SSDS' SSDS) (OPDS' OPDS) (MAS' MAS) (EqS' EqS) (RlS' RlS)
          (DDL' DDL) (SCDL' SCDL) (SRDL' SRDL) (ESDL' ESDL)
          (GEDL' GEDL) (CEDL' CEDL)
        endtheory
      )
    if CTH' := getTopModule(Q, DB)
    /\ theory H' is IL' sorts SS' . SSDS' OPDS' MAS' EqS' RlS' DDL' SCDL' SRDL' ESDL' GEDL' CEDL'
       endtheory := getTopModule(Q, DB)
    /\ QL := convImportList2QidList(IL')
  .
  eq getFlatCth'(Q, DB, CTH) = CTH [owise] .

  eq getFlatCth''(Q QL, DB, CTH) = 
     getFlatCth'(Q, DB, getFlatCth''(QL, DB, CTH)) .
  eq getFlatCth''(nil, DB, CTH) = CTH .


  op emptyCTheory : -> CTheory .
  eq emptyCTheory =
    theory nullHeader is nil sorts none . none none none none none none none none none none none endtheory .
  
  op emptyCTheory : Qid -> CTheory .
  eq emptyCTheory(Q) =
    theory Q is nil sorts none . none none none none none none none none none none none endtheory .

  op theory_is_sorts_.___________endtheory : Header ImportList SortSet SubsortDeclSet
    OpDeclSet MembAxSet EquationSet RuleSet DerDeclList SpeCtxDeclList SimpRlDeclList 
    EnumSortDeclList GrdEqDeclList CaseEqDeclList ->
    CTheory [ctor gather (& & & & & & & & & & & & & &)
       format (g! o g! n++io ni d d ni ni ni ni ni ni ni ni ni ni ni n--ig! o)] .

  eq rightEmptyModule(U1:FTheory, U2:CTheory) = emptyFTheory .
  eq rightEmptyModule(U1:CTheory, U2:FTheory) = emptyFTheory .
  eq rightEmptyModule(U1:STheory, U2:CTheory) = emptySTheory .
  eq rightEmptyModule(U1:CTheory, U2:STheory) = emptySTheory .
  eq rightEmptyModule(U1:CTheory, U2:CTheory) = emptyCTheory .
  eq rightEmptyModule(U1:FModule, U2:CTheory) = emptyCTheory .
  eq rightEmptyModule(U1:CTheory, U2:FModule) = emptyCTheory .
  eq rightEmptyModule(U1:SModule, U2:CTheory) = emptyCTheory .
  eq rightEmptyModule(U1:CTheory, U2:SModule) = emptyCTheory .

  *** Error handling operators  
  op derError : QidList -> [DerDeclList] [ctor format (r o)] .
  eq derError(QL) derError(QL') = derError(QL QL') .

  op scxError : QidList -> [SpeCtxDeclList] [ctor format (r o)] .
  eq scxError(QL) scxError(QL') = scxError(QL QL') .
  
  op srlError : QidList -> [SimpRlDeclList] [ctor format (r o)] .
  eq srlError(QL) srlError(QL') = srlError(QL QL') .
  
  op geqError : QidList -> [GrdEqDeclList] [ctor format (r o)] .
  eq geqError(QL) geqError(QL') = geqError(QL QL') .
  
  op aeqError : QidList -> [CaseEqDeclList] [ctor format (r o)] .
  eq aeqError(QL) aeqError(QL') = aeqError(QL QL') .
  
  *** Derivatives unit operators

  op setDers : DerDeclList Module ~> Module .
  op addDers : DerDeclList Module -> Module .
  op getDers : Module             -> DerDeclList .

  eq addDers(DDL, U) = setDers((getDers(U) DDL), U) .

  eq getDers(unitError(QL)) = none .
  eq getDers(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = DDL .
  eq getDers(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getDers(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getDers(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getDers(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getDers(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = none .
  eq getDers(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = none .


  eq setDers(DDL', unitError(QL)) = unitError(QL) .
  eq setDers(DDL?1:[DerDeclList] derError(QL) DDL?2:[DerDeclList], U) = unitError(QL) .
  eq setDers(DDL?1:[DerDeclList] derError(QL') DDL?2:[DerDeclList], unitError(QL)) 
    = unitError(QL QL') .
  eq setDers(DDL', theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory)
    = theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL' SCDL SRDL ESDL GEDL CEDL endtheory 
    .
  eq setDers(DDL', mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setDers(DDL', th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth)
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setDers(DDL', fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setDers(DDL', fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth)
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setDers(DDL', omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setDers(DDL', oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .

  eq parseDecl('derivative_.['bubble[T]], PU, U, VDS) =
     parseDecl('der_.['bubble[T]], PU, U, VDS) .
  eq parseDecl('der_.['bubble[T]], PU, U, VDS)
    = < addDers((der 'bubble[T] .), PU) ;
        addDers((der 'bubble[T] .), U) ; VDS > .


*** Special contexts unit operators

  op setSpeCtxs : SpeCtxDeclList Module ~> Module .
  op addSpeCtxs : SpeCtxDeclList Module -> Module .
  op getSpeCtxs : Module             -> SpeCtxDeclList .

  eq addSpeCtxs(SCDL, U) = setSpeCtxs((getSpeCtxs(U) SCDL), U) .

  eq getSpeCtxs(unitError(QL)) = none .
  eq getSpeCtxs(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = SCDL .
  eq getSpeCtxs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getSpeCtxs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getSpeCtxs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getSpeCtxs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getSpeCtxs(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = none .
  eq getSpeCtxs(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = none .

  eq setSpeCtxs(SCDL', unitError(QL)) = unitError(QL) .
  eq setSpeCtxs(SCDL?1:[SpeCtxDeclList] scxError(QL) SCDL?2:[SpeCtxDeclList], U) = unitError(QL) .
  eq setSpeCtxs(SCDL?1:[SpeCtxDeclList] scxError(QL') SCDL?2:[SpeCtxDeclList], unitError(QL)) 
    = unitError(QL QL') .
  eq setSpeCtxs(SCDL', theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory)
    = theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL' SRDL ESDL GEDL CEDL endtheory .
  eq setSpeCtxs(SCDL', mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setSpeCtxs(SCDL', th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth)
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setSpeCtxs(SCDL', fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setSpeCtxs(SCDL', fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth)
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setSpeCtxs(SCDL', omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setSpeCtxs(SCDL', oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .

  eq parseDecl('special-context_.['bubble[T]], PU, U, VDS) =
     parseDecl('scx_.['bubble[T]], PU, U, VDS) .
  eq parseDecl('scx_.['bubble[T]], PU, U, VDS)
    = < addSpeCtxs((scx 'bubble[T] .), PU) ;
        addSpeCtxs((scx 'bubble[T] .), U) ; VDS > .
*** Enum sorts unit operators

  op setEnumSorts : EnumSortDeclList Module ~> Module .
  op addEnumSorts : EnumSortDeclList Module -> Module .
  op getEnumSorts : Module                  -> EnumSortDeclList .

  eq addEnumSorts(ESDL, U) = setEnumSorts((getEnumSorts(U) ESDL), U) .

  eq getEnumSorts(unitError(QL)) = none .
  eq getEnumSorts(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = ESDL .
  eq getEnumSorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getEnumSorts(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getEnumSorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getEnumSorts(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getEnumSorts(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = none .
  eq getEnumSorts(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = none .

  eq setEnumSorts(ESDL', unitError(QL)) = unitError(QL) .
  eq setEnumSorts(ESDL', theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory)
    = theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL' GEDL CEDL endtheory .
  eq setEnumSorts(ESDL', mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setEnumSorts(ESDL', th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth)
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setEnumSorts(ESDL', fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setEnumSorts(ESDL', fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth)
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setEnumSorts(ESDL', omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setEnumSorts(ESDL', oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .


  ceq parseDecl('enum_is_.['token[T], 'bubble[T']], PU, U, VDS)
    = < addEnumSorts((enum Q is QL .), PU) ;
        addEnumSorts((enum Q is QL .), U) ;
        VDS >
    if Q  := downQid(T)
    /\ QL := downQidList(T')
  .




*** Guarded equations for case analysis unit operators

  op setGrdEqDecl : GrdEqDeclList Module ~> Module .
  op addGrdEqDecl : GrdEqDeclList Module -> Module .
  op getGrdEqDecl : Module               -> GrdEqDeclList .

  eq addGrdEqDecl(GEDL, U) = setGrdEqDecl((getGrdEqDecl(U) GEDL), U) .

  eq getGrdEqDecl(unitError(QL)) = none .
  eq getGrdEqDecl(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = GEDL .
  eq getGrdEqDecl(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getGrdEqDecl(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getGrdEqDecl(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getGrdEqDecl(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getGrdEqDecl(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = none .
  eq getGrdEqDecl(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = none .

  eq setGrdEqDecl(GEDL', unitError(QL)) = unitError(QL) .
  eq setGrdEqDecl(GEDL?1:[GrdEqDeclList] geqError(QL) GEDL?2:[GrdEqDeclList], U) = unitError(QL) .
  eq setGrdEqDecl(GEDL?1:[GrdEqDeclList] geqError(QL') GEDL?2:[GrdEqDeclList], unitError(QL)) 
    = unitError(QL QL') .
  
  eq setGrdEqDecl(GEDL', theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory)
    = theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL' CEDL endtheory .
  eq setGrdEqDecl(GEDL', mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setGrdEqDecl(GEDL', th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth)
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setGrdEqDecl(GEDL', fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setGrdEqDecl(GEDL', fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth)
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setGrdEqDecl(GEDL', omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setGrdEqDecl(GEDL', oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .


  eq parseDecl('geq_=_.[T, T'], PU, U, VDS)
    = < addGrdEqDecl((geq T = T' .), PU) ;
        addGrdEqDecl((geq T = T' .), U) ;
        VDS >
  .
  


*** Case equations for case analysis unit operators

  op setCaseEqDecl : CaseEqDeclList Module ~> Module .
  op addCaseEqDecl : CaseEqDeclList Module -> Module .
  op getCaseEqDecl : Module               -> CaseEqDeclList .

  eq addCaseEqDecl(CEDL, U) = setCaseEqDecl((getCaseEqDecl(U) CEDL), U) .

  eq getCaseEqDecl(unitError(QL)) = none .
  eq getCaseEqDecl(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = CEDL .
  eq getCaseEqDecl(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getCaseEqDecl(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getCaseEqDecl(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getCaseEqDecl(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getCaseEqDecl(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = none .
  eq getCaseEqDecl(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = none .

  eq setCaseEqDecl(CEDL', unitError(QL)) = unitError(QL) .
  eq setCaseEqDecl(CEDL?1:[CaseEqDeclList] aeqError(QL) CEDL?2:[CaseEqDeclList], U) = unitError(QL) .
  eq setCaseEqDecl(CEDL?1:[CaseEqDeclList] aeqError(QL') CEDL?2:[CaseEqDeclList], unitError(QL)) 
    = unitError(QL QL') .
  
  eq setCaseEqDecl(CEDL', theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory)
    = theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL' endtheory .
  eq setCaseEqDecl(CEDL', mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setCaseEqDecl(CEDL', th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth)
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setCaseEqDecl(CEDL', fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setCaseEqDecl(CEDL', fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth)
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setCaseEqDecl(CEDL', omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setCaseEqDecl(CEDL', oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .


  eq parseDecl('cases`pattern`=_if_.[T, T'], PU, U, VDS)
    = < addCaseEqDecl((cases pattern = T if T' .), PU) ;
        addCaseEqDecl((cases pattern = T if T' .), U) ;
        VDS >
  ---[print T "\n" T']
  .

*** Simplifying rules unit operators

  op setSimpRls : SimpRlDeclList Module ~> Module .
  op addSimpRls : SimpRlDeclList Module -> Module .
  op getSimpRls : Module                -> SimpRlDeclList .

  eq addSimpRls(SRDL, U) = setSimpRls((getSimpRls(U) SRDL), U) .

  eq getSimpRls(unitError(QL)) = none .
  eq getSimpRls(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = SRDL .
  eq getSimpRls(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getSimpRls(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getSimpRls(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getSimpRls(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getSimpRls(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = none .
  eq getSimpRls(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = none .

  eq setSimpRls(SRDL', unitError(QL)) = unitError(QL) .
  eq setSimpRls(SRDL?1:[SimpRlDeclList] srlError(QL) SRDL?2:[SimpRlDeclList], U) = unitError(QL) .
  eq setSimpRls(SRDL?1:[SimpRlDeclList] srlError(QL') SRDL?2:[SimpRlDeclList], unitError(QL)) 
    = unitError(QL QL') .
  eq setSimpRls(SRDL', theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory)
    = theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL' ESDL GEDL CEDL endtheory .
  eq setSimpRls(SRDL', mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setSimpRls(SRDL', th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth)
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setSimpRls(SRDL', fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setSimpRls(SRDL', fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth)
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setSimpRls(SRDL', omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setSimpRls(SRDL', oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .

  eq parseDecl('csrl_=>_if_.[T1, T2, T3], PU, U, VDS)
    = < addSimpRls((csrl 'none : T1 => T2 if T3 .), PU) ;
        addSimpRls((csrl 'none : T1 => T2 if T3 .), PU) ;
        VDS >
  .

  eq parseDecl('srl_=>_.[T1, T2], PU, U, VDS)
    = < addSimpRls((csrl 'none : T1 => T2 if
          'bubble['__[''`(.Qid,''true.Qid,''=.Qid,''true.Qid,''`).Qid]] .), PU) ;
        addSimpRls((csrl 'none : T1 => T2 if
          'bubble['__[''`(.Qid,''true.Qid,''=.Qid,''true.Qid,''`).Qid]] .), PU) ;
        VDS >
  .

*** Overloaded unit operators

  eq empty(theory MN is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory)
    = theory MN is nil sorts none . none none none none none none none none none none none endtheory .

  eq theory(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = true .
  eq getName(theory ME is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = ME .
  eq getName(theory ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = ME .
  eq getImports(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = IL .
  eq getPars(theory ME is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = nil .
  eq getPars(theory ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = PDL .
  eq getPars(theory nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) =
       nil .
  eq getSorts(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = SS .
  eq getSubsorts(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = SSDS .
  eq getOps(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = OPDS .
  eq getMbs(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = MAS .
  eq getEqs(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = EqS .
  eq getRls(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = RlS .
  eq getClasses(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = none .
  eq getSubclasses(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = none .
  eq getMsgs(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) = none .


  eq setName(theory nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, ME')
    = theory ME' is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory .
  eq setName(theory ME is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, ME')
    = theory ME' is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory .
  eq setName(theory ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, ME')
    = theory ME'{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory .

  eq setImports(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, IL')
    = theory H is IL' sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory .
  eq setPars(theory ME is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, PDL)
    = if PDL == nil
      then theory ME is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory
      else theory ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory
      fi .
  eq setPars(theory ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, PDL')
    = if PDL' == nil
      then theory ME is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory
      else theory ME{PDL'} is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory
      fi .
  eq setOps(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, OPDS')
    = theory H is IL sorts SS . SSDS OPDS' MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory .
  eq setSubsorts(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, SSDS')
    = theory H is IL sorts SS . SSDS' OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory .
  eq setMbs(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, MAS')
    = theory H is IL sorts SS . SSDS OPDS MAS' EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory .
  eq setEqs(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, EqS')
    = theory H is IL sorts SS . SSDS OPDS MAS EqS' RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory .
  eq setSorts(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, SS')
    = theory H is IL sorts SS' . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory .

  --- should also be considered for mod-ules.
  eq setRls(theory MN is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, RlS')
    = (theory MN is IL sorts SS . SSDS OPDS MAS EqS RlS' DDL SCDL SRDL ESDL GEDL CEDL endtheory) .
    
  --- should also be considered for omod-ules.
  eq setClasses(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, CDS)
    = theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory .
  eq setSubclasses(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, SCDS)
    = theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory .
  eq setMsgs(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory, MDS)
    = theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory .


  ceq transform(U, DB) = theory2th(U, DB)
    if not U :: OModule /\
       not U :: OTheory /\
       U :: CTheory
    ---[print U]
  .

  op theory2th : Module Database -> Module .
  op theory2th : Module -> Module .

  eq theory2th(theory H is IL sorts SS . SSDS OPDS MAS EqS RlS DDL SCDL SRDL ESDL GEDL CEDL endtheory) =
     th H is IL sorts (SS ; getSortsFromEnums(ESDL)) .
       SSDS
       (OPDS getOpsFromEnums(ESDL))
       MAS
       EqS
       RlS
     endth
     ---[print ESDL]
  .
  eq theory2th(M, DB) = theory2th(M) .

  var Q-SORT-NAME : Qid .
  ---var ESD : EnumSortDecl .
  op getSortsFromEnums : EnumSortDeclList -> SortSet .
  eq getSortsFromEnums(none) = none .
  eq getSortsFromEnums((enum Q-SORT-NAME is QL .) ESDL) = Q-SORT-NAME ; getSortsFromEnums(ESDL) .
  
  op getOpsFromEnums : EnumSortDeclList -> OpDeclSet .
  eq getOpsFromEnums(none) = none .
  eq getOpsFromEnums((enum Q-SORT-NAME is QL .) ESDL) =
     getOpsFromQidList(Q-SORT-NAME, QL)
     getOpsFromEnums(ESDL)
  .
  
  op getOpsFromQidList : Qid QidList -> OpDeclSet .
  eq getOpsFromQidList(Q-SORT-NAME, nil) = none .
  eq getOpsFromQidList(Q-SORT-NAME, Q QL) =
     (op Q : nil -> Q-SORT-NAME [ctor] .)
     getOpsFromQidList(Q-SORT-NAME, QL)
  .

  --- TODO: don't we need to add srls, ctxs, geqs... etcs ?
  ceq addDecls(U, U') =
      addImports(getImports(U'),
        addSorts(getSorts(U'),
          addSubsorts(getSubsorts(U'),
            addOps(getOps(U'),
              addMbs(getMbs(U'),
                addEqs(getEqs(U'),
                  addDers(getDers(U'),
                    addSpeCtxs(getSpeCtxs(U'),
                      if U' :: FModule or U' :: FTheory
                      then U
                      else addRls(getRls(U'), U)
                      fi
                    )
                  )
                )
              )
            )
          )
        )
      )
    if U  :: CTheory or
       U' :: CTheory
  ---[print U']
  .
  

  op evalPreModule2' : Module Module Module OpDeclSet Database -> Database .
  op solveBubblesCth : Module OpDeclSet Module Bool OpDeclSet Database ->
                       Module .


  ceq evalPreModule1(PU, U, nil, U', VDS, DB)
    = evalPreModule2'(PU, U,
        signature(transform(addDecls(U', setImports(U, nil)), DB)), VDS, DB)
    if U :: CTheory
    ---[print U]
  .

  eq evalPreModule2'(PU, U, M, VDS, DB)
    *** PU : top module with bubbles
    *** U  : everything below
    *** M  : complete signature
    = evalPreModule3(
        solveBubblesCth(PU, getOps(U), M,
          included('META-MODULE, getImports(PU), DB), VDS, DB),
        U, M,
        insertVars(getName(PU), VDS,
          insertTopModule(getName(PU),
            solveBubblesCth(PU, getOps(U), M,
              included('META-MODULE, getImports(PU), DB), VDS, DB), DB)))
  .
              
  ceq solveBubblesCth(PU, OPDS, M, B, VDS, DB)
    = setOps(
        (if getGrdEqDecl(PU)  == none and
            getCaseEqDecl(PU) == none and
            getSimpRls(PU)    == none and
            getDers(PU)       == none and
            getMbs(PU)        == none and
            getEqs(PU)        == none and
            getRls(PU)        == none
         then PU
         else 
           setGrdEqDecl(solveBubbles(
                          getGrdEqDecl(PU), M', addInfoConds(M'), B, VDS, DB
                        ),
             setCaseEqDecl(solveBubbles(
                            getCaseEqDecl(PU), M', addInfoConds(M'), B, VDS, DB
                          ),
               setSimpRls(solveBubbles(
                            getSimpRls(PU), M', addInfoConds(M'), B, VDS, DB
                          ),
                 setDers(solveBubbles(
                           getDers(PU), M', addInfoConds(M'), B, VDS, DB
                         ),
                   setSpeCtxs(solveBubbles(
                                getSpeCtxs(PU), M', addInfoConds(M'), B, VDS, DB
                              ),
                     setEqs(
                       setMbs(
                         setRls(PU,
                           solveBubbles(getRls(PU), M', addInfoConds(M'), B, VDS, DB)
                         ),
                         solveBubbles(getMbs(PU), M', addInfoConds(M'), B, VDS, DB)
                       ),
                       solveBubbles(getEqs(PU), M', addInfoConds(M'), B, VDS, DB)
                     )
                   )
                 )
               )
             )
           )
        fi),
      solveBubblesOps(getOps(PU), OPDS, M'))
    if M' := addOps(VDS, M)
  .

  


  var TL1 TL2 : TermList .
  
  op haveStars : TermList -> Bool .
  eq haveStars(T) = hasStar(T) .
  ceq haveStars((TL1, TL2)) = haveStars(TL1) and haveStars(TL2)
    if TL1 =/= empty
    /\ TL2 =/= empty
  .
  
  op hasStar : TermList -> Bool .
  eq hasStar(V:Variable) = getName(V:Variable) == '* .
  eq hasStar(C:Constant) = false .
  eq hasStar(Q[TL]) = hasStar(TL) .
  ceq hasStar((TL1, TL2)) = hasStar(TL1) or hasStar(TL2) 
    if TL1 =/= empty
    /\ TL2 =/= empty
  .


  *** Error handling equations for new syntactical constructs.
  eq (der qidError(QL) .) = derError(QL) .
  eq (scx qidError(QL) .) = scxError(QL) .
  eq (csrl (Q) : qidError(QL) => T1?:[Term] if T2?:[Term] .) = srlError(QL) .  
  eq (csrl (Q) : T?:[Term] => qidError(QL1) if T2?:[Term] .) = srlError(QL1) .
  eq (csrl (Q) : T?:[Term] => T1?:[Term] if qidError(QL2) .) = srlError(QL2) .
  eq (geq qidError(QL) = T?:[Term] .) = geqError(QL) .
  eq (geq T?:[Term] = qidError(QL) .) = geqError(QL) .
  eq (cases pattern = qidError(QL) if T?:[Term] .) = aeqError(QL) .
  eq (cases pattern = T?:[Term] if qidError(QL) .) = aeqError(QL) .  

  *** Bubbles Solving

  op solveBubbles : DerDeclList Module [Module] Bool OpDeclSet Database
       -> [DerDeclList] .
       
  eq solveBubbles((none).DerDeclList, M, M', B, VDS, DB) = (none).DerDeclList .
  ceq solveBubbles(((der 'bubble[T] .) DDL), M, M', B, VDS, DB) =
    (der TL' .) (solveBubbles(DDL, M, M', B, VDS, DB))
    if QL := downTerm(T, 'nil)
    /\ RPS := parseForSetOfTermsInModule(M, QL)
    /\ RPS :: NsNeSet{ResultPair}
    /\ TL' :=  getUnwrappedTermList(RPS)
    /\ haveStars(TL')
    ---[print TL']
  .
  
  eq solveBubbles(DDL, M, unitError(QL), B, VDS, DB) = derError(QL) .
  
  *** No parse for derivative
  ceq solveBubbles(((der 'bubble[T] .) DDL), M, M', B, VDS, DB) =
      (der TL?:[TermList] .) (solveBubbles(DDL, M, M', B, VDS, DB))
    if QL := downTerm(T, 'nil)
    /\ RPS := parseForSetOfTermsInModule(M, QL)
    /\ not RPS :: NsNeSet{ResultPair}
    /\ TL?:[TermList] := qidError('\r 'Error: '\o 'no 'parse 'for '\s QL '\n)
  .
  
  *** Derivative has no *
  ceq solveBubbles(((der 'bubble[T] .) DDL), M, M', B, VDS, DB) =
      (der TL?:[TermList] .) (solveBubbles(DDL, M, M', B, VDS, DB))
    if QL := downTerm(T, 'nil)
    /\ RPS := parseForSetOfTermsInModule(M, QL)
    /\ RPS :: NsNeSet{ResultPair}
    /\ TL' := getUnwrappedTermList(RPS)
    /\ not haveStars(TL')
    /\ TL?:[TermList] := qidError('\r 'Error: '\o QL '\s 'invalid 'derivative
                                    qid("(") 's qid(")") '\s '--
                                    'not 'enough '"*" 'variables '\n)
                                    ---[print TL']
  .
  
  op solveBubbles : SpeCtxDeclList Module [Module] Bool OpDeclSet Database
       -> [SpeCtxDeclList] .
  eq solveBubbles((none).SpeCtxDeclList, M, M', B, VDS, DB) =
       (none).SpeCtxDeclList .
  ceq solveBubbles(((scx 'bubble[T] .) SCDL), M, M', B, VDS, DB) =
    (scx TL' .) (solveBubbles(SCDL, M, M', B, VDS, DB))
    if QL  := downTerm(T, 'nil)
    /\ RPS := parseForSetOfTermsInModule(M, QL)
    /\ RPS :: NsNeSet{ResultPair}
    /\ TL' := getUnwrappedTermList(RPS)
    /\ haveStars(TL')
  .
  eq solveBubbles(SCDL, M, unitError(QL), B, VDS, DB) = scxError(QL) .
  
  *** No parse for special context
  ceq solveBubbles(((scx 'bubble[T] .) SCDL), M, M', B, VDS, DB) =
      (scx TL?:[TermList] .) (solveBubbles(SCDL, M, M', B, VDS, DB))
    if QL := downTerm(T, 'nil)
    /\ RPS := parseForSetOfTermsInModule(M, QL)
    /\ not RPS :: NsNeSet{ResultPair}
    /\ TL?:[TermList] := qidError('\r 'Error: '\o 'no 'parse 'for '\s QL '\n)
  .
  
  *** Special context has no *
  ceq solveBubbles(((scx 'bubble[T] .) SCDL), M, M', B, VDS, DB) =
      (scx TL?:[TermList] .) (solveBubbles(SCDL, M, M', B, VDS, DB))
    if QL := downTerm(T, 'nil)
    /\ RPS := parseForSetOfTermsInModule(M, QL)
    /\ RPS :: NsNeSet{ResultPair}
    /\ TL' := getUnwrappedTermList(RPS)
    /\ not haveStars(TL')
    /\ TL?:[TermList] := qidError('\r 'Error: '\o QL '\s 'invalid 'special 'context
                                    qid("(") 's qid(")") '\s '--
                                    'not 'enough '"*" 'variables '\n)
  .

  op solveBubbles : SimpRlDeclList Module [Module] Bool OpDeclSet Database
       -> SimpRlDeclList .
  eq solveBubbles((none).SimpRlDeclList, M, M', B, VDS, DB) =
       (none).SimpRlDeclList .  
  eq parseCond('_\/_[T, T'], VDS) = parseCond(T, VDS) \/ parseCond(T', VDS) .
  
  ceq solveBubbles((csrl Q : 'bubble[T] => 'bubble[T'] if 'bubble[T''] .) SRDL, M, M', B, VDS, DB)
      = (csrl (Q) : parseCond(getTerm(RP), VDS) =>
                    parseCond(getTerm(RP1), VDS) if
                    parseCond(getTerm(RP2), VDS) .)
        (solveBubbles(SRDL, M, M', B, VDS, DB))
     if M'' := addOps(
                 (op '_\/_ : '@Condition@ '@Condition@ -> '@Condition@ [assoc ctor prec(75)] .),
                 M'
               )
     /\ QL  := downQidList(T)
     /\ QL1 := downQidList(T')
     /\ QL2 := downQidList(T'')
     /\ RP  := metaParse(M'', '`( QL '`), '@Condition@)
     /\ RP1 := metaParse(M'', '`( QL1 '`), '@Condition@)
     /\ RP2 := metaParse(M'', '`( QL2 '`), '@Condition@)
     /\ RP  :: ResultPair
     /\ RP1 :: ResultPair
     /\ RP2 :: ResultPair
  .
  
  eq solveBubbles(SRDL, M, unitError(QL), B, VDS, DB) = srlError(QL) .
  ceq solveBubbles((csrl Q : 'bubble[T] => 'bubble[T'] if 'bubble[T''] .) SRDL, M, M', B, VDS, DB)
      = (csrl (Q) : T?:[Type] => T1?:[Type] if T2?:[Type] .)
        (solveBubbles(SRDL, M, M', B, VDS, DB))
     if M'' := addOps(
                 (op '_\/_ : '@Condition@ '@Condition@ -> '@Condition@ [assoc ctor prec(75)] .),
                 M'
               )
     /\ QL  := downQidList(T)
     /\ QL1 := downQidList(T')
     /\ QL2 := downQidList(T'')
     /\ RP  := metaParse(M'', '`( QL '`), '@Condition@)
     /\ RP1 := metaParse(M'', '`( QL1 '`), '@Condition@)
     /\ RP2 := metaParse(M'', '`( QL2 '`), '@Condition@)
     /\ ((not RP :: ResultPair) or (not RP1 :: ResultPair) or (not RP2 :: ResultPair))
     /\ T?:[Type] :=
         if (not RP :: ResultPair)
           then qidError('\r 'Warning: '\o printSyntaxError(RP, QL) '\n
                         '\r 'Error: '\o 'no 'parse 'for QL '\n)
           else getTerm(RP)
         fi
     /\ T1?:[Type] :=
         if (not RP1 :: ResultPair)
           then qidError('\r 'Warning: '\o printSyntaxError(RP1, QL1) '\n
                         '\r 'Error: '\o 'no 'parse 'for QL1 '\n)
           else getTerm(RP1)
         fi
     /\ T2?:[Type] :=
         if (not RP2 :: ResultPair)
           then qidError('\r 'Warning: '\o printSyntaxError(RP2, QL2) '\n
                         '\r 'Error: '\o 'no 'parse 'for QL2 '\n)
           else getTerm(RP2)
         fi
  .
  
  
  op addInfoGeqs : Module -> Module .

  eq addInfoGeqs(M) =
     addOps(
       (op '_if_`[`] : 'Universal '@Condition@ -> '@Case@ [poly(1) prec(70)] .)
       (op '_`[owise`] : 'Universal -> '@Case@ [poly(1) prec(70)] .)
       (op '__ : '@CaseList@ '@CaseList@ -> '@CaseList@ [assoc prec(80)] .)
       (op '@wrapper : 'Universal -> '@@@ [poly(1)] .),
       addSubsorts((subsort '@Case@ < '@CaseList@ .),
         addSorts('@@@ ; '@Case@ ; '@CaseList@ , M)
       )
     )
  .
  
  --- Turns the provided term into a list of cases.
  op getCaseList : Term OpDeclSet -> CaseList .
  eq getCaseList('__[T, T'], VDS) =
     getCaseList(T, VDS)
     getCaseList(T', VDS)
  .
  eq getCaseList('_if_`[`][T, T'], VDS) =
     constsToVars(T, VDS) if (parseCond(T', VDS)) []
  .
  eq getCaseList('_`[owise`][T], VDS) =
     constsToVars(T, VDS) [owise]
  . 

  var RP  : ResultPair? .
  var RP' : ResultPair? .
  var M'' : Module .
  var T-WRAPPED T'-WRAPPED : Term .
  var CL : CaseList .
  op solveBubbles : GrdEqDeclList Module [Module] Bool OpDeclSet Database
                    -> GrdEqDeclList .
  eq solveBubbles((none).GrdEqDeclList, M, M', B, VDS, DB) =
       (none).GrdEqDeclList .

  --- Getting a term from a bubble is a strange ritual.
  --- First you get the qid list from the bubble, then you wrap it,
  --- then you parse it, then you unwrap it. Oh, wrapping means
  --- temporary meta-adding an operator (@wrapper) and a sort (@@@).
  --- Isn't this fun ?!?
  ceq solveBubbles(
        (geq 'bubble[T] = 'bubble[T'] .) GEDL, M, M', B, VDS, DB
      ) = (geq constsToVars(T-WRAPPED, VDS) = CL .)
          (solveBubbles(GEDL, M, M', B, VDS, DB))
    if QL         := downQidList(T)
    /\ M''        := addInfoGeqs(M')
    /\ RP         := metaParse(M'', '@wrapper '`( QL '`), '@@@)
    /\ T-WRAPPED  := getUnwrappedTerm(RP)
    /\ QL'        := downQidList(T')
    /\ RP'        := metaParse(M'', '@wrapper '`( QL' '`), '@@@)
    /\ T'-WRAPPED := getUnwrappedTerm(RP')
    /\ CL         := getCaseList(T'-WRAPPED, VDS)
  .
  eq solveBubbles(GEDL, M, unitError(QL), B, VDS, DB) = geqError(QL) .
  ceq solveBubbles((geq 'bubble[T] = 'bubble[T'] .) GEDL, M, M', B, VDS, DB) =
      (geq T?:[Type] = T'?:[Type] .) (solveBubbles(GEDL, M, M', B, VDS, DB))
    if QL         := downQidList(T)
    /\ QL'        := downQidList(T')
    /\ M''        := addInfoGeqs(M')
    /\ RP         := metaParse(M'', '@wrapper '`( QL '`), '@@@)
    /\ RP'        := metaParse(M'', '@wrapper '`( QL' '`), '@@@)
    /\ ((not RP :: ResultPair) or (not RP' :: ResultPair))
    /\ T?:[Type] :=
         if (not RP :: ResultPair)
           then qidError('\r 'Warning: '\o printSyntaxError(RP, QL) '\n
                         '\r 'Error: '\o 'no 'parse 'for QL '\n)
           else getTerm(RP)
         fi
    /\ T'?:[Type] :=
         if (not RP' :: ResultPair)
           then qidError('\r 'Warning: '\o printSyntaxError(RP', QL') '\n
                         '\r 'Error: '\o 'no 'parse 'for QL' '\n)
           else getTerm(RP')
         fi
  .


  op addInfoCaeqs : Module -> Module .

  eq addInfoCaeqs(M) =
     addOps(
       (op '_\/_ : '@Condition@ '@Condition@ -> '@Condition@ [assoc ctor prec(73)] .)
       (op '@wrapper : 'Universal -> '@@@ [poly(1)] .),
         addSorts('@@@ , M)
     )
  .

  op solveBubbles : CaseEqDeclList Module [Module] Bool OpDeclSet Database
                    -> CaseEqDeclList .
  eq solveBubbles((none).CaseEqDeclList, M, M', B, VDS, DB) =
       (none).CaseEqDeclList .
  ceq solveBubbles(
        (cases pattern = 'bubble[T] if 'bubble[T'] .) CEDL, M, M', B, VDS, DB
      ) = (cases pattern = constsToVars(T-WRAPPED, VDS) if COND .)
          (solveBubbles(CEDL, M, M', B, VDS, DB))
    if QL         := downQidList(T)
    /\ M''        := addInfoCaeqs(M')
    /\ RP         := metaParse(M'', '@wrapper '`( QL '`), '@@@)
    /\ T-WRAPPED  := getUnwrappedTerm(RP)
    /\ QL'        := downQidList(T')
    /\ RP'        := metaParse(M'', '@wrapper '`( QL' '`), '@@@)
    /\ COND := parseCond(getUnwrappedTerm(RP'), VDS)
  .
  eq solveBubbles(CEDL, M, unitError(QL), B, VDS, DB) = aeqError(QL) .
  ceq solveBubbles((cases pattern = 'bubble[T] if 'bubble[T'] .) CEDL, M, M', B, VDS, DB) =
      (cases pattern = T?:[Type] if T'?:[Type] .) (solveBubbles(CEDL, M, M', B, VDS, DB))
    if QL         := downQidList(T)
    /\ QL'        := downQidList(T')
    /\ M''        := addInfoGeqs(M')
    /\ RP         := metaParse(M'', '@wrapper '`( QL '`), '@@@)
    /\ RP'        := metaParse(M'', '@wrapper '`( QL' '`), '@@@)
    /\ ((not RP :: ResultPair) or (not RP' :: ResultPair))
    /\ T?:[Type] :=
         if (not RP :: ResultPair)
           then qidError('\r 'Warning: '\o printSyntaxError(RP, QL) '\n
                         '\r 'Error: '\o 'no 'parse 'for QL '\n)
           else getTerm(RP)
         fi
    /\ T'?:[Type] :=
         if (not RP' :: ResultPair)
           then qidError('\r 'Warning: '\o printSyntaxError(RP', QL') '\n
                         '\r 'Error: '\o 'no 'parse 'for QL' '\n)
           else getTerm(RP')
         fi
  .
  

--- Get new syntax from the polished top module and translate it into
--- the internal module in the database
--------------------------------------------------------------------------------
  var ES ES' : EquationSet .
  var E E' : Equation .
  var DB' DB'' DB''' : Database .

  var M-TOP : Module .
  op fillInternal : Qid Database -> Database .
  
  --- also enhance the GEDL
  ceq fillInternal(Q, DB) = DB''
    if M-TOP := getTopModule(Q, DB)
    /\ GEDL  := getGrdEqDecl(M-TOP)
    /\ ES    := getEqsFromGeqs(GEDL)
    /\ DB'   := insertFlatModule(Q, addEqs(ES, getFlatModule(Q, DB)), DB)
    /\ DB''  := insertInternalModule(Q, addEqs(ES, getInternalModule(Q, DB')), DB')
  .
  
  var GED : GrdEqDecl .
  
  ***(
  op enhanceGEDL : Module -> Module .
  eq enhanceGEDL(M-TOP) = setGrdEqDecl(enhanceGEDL(getGrdEqDecl(M-TOP)), M-TOP) .
  
  op enhanceGEDL : GrdEqDeclList -> GrdEqDeclList .
  eq enhanceGEDL(none) = none .
  eq enhanceGEDL(GED GEDL) = enhanceGED(GED) enhanceGEDL(GEDL) .
  
  op enhanceGED : GrdEqDecl -> GrdEqDecl .
  eq enhanceGED((geq T = CL .)) = (geq T = enhanceCases(T, CL) .) .
  
  op enhanceCases : Term CaseList -> CaseList .
  eq enhanceCases(T, C CL) = enhanceCases(T, C) enhanceCases(T, CL) .
  eq enhanceCases(T, (T' if COND [])) = (T' if (COND /\ (T = T')) []) .
  eq enhanceCases(T, (T' [owise])) = (T' if (T = T')  []) . 
  )

  var CL' : CaseList .
  var C : Case .
  
  --- Takes each case from each guarded equation from a list and
  --- returns the corresponding conditional equations.
  op getEqsFromGeqs : GrdEqDeclList -> EquationSet .
  eq getEqsFromGeqs(none) = none .
  ceq getEqsFromGeqs((geq T = C .)) = (ceq T = T' if COND [none] .)
    if (T' if COND []) := C
  .
  ceq getEqsFromGeqs((geq T = C .)) = none if (T' [owise]) := C .
  ***(
  ceq getEqsFromGeqs((geq T = C .)) = (eq T = T' [owise] .) if (T' [owise]) := C .
  )
  eq getEqsFromGeqs((geq T = (C CL) .) GEDL) =
     getEqsFromGeqs(geq T = C .)
     getEqsFromGeqs((geq T = CL .) GEDL)
  .
  eq getEqsFromGeqs((geq T = C .) GEDL) =
     getEqsFromGeqs(geq T = C .)
     getEqsFromGeqs(GEDL)
  .

--------------------------------------------------------------------------------

*** Overloaded printing operator

  eq eMetaPrettyPrint(M, theory MN is IL sorts SS . SSDS OPDS MAS EqS RlS
                             DDL SCDL SRDL ESDL GEDL CEDL endtheory)
    = ('\n '\b
       'theory '\o eMetaPrettyPrint(MN) '\b 'is '\o
          eMetaPrettyPrint(IL)
          (if SS == none
             then nil
             else ('\n '\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o)
           fi)
          eMetaPrettyPrint(SSDS)
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS)
          eMetaPrettyPrint(M, EqS)
          eMetaPrettyPrint(M, RlS)
          eMetaPrettyPrint(M, DDL)
          eMetaPrettyPrint(M, SCDL)
          eMetaPrettyPrint(M, SRDL)
          eMetaPrettyPrint(M, ESDL)
          eMetaPrettyPrint(M, GEDL)
          eMetaPrettyPrint(M, CEDL)
       '\n '\b 'endtheory '\o '\n)
  .

  op eMetaPrettyPrint : Module DerDeclList -> QidList .
  eq eMetaPrettyPrint(M, (der T .) DDL) =
     ('\n '\s '\s '\b 'der '\o eMetaPrettyPrint(M, T) '\s '\b '. '\o)
     eMetaPrettyPrint(M, DDL)
  .
  eq eMetaPrettyPrint(M, (none).DerDeclList) = nil .

  op eMetaPrettyPrint : Module SpeCtxDeclList -> QidList .
  eq eMetaPrettyPrint(M, (scx T .) SCDL) =
     ('\n '\s '\s '\b 'scx '\o eMetaPrettyPrint(M, T) '\s '\b '. '\o)
     eMetaPrettyPrint(M, SCDL)
  .
  eq eMetaPrettyPrint(M, (none).SpeCtxDeclList) = nil .

  var PTD CPTD : EqCondition .
  op eMetaPrettyPrint : Module SimpRlDeclList -> QidList .

  eq eMetaPrettyPrint(M, (csrl Q : PTD => CPTD if COND .) SRDL) =
     ('\n '\s '\s '\b 'csrl '\o Q '\b ': '\o '\n
     '\s '\s '\s '\s eMetaPrettyPrint(M, PTD) '\b '=> '\o '\n
     '\s '\s '\s '\s eMetaPrettyPrint(M, CPTD) '\n
     '\s '\s '\s '\s '\b 'if '\o 
     eMetaPrettyPrint(M, COND)
     '\b '. '\o)
     eMetaPrettyPrint(M, SRDL)
  .
  
  eq eMetaPrettyPrint(M, (none).SimpRlDeclList) = nil .
  
  op eMetaPrettyPrint : Module EnumSortDeclList -> QidList .
  eq eMetaPrettyPrint(M, (enum S:Sort is QL .) ESDL) =
     ('\n '\s '\s '\b 'enum '\o S:Sort '\b 'is '\o QL '\b '. '\o) .
  eq eMetaPrettyPrint(M, (none).EnumSortDeclList) = nil .
  
  op eMetaPrettyPrint : Module GrdEqDeclList -> QidList .
  eq eMetaPrettyPrint(M, (geq T = CL .) GEDL) =
     ('\n '\s '\s '\b 'geq '\o eMetaPrettyPrint(M, T) '\b '= '\o
     eMetaPrettyPrint(M, CL) '\n
     '\s '\s '\b '. '\o)
     eMetaPrettyPrint(M, GEDL)
  .
  eq eMetaPrettyPrint(M, (none).GrdEqDeclList) = nil .

  op eMetaPrettyPrint : Module CaseList -> QidList .
  eq eMetaPrettyPrint(M, CL CL') =
     eMetaPrettyPrint(M, CL)
     eMetaPrettyPrint(M, CL')
  .
  eq eMetaPrettyPrint(M, T if COND []) =
     '\n '\s '\s '\s '\s eMetaPrettyPrint(M, T) '\s '\b 'if '\o 
     eMetaPrettyPrint(M, COND) '\s '\b qid("[") qid("]") '\o
  .
  eq eMetaPrettyPrint(M, T [owise]) =
     '\n '\s '\s '\s '\s eMetaPrettyPrint(M, T) '\s '\b
     qid("[") 'owise qid("]") '\o
  .
  
  op eMetaPrettyPrint : Module CaseEqDeclList -> QidList .
  eq eMetaPrettyPrint(M, (cases pattern = T if COND .) CEDL) =
     ('\n '\s '\s '\b 'cases 'pattern '= '\o eMetaPrettyPrint(M, T) '\b 'if '\o '\n
     eMetaPrettyPrint(M, COND) '\n
     '\s '\s '\b '. '\o)
     eMetaPrettyPrint(M, CEDL)
  .
  eq eMetaPrettyPrint(M, (none).CaseEqDeclList) = nil .
  
  op eMetaPrettyPrint : Module Condition -> QidList .
  eq eMetaPrettyPrint(M, (COND1:Condition \/ COND2:Condition)) =
     eMetaPrettyPrint(M, COND1:Condition) '\/
     eMetaPrettyPrint(M, COND2:Condition)
  . 

endm --- CIRC-UNIT

***( ===========================================================================
*
* ============================================================================ )

fmod PROOFSTATUS is

  including INT .
  including CONTAINERS .

  sort ProofStatus . --- a proof status is a regular expression over rule labels
  sort ProofTriple .
  sort TripStack .

  subsort ProofTriple < TripStack .
  subsort TripStack < ProofStatus .

  vars R R1 R2 : ProofStatus .
  vars A B : RuleLabel .

  op emptyTS :                     -> TripStack .
  op _;TS;_  : TripStack TripStack -> TripStack
               [assoc id: emptyTS format (d d ni d)] .

  op <_,_,_> : Action Action Bool -> ProofTriple .

  op _|>_     : Action Action -> Action [gather (E e)] .
  op _#_      : Action Action -> Action [gather (E e)] .
  op _!       : Action        -> Action .

  op noAction : -> Action .

  op waiting          : -> ProofStatus .  --- end of a command
  op undo             : -> ProofStatus .  --- performs one step back
  

  op pushProofStack   : -> RuleLabel .  --- save the current proof state
  op popProofStack    : -> RuleLabel .  --- load the current proof state

  op initialize       : -> RuleLabel . --- initialize step
  op addSpeCtxHypo    : -> RuleLabel . --- adds the hypo required for spectxs
  
  op startInduction   : -> RuleLabel .  --- starts a proof by induction
  op normalize        : -> RuleLabel .  --- normalization step
  op eqRed            : -> RuleLabel .  --- equational reduction step
  op ccstep           : -> RuleLabel .  --- circular coinduction step
  op ccstep-eq        : -> RuleLabel .  --- equational circular coinduction exp
  op ccstep-atts      : -> RuleLabel .  --- operational circular coinduction exp
  op cistep           : -> RuleLabel .  --- circular induction step
  op cistep-eq        : -> RuleLabel .  --- equational circular induction exp
  op cistep-atts      : -> RuleLabel .  --- operational circular induction exp
  op simplify         : -> RuleLabel .  --- simlpification step
  op addGoalEq        : -> RuleLabel .  --- equational goal adding
  op generalize       : -> RuleLabel .  --- goal generalization
  op checkCSet        : -> RuleLabel .  --- proof/cobasis checking
  op cases            : -> RuleLabel .  --- "case analysis"
  op checkcond        : -> RuleLabel .

  op reduce           :     -> Action .
  op coinduction      :     -> Action .
  ***( ! deprecated ! ) op coinduction-grlz :     -> Action .
  op induction        :     -> Action .
  op checkCSet        : Nat -> Action [memo] .


  op initAction : -> Action .
  eq initAction = initialize # addSpeCtxHypo .


  eq reduce           = normalize # eqRed .
  eq coinduction      = ((normalize |> eqRed |> checkcond |> cases |> simplify  |> ccstep) !) .
  eq coinduction-grlz = ((normalize |> eqRed |> simplify |> generalize |> checkcond |> cases |> ccstep) !) .
  eq induction        = ((normalize |> eqRed |> simplify |> checkcond |> cistep) !) .
  
  op start : Action -> ProofStatus .
  eq start(noAction) = waiting .
  eq start(ACT:Action) = < ACT:Action , ACT:Action , false > [owise] .
  
  op checkCSetEnd : -> ProofTriple . --- marks the end of checkCSet action
  var I : Int .
  ceq checkCSet(I) = noAction if (I < 0) .
  eq  checkCSet(I) = (reduce |> ccstep) ! [owise] .
  ---eq checkCSet(0) = (reduce !) .
  ---eq checkCSet(I) = (normalize # (eqRed |> ccstep)) # checkCSet(I + (-1)) [owise] .
  
  op hasCheckingCToken : TripStack -> Bool .
  
  eq hasCheckingCToken(TSTK:TripStack ;TS; checkCSetEnd) = true .
  eq hasCheckingCToken(TSTK:TripStack) = false [owise] .

endfm  --- PROOFSTATUS


***( ===========================================================================
*
* ============================================================================ )

mod CIRC-DATABASE-HANDLING is

  including PRE-OUTPUT .
  including PROOFSTATUS .
  ---including META-CIRC-LANG-SIGN .
  including CIRC-UNIT .

  var Atts Atts'        : AttributeSet .
  var Att               : Attr .
  var AS AS' AttS       : AttrSet .
  var B B' B''          : Bool .
  var B-DBG             : Bool .
  var C                 : Constant .
  var CPTD              : EqCondition .
  var DB DB'            : Database .
  var X@Database        : DatabaseClass .
  var DDL               : DerDeclList .
  var COND              : EqCondition .
  var E E'              : Equation .
  var EL                : NsList{Equation} .
  var ES ES''           : EquationSet .
  var N N'              : Int .
  var NSL MNS           : Int .
  var M M' PM           : Module .
  var M-FLAT M-TOP      : Module .
  var MN                : ModuleName .
  var RPS               : NsNeSet{ResultPair?} .
  var O                 : Oid .
  var OD                : OpDecl .
  var ODS ODS' ODS''    : OpDeclSet .
  var PrSt              : ProofStatus .
  var Q Q'              : Qid .
  var QLT QLH           : QidList .
  var QLT1 QLT1'        : QidList .
  var QLT2 QLT3         : QidList .
  var QL QL' QL'' QL''' : QidList .
  var USR-MSG-SCX       : QidList .
  var CSUBST            : <Qid|Subst> .
  var RP RP1 RP2 RP3    : ResultPair? .
  var ME ME'            : ModuleExpression .
  var SRDL              : SimpRlDeclList .
  var Srt Srt' Srt1     : Sort .
  var SS SS1 SS2 SS3    : SortSet .
  var SS-HIDDEN         : SortSet .
  var SCDL              : SpeCtxDeclList .
  var STR               : String .
  var SW SW'            : SwitchStatus .
  var T T' T''          : Term .
  var T1 T2 T3          : Term .
  var T1' T2'           : Term .
  var TL TL' TL''       : TermList .
  var TL1 TL2 TL3 TL4   : TermList .
  var TL-DERS           : TermList .
  var TL-SCXS           : TermList .
  var Ty Ty1 Ty2        : Type .
  var TyTemp            : Type? .  
  var TyL TyL1 TyL2     : TypeList .
  var V V' V1 V2        : Variable .

  sort    CIRCDataBase .
  subsort CIRCDataBase < DatabaseClass .

  op CIRCDB : -> CIRCDataBase .

  sort <Qid|Subst> .
  op none  :                  -> <Qid|Subst> .
  op <_|_> : Qid Substitution -> <Qid|Subst> .

  var CP : CasePair .
  var GED : GrdEqDecl .
  var GEDL : GrdEqDeclList .
  var CL CL' CL'' : CaseList .

  op convGEDL2CPL : GrdEqDeclList -> NsList{CasePair} .
  eq convGEDL2CPL(none) = nsnil-CP .
  ceq convGEDL2CPL(GED GEDL) =
      < T | COND > :CP: convGEDL2CPL(GEDL)
    if (geq T = CL .) := GED
    /\ COND := convCL2COND(CL)
  .

  op convCL2COND : CaseList -> Condition .
  op convCL2COND-if : CaseList -> Condition .
  op convCL2COND-ow : CaseList Condition -> Condition .
  ceq convCL2COND(CL) = COND'
    if COND  := convCL2COND-if(CL)
    /\ COND' := convCL2COND-ow(CL, COND)
  .
  
  eq convCL2COND-if(CL (T [owise])) = convCL2COND-if(CL) .
  eq convCL2COND-if((T [owise]) CL) = convCL2COND-if(CL) .
  eq convCL2COND-if(CL (T [owise]) CL') = convCL2COND-if(CL CL') .
  eq convCL2COND-if(CL CL') = convCL2COND-if(CL) \/ convCL2COND-if(CL') .
  eq convCL2COND-if(T if COND []) = COND .
  
  ceq convCL2COND-ow(CL, COND) = COND \/ 'true.Bool = 'true.Bool
    if hasOwise(CL)
  .
  eq convCL2COND-ow(CL, COND) = COND [owise] .
  
  op hasOwise : CaseList -> Bool .
  eq hasOwise(T [owise]) = true .
  eq hasOwise(CL (T [owise])) = true .
  eq hasOwise((T [owise]) CL') = true .
  eq hasOwise(CL (T [owise]) CL') = true .
  eq hasOwise(CL) = false [owise] .
  
  var ESD : EnumSortDecl .
  var ESDL : EnumSortDeclList .
  var S : Sort .

  op convES2CPL : EnumSortDeclList -> NsList{CasePair} .
  eq convES2CPL(none) = nsnil-CP .
  ceq convES2CPL(ESD ESDL) = 
      < T | COND > :CP: convES2CPL(ESDL)
    if enum S is QL . := ESD
    /\ T := qid("V:" + string(S)) /\ true
    /\ COND := convSQL2COND(S, QL)
  .
  
  var CED : CaseEqDecl .
  var CEDL : CaseEqDeclList .
  
  op convCEDL2CPL : CaseEqDeclList -> NsList{CasePair} .
  eq convCEDL2CPL(none) = nsnil-CP .
  ceq convCEDL2CPL(CED CEDL) = 
      < T | COND > :CP: convCEDL2CPL(CEDL)
    if (cases pattern = T if COND .) := CED
  .

  op convSQL2COND : Sort QidList -> Condition .
  ceq convSQL2COND(S, QL QL') = convSQL2COND(S, QL) \/ convSQL2COND(S, QL')
    if QL =/= nil
    /\ QL' =/= nil
  .
  eq convSQL2COND(S, Q) =
     (qid("V:" + string(S)) = qid(string(Q) + "." + string(S)))
  .

  op topModule     :_ : Module              -> Attribute [format (gni o d d)] .
  op internModule  :_ : Module              -> Attribute [format (gni o d d)] .
  op flatModule    :_ : Module              -> Attribute [format (gni o d d)] .
  
  op log           :_ : NsList{LogUple}     -> Attribute [format (gni o d d)] .

  op proofStatus   :_ : ProofStatus         -> Attribute [format (gni o d d)] .
  op ctors         :_ : OpDeclSet           -> Attribute [format (gni o d d)] .
  op indUples      :_ : NsList{InductionUple} -> Attribute [format (gni o d d)] .
  op uniqueNat     :_ : Nat                 -> Attribute [format (gni o d d)] .
  op ssorts        :_ : SubsortDeclSet      -> Attribute [format (gni o d d)] .
  op derivatives   :_ : TermList            -> Attribute [format (gni o d d)] .
  op proofStack    :_ : Stack{ProofStateUple} -> Attribute [format (gni o d d)] .
  
  op debug         :_ : Bool                -> Attribute [format (gni o d d)] .
  
  
  op autoAddConj   :_ : SwitchStatus        -> Attribute [format (gni o d d)] .
  op autoContext   :_ : SwitchStatus        -> Attribute [format (gni o d d)] .
  op allContexts   :_ : SwitchStatus        -> Attribute [format (gni o d d)] .
  op grlz          :_ : SwitchStatus        -> Attribute [format (gni o d d)] .
  
  op casesPairs    :_ : NsList{CasePair}    -> Attribute [format (gni o d d)] .
  op hypCounter    :_ : Nat                 -> Attribute [format (gni o d d)] .
  op showDetails   :_ : SwitchStatus        -> Attribute [format (gni o d d)] .
  op showProvProp  :_ : SwitchStatus        -> Attribute [format (gni o d d)] .
  op simplifyRules :_ : SimpRlDeclList      -> Attribute [format (gni o d d)] .
  op spectxs       :_ : TermList            -> Attribute [format (gni o d d)] .
  op noSubgoals    :_ : Int                 -> Attribute [format (gni o d d)] .
  op maxNoSteps    :_ : Int                 -> Attribute [format (gni o d d)] .
  op stopMessage   :_ : QidList             -> Attribute [format (gni o d d)] .

  eq procModule2(T, 'theory_is_endtheory[T', T''], DB) =
     procModule3(T, T', T'', addImports((including 'BOOL .), emptyCTheory), DB)
  .
  eq procModule2('theory_is_endtheory[T, T'], DB) =
     procModule3(T, T', addImports((including 'BOOL .), emptyCTheory), DB)
  .
    
  
    
  sort LogUple NsList{LogUple} .
  subsort LogUple < NsList{LogUple} .

  op LU<proofSeparator> : -> LogUple .
  op LU<disjSeparator> : -> LogUple .
  op LU<_,_,_> : RuleLabel Module NsList{NsList{Goal}} -> LogUple .
  op LU<_,_,_,_> : RuleLabel Module NsList{NsList{Goal}} NsList{NsSet{Variable}}
                   -> LogUple .
  
  op nsnil-LU : -> NsList{LogUple} .
  op _:LU:_ : NsList{LogUple} NsList{LogUple} ->
              NsList{LogUple} [assoc id: nsnil-LU format (d d ni d)] .

  --- Retruns true if the first element is the proof separator
  op hasTopProofSeparator : NsList{LogUple} -> Bool .
  eq hasTopProofSeparator(LU<proofSeparator> :LU: LUL:NsList{LogUple}) = true .
  eq hasTopProofSeparator(LUL:NsList{LogUple}) = false [owise] .
  
  --- gets the set of equational goals that had been coexpanded or simplified
  op getCSet : NsList{LogUple} -> NsList{Goal} .
  eq getCSet(nsnil-LU) = nsnil-G .
  ceq getCSet(LU< ccstep-eq , M-LOG , GLL > :LU: LUL) =
    eq2goal(E) :G: getCSet(LUL)
  if E := getEqs(M-LOG)
  .
  ceq getCSet(LU< simplify , M-LOG , GLL > :LU: LUL) =
    (eq2goal(E) :G: GLL :G: getCSet(LUL))
  if E := getEqs(M-LOG)
  .
  eq getCSet(LU :LU: LUL) = getCSet(LUL) [owise] .
  
  op getLemmas : Module -> NsList{Equation} .
  ceq getLemmas(M) = getLemmas(EL)
    if EL := convEqSet2EqList(getEqs(M))
  .
  
  ---
  op getLemmas : NsList{Equation} -> NsList{Equation} .
  eq getLemmas(nsnil-E) = nsnil-E .
  eq getLemmas((eq T = T' [label('lemma)] .) :E: EL) =
    (eq T = T' [label('lemma)] .) :E: getLemmas(EL)
  .
  eq getLemmas(E :E: EL) = getLemmas(EL) [owise] .


  op convDDL2TL : Module DerDeclList          -> TermList .
  op convDDL2TL : Module DerDeclList TermList -> TermList .
 
  eq convDDL2TL(M, DDL) = convDDL2TL(M, DDL, empty) .
  eq convDDL2TL(M, none, TL) = TL .
  eq convDDL2TL(M, (der TL' .) DDL, TL) =
       convDDL2TL(M, DDL, (TL, TL')) .

  --- Searches in depth for all the derivatives starting from the provided
  --- theory and returns them as a term list.
  op calcDerivatives : ModuleExpression Database -> TermList .
  eq calcDerivatives(ME, DB) =
     convDDL2TL(getFlatModule(ME, DB), getDers(getFlatCth(ME, DB)))
  .

  op convSCDL2TL : Module SpeCtxDeclList          -> TermList .
  op convSCDL2TL : Module SpeCtxDeclList TermList -> TermList .

  eq convSCDL2TL(M, SCDL) = convSCDL2TL(M, SCDL, empty) .
  eq convSCDL2TL(M, none, TL) = TL .
  eq convSCDL2TL(M, (scx TL' .) SCDL, TL) =
       convSCDL2TL(M, SCDL, (TL, TL')) .

  op convRL2QL : RuleLabel -> QidList .
  eq convRL2QL(normalize) = 'Normalize .
  eq convRL2QL(eqRed) = 'Reduce .
  eq convRL2QL(ccstep-eq) = 'Derive .
  eq convRL2QL(cistep) = 'Derive-ind .
  eq convRL2QL(simplify) = 'Simplify .
  eq convRL2QL(ccstep-atts) = 'Derive-atts .
  eq convRL2QL(addGoalEq) = 'AddIniGoal .
  eq convRL2QL(cases) = 'Cases .
  eq convRL2QL(generalize) = 'Generalize .
  eq convRL2QL(checkcond) = 'CheckCond .
    
  var theta? theta'? : Substitution? .
  
  --- Converts a goal conjunction into a list of equations .
  op convDisjNF2goals : Substitution? EqCondition AttrSet
                        EqCondition -> NsList{NsList{Goal}} .
  ceq convDisjNF2goals(theta?, COND, AS, (T = T')) =
        convEL2GL(ceq '#*_*#[T1] = '#*_*#[T1'] if COND [AS] .)
    if T1  := applySubst(T, theta?)
    /\ T1' := applySubst(T', theta?)
  .

  var CGD1 CGD2 : EqCondition .
  ceq convDisjNF2goals(theta?, COND, AS, (CGD1 \/ CGD2)) =
     convDisjNF2goals(theta?, COND, AS, CGD1) :GL:
     convDisjNF2goals(theta?, COND, AS, CGD2)
     if CGD1 =/= nil
     /\ CGD2 =/= nil
  .
  ceq convDisjNF2goals(theta?, COND, AS, (CGD1 /\ CGD2)) =
     convDisjNF2goals(theta?, COND, AS, CGD1) :G:
     convDisjNF2goals(theta?, COND, AS, CGD2)
     if CGD1 =/= nil
     /\ CGD2 =/= nil
  .

  --- Luta's special contexts version
  op genSpeCtxHypo : TermList -> EquationSet .
  eq genSpeCtxHypo(empty) = none .
  ceq genSpeCtxHypo((T, TL)) =
      (ceq '#*_*#[T < V1 >] = '#*_*#[T < V2 >]
         if '#*_*#[ V2 ] := '#*_*#[ V1 ]
         /\ 'notEqual[V1, V2] = 'true.Bool [none]
       .)
      genSpeCtxHypo(TL)
    if V1 := qid(string('S1-CIRCV:) + getStarTypeAsString(T))
    /\ V2 := qid(string('S2-CIRCV:) + getStarTypeAsString(T))
  .

  --- Returns the type of the star variable as a string
  op getStarTypeAsString : TermList -> String .

  eq getStarTypeAsString(C) = "" . 
  ceq getStarTypeAsString(V) = string(getType(V)) if getName(V) = '* .
  eq  getStarTypeAsString(V) = "" [owise] .
  eq  getStarTypeAsString(Q[TL]) = getStarTypeAsString(TL) .
  eq  getStarTypeAsString(empty) = "" .
  ceq getStarTypeAsString((T', TL)) =
      getStarTypeAsString(T') + getStarTypeAsString(TL)
    if TL =/= empty
  .
  
  op addNotEqual : TermList Module -> Module .
  eq addNotEqual(empty, M) = M .
  ceq addNotEqual((T, TL), M) =
      addOps((op 'notEqual : Ty Ty -> 'Bool [none] .),
        addEqs(
          (
            (eq 'notEqual[V1,V1] = 'false.Bool [none] .)
            (eq 'notEqual[V1,V2] = 'true.Bool [owise] .)
          ),
          addNotEqual(TL, M)
        )
      )
    if STR := getStarTypeAsString(T)
    /\ Ty := qid(STR) /\ true
    /\ V1 := qid(string('S1-CIRCV:) + STR)
    /\ V2 := qid(string('S2-CIRCV:) + STR)
  .
  
  var SR   : SimpRlDecl .
  var U U' : [Term] .
  var COND' : EqCondition .
  
--- getVarsIndFrozen
  op isIndFrozen : Equation NsList{InductionUple} -> Bool .
  eq isIndFrozen(E, IUL) = getVarsIndFrozen(E, IUL) == nsempty-V .
  eq isIndFrozen(E, IUL) = true [owise] .


  sort SimpRlDeclSubstUple . --- none none
  op SRDS<_`,_> : SimpRlDecl Substitution -> SimpRlDeclSubstUple .
  op noSimpRule : -> SimpRlDecl .
  op findSimplificationRule : Module SimpRlDeclList Term Term -> SimpRlDeclSubstUple .
  eq findSimplificationRule(M, none, T, T') = SRDS< noSimpRule , none > .
  eq findSimplificationRule(M, SR SRDL, T, T') =
     findSimplificationRule(M, SRDL, T, T')
    [ ---print SR "\n" T "\n" T' "\n\n"
     owise]
  .

  ceq findSimplificationRule(M, SR SRDL , T, T') = SRDS< SR , theta? >
    if (csrl (QSRLN:Qid) : (U = U') => CPTD if COND' .) := SR
    /\ theta? := metaMatchPairCond(
                   M, '#*_*#[U], '#*_*#[U'], '#*_*#[removeCoFreezing(T)], '#*_*#[removeCoFreezing(T')], coFreezeCond(COND')
                 )
    /\ theta? :: Substitution
    /\ theta? =/= none
  .

  var M-CTH-FLAT : Module .
  
  ***( ! deprecated ! ) crl [parseCTheory] :
    < O : X@Database |
      db            : DB,
      default       : ME,
      input         : ('cth_is_endcth[T, T']),
      output        : nil,
      topModule     : M-TOP:Module,
      internModule  : M-INTERN:Module,
      flatModule    : M-FLAT:Module,
      Atts
    >
    =>
    < O : X@Database |
      db            : insertFlatModule(ME', getFlatModule(ME', DB'), DB'),
      default       : ME',
      input         : 'initialize`..@Command@,
      output        : ('\n '\b
                       '.......................................... '\n
                       '__________________________________________ '\n '\n '\o
                        QL'),
      topModule     : if (B1:Bool) then M-TOP':[Module] else noModule fi,
      internModule  : if (B2:Bool) then M-INTERN':[Module] else noModule fi,
      flatModule    : if (B3:Bool) then M-FLAT':[Module] else noModule fi,
      Atts
    >
    if ME'             := parseHeader(T)
    /\ DB'             := fillInternal(ME', procModule('theory_is_endtheory[T, T'], DB))
    /\ QL'             := ('\g 'Introduced '\r 'ctheory '\o header2Qid(ME') '\n '\n)
    /\ M-TOP':[Module] := getTopModule(ME', DB')
    /\ M-INTERN':[Module] := getInternalModule(ME', DB')
    /\ M-FLAT':[Module] := getFlatModule(ME', DB')
    /\ B1:Bool := M-TOP':[Module] :: Module
    /\ B2:Bool := M-INTERN':[Module] :: Module
    /\ B3:Bool := M-FLAT':[Module] :: Module
    ---[print B1:Bool B2:Bool B3:Bool]
  .

  var M-TOP' : Module .
  
  crl [parseTheory] :
    < O : X@Database |
      db           : DB,
      default      : ME,
      input        : ('theory_is_endtheory[T, T']),
      output       : nil,
      proofStatus  : waiting,
      topModule    : M-TOP:Module,
      internModule : M-INTERN:Module,
      flatModule   : M-FLAT:Module,
      Atts
    >
    =>
    < O : X@Database |
      db           : DB',
      default      : ME',
      input        : nilTermList,
      output       : (QL'),
      proofStatus  : < initAction , initAction , false >,
      topModule    : if (B1:Bool) then M-TOP':[Module] else noModule fi,
      internModule : if (B2:Bool) then M-INTERN':[Module] else noModule fi,
      flatModule   : if (B3:Bool) then M-FLAT':[Module] else noModule fi,
      Atts
    >
    if ME' := parseHeader(T)
    /\ DB' := fillInternal(ME', procModule('theory_is_endtheory[T, T'], DB)) 
    /\ QL' := ('\g 'Introduced 'theory '\o header2Qid(ME') '\n '\n)
    /\ M-TOP':[Module] := getTopModule(ME', DB')
    /\ M-INTERN':[Module] := getInternalModule(ME', DB')
    /\ M-FLAT':[Module] := getFlatModule(ME', DB')
    /\ B1:Bool := M-TOP':[Module] :: Module
    /\ B2:Bool := M-INTERN':[Module] :: Module
    /\ B3:Bool := M-FLAT':[Module] :: Module
  .
  
  var GEDL' GEDL'' : GrdEqDeclList .
  var DB'' : Database .


  rl [parseCTheory2] :
    < O : X@Database |
      proofStatus   : waiting,
      input         : ('ctheory_is_endctheory[T, T']),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus   : waiting,
      input         : ('cth_is_endcth[T, T']),
      Atts
    >
  .
  
  
  crl [parseCommand--initialize`.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : TL,
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < initAction , initAction , false >,
      input       : nilTermList,
      output      : ('\n '\b 'Initializing '... '\o '\n),
      Atts
    >
    if (TL == 'initialize`..@Command@) or (TL == 'init`..@Command@)
  .
    

  var M-WORK M-WORK'    : Module .
  var CNJL              : NsList{Goal} .
  var GL                : NsList{Goal} .


  ***(
  op addInfoAddGoal : Module -> Module .
  eq addInfoAddGoal(M) =
     addOps(
       (op '@wrapper : 'Universal -> '@@@ [poly(1)] .),
       addSorts('@@@, M)
     )
  .
  
  /\ M''        := addInfoGeqs(M')
  /\ RP         := metaParse(M'', '@wrapper '`( QL '`), '@@@)
  /\ T-WRAPPED  := getUnwrappedTerm(RP)
  )
  crl [parseCommand--add`goal_=_.] :
    < O : X@Database |
      proofStatus : waiting,
      proofStack  : PSS,
      input       : ('add`goal_=_.['bubble[T1], 'bubble[T2]]),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < addGoalEq, addGoalEq, false >,
      proofStack  : setTopGLL(eq2goal(ceq T = T' if nil [none] .) :G: GL, PSS),
      input       : nilTermList,
      Atts
    >
    if M-WORK := getTopM(PSS)
    /\ GL   := getTopGLL(PSS)
    /\ QLT1 := downTerm(T1, 'nil)
    /\ QLT2 := downTerm(T2, 'nil)
    /\ RP1  := parseInModule(M-WORK, QLT1)
    /\ RP2  := parseInModule(M-WORK, QLT2)
    /\ RP1  :: ResultPair
    /\ RP2  :: ResultPair
    /\ T    := getUnwrappedTerm(RP1)
    /\ T'   := getUnwrappedTerm(RP2)
  .
  
  crl [errorCommand--add`goal_=_.] :
    < O : X@Database |
      proofStatus : waiting,
      proofStack  : PSS,
      input       : ('add`goal_=_.['bubble[T1], 'bubble[T2]]),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      proofStack  : PSS,
      input       : nilTermList,
      output      : QL,
      Atts
    >
    if M-WORK := getTopM(PSS)
    /\ QLT1 := downTerm(T1, 'nil)
    /\ QLT2 := downTerm(T2, 'nil)
    /\ RP1  := parseInModule(M-WORK, QLT1)
    /\ RP2  := parseInModule(M-WORK, QLT2)
    /\ ((not RP1 :: ResultPair) or (not RP2 :: ResultPair)) 
    /\ QL   := if (not RP1 :: ResultPair)
                 then '\r 'Warning: '\o printSyntaxError(RP1, QLT1) '\n
                      '\r 'Error: '\o 'no 'parse 'for QLT1 '\n
                 else nil
               fi
               if (not RP2 :: ResultPair)
                 then '\r 'Warning: '\o printSyntaxError(RP2, QLT2) '\n
                      '\r 'Error: '\o 'no 'parse 'for QLT2 '\n
                 else nil
               fi
  .

  crl [parseCommand--add`cgoal_=_if_.] :
    < O : X@Database |
      db          : DB,
      default     : ME,
      proofStatus : waiting,
      proofStack  : PSS,
      input       : ('add`cgoal_=_if_.['bubble[T1], 'bubble[T2], T3]),
      Atts
    >
    =>
    < O : X@Database |
      db          : DB,
      default     : ME,
      proofStatus : < addGoalEq, addGoalEq, false >,
      proofStack  : setTopGLL(eq2goal(ceq T = T' if COND [none] .) :G: GL, PSS),
      input       : nilTermList,
      Atts
    >
    if M-WORK := getTopM(PSS)
    /\ GL     := getTopGLL(PSS)
    /\ COND := parseCondition(T3, ME, DB, M-WORK) 
    /\ COND :: EqCondition
    /\ QLT1 := downTerm(T1, 'nil)
    /\ QLT2 := downTerm(T2, 'nil)
    /\ RP1  := parseInModule(M-WORK, QLT1)
    /\ RP2  := parseInModule(M-WORK, QLT2)
    /\ RP1  :: ResultPair
    /\ RP2  :: ResultPair
    /\ T    := getUnwrappedTerm(RP1)
    /\ T'   := getUnwrappedTerm(RP2)
  .
  
  crl [errorCommand--add`cgoal_=_if_.] :
    < O : X@Database |
      db          : DB,
      default     : ME,
      proofStatus : waiting,
      proofStack  : PSS,
      input       : ('add`cgoal_=_if_.['bubble[T1], 'bubble[T2], T3]),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      db          : DB,
      default     : ME,
      proofStatus : waiting,
      proofStack  : PSS,
      input       : nilTermList,
      output      : nil,
      Atts
    >
    if M-WORK := getTopM(PSS)
    /\ COND := parseCondition(T3, ME, DB, M-WORK) 
    /\ COND :: EqCondition
    /\ QLT1 := downTerm(T1, 'nil)
    /\ QLT2 := downTerm(T2, 'nil)
    /\ RP1  := parseInModule(M-WORK, QLT1)
    /\ RP2  := parseInModule(M-WORK, QLT2)
    /\ ((not RP1 :: ResultPair) or (not RP2 :: ResultPair))
    /\ QL := if (not RP1 :: ResultPair)
                 then '\r 'Warning: '\o printSyntaxError(RP1, QLT1) '\n
                      '\r 'Error: '\o 'no 'parse 'for QLT1 '\n
                 else nil
             fi
             if (not RP2 :: ResultPair)
               then '\r 'Warning: '\o printSyntaxError(RP2, QLT2) '\n
                    '\r 'Error: '\o 'no 'parse 'for QLT2 '\n
               else nil
             fi
  .
  
  crl [errorCommand--add`cgoal_=_if_.] :
    < O : X@Database |
      db          : DB,
      default     : ME,
      proofStatus : waiting,
      proofStack  : PSS,
      input       : ('add`cgoal_=_if_.['bubble[T1], 'bubble[T2], T3]),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      db          : DB,
      default     : ME,
      proofStatus : waiting,
      proofStack  : PSS,
      input       : nilTermList,
      output      : QL,
      Atts
    >
    if M-WORK := getTopM(PSS)
    /\ COND?:[EqCondition] := parseCondition(T3, ME, DB, M-WORK) 
    /\ not COND?:[EqCondition] :: EqCondition
    /\ errorCond(QL') := COND?:[EqCondition] /\ true = true 
    /\ QL := ('\r 'Error: 'No 'parse 'for '\o QL' '\n)
  .
  
  op parseCondition : Term Qid Database Module -> [EqCondition] .
  
  ceq parseCondition('bubble[T], Q, DB, M-WORK) = COND
    if M := addInfoConds(M-WORK)
    /\ QL  := downQidList(T)
    /\ RP  := metaParse(M, '`( QL '`), '@Condition@)
    /\ T' := getTerm(RP)
    --- taken from full-maude - parseCond needs the VDS
    /\ < DT:Default{Term} ; VDS:OpDeclSet ; U:Module > := getTermModule(Q, DB) 
    /\ COND := parseCond(T', VDS:OpDeclSet)
  .
  
  op errorCond : QidList -> [EqCondition] .
  ceq parseCondition('bubble[T], Q, DB, M-WORK) = errorCond(QL)
    if M := addInfoConds(M-WORK)
    /\ QL := downQidList(T)
    [owise]
  .

  var GLL GLL' : NsList{NsList{Goal}} .

  --- Used for proving some properties for a given binary operator.
  --- E.g. : goal: (add goal (op _+_ : Stream Stream -> Stream [comm] .) .)
  --- Handled attributes:
  --- [assoc] [comm] [id: neuEl] [right id: neuEl] [left id: neuEl] [idem].
  crl [parseCommand--add`goal_.] :
    < O : X@Database |
      proofStatus : waiting,
      proofStack  : PSS,
      input       : ('add`goal_.['op_:_->_`[_`].['token[T], T1, T2, T3]]),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      proofStack  : setTopGLL(op2goal(OD) :G: GL,
                              setTopCNJL(op2goal(OD) :G: CNJL, PSS)),
      input       : nilTermList,
      output      : ('\n '\g 'Goal 'added: '\o
                     'op QLT ': parseTypeList(T1) '-> parseType(T2) '\s
                     '`[ attrSet2QidList(AS) '`] '\s '.
                     '\n '\n),
      Atts
    >
    if M-WORK := getTopM(PSS)
    /\ GL     := getTopGLL(PSS)
    /\ CNJL   := getTopCNJL(PSS)
    /\ QLT   := downQid(T)
    /\ N:Nat := size(parseTypeList(T1))
    /\ AS    := parseAttrCirc(T3, M-WORK, N:Nat)
    /\ OD    := (op downQid(T) : parseTypeList(T1) -> parseType(T2) [AS] .)
  .

  crl [parseCommand--focus_.] :
    < O : X@Database |
      proofStatus : waiting,
      proofStack  : PSS,
      input       : ('focus_.['token[T]]),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      proofStack  : setTopGLL(setFirst(GL, N), PSS),
      input       : ('show`goals`..@Command@),
      Atts
    >
    if GL := getTopGLL(PSS)
    /\ Q := downTerm(T, 'nil)
    /\ N := downTerm(getTerm(metaParse(upModule('INT, true), Q, 'Int)), 0)
    /\ N :: Int
  .
  
  crl [parseCommand--set`max`no`steps_.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('set`max`no`steps_.['token[T]]),
      proofStack  : PSS,
      maxNoSteps  : MNS,
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      input       : nilTermList,
      proofStack  : setTopNSL(N, PSS),
      maxNoSteps  : N,
      output      : ('\n 'The 'maximum 'number 'of 'proving 'steps
                     'was 'set 'to '\g qid(string(N, 10)) '. '\n '\g),
      Atts
    >
    if Q := downTerm(T, 'nil)
    /\ N := downTerm(getTerm(metaParse(upModule('INT, true), Q, 'Int)), 0)
    /\ N :: Int
  .
  
  rl [parseCommand--show`max`no`steps`.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('show`max`no`steps`..@Command@),
      output      : nil,
      proofStack  : PSS,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      input       : nilTermList,
      output      : ('\n 'The 'number 'of 'proving 'steps 'allowed 'is
                     '\g qid(string(getTopNSL(PSS), 10)) '\g '. '\n ),
      proofStack  : PSS,
      Atts
    >
  .
  
  var IUL IUL' : NsList{InductionUple} .

  crl [parseCommand--show`goals`.] :
    < O : X@Database |
      proofStatus : PrSt,
      proofStack  : PSS,
      input       : ('show`goals`..@Command@),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      proofStack  : PSS,
      input       : nilTermList,
      output      : ('\n myMetaPrettyPrint(M-WORK, GLL')),
      Atts
    >
    if M-WORK := getTopM(PSS)
    /\ GLL' := prettyGoal(getTopGLL(PSS), getTopIUL(PSS))
  .
  
  var QL-COBASIS : QidList .
  var QL-CAND : QidList .
  var TL-COBASIS : TermList .
  var TL-CAND : TermList .
  var RPS-CAND : NsNeSet{ResultPair?} .

  crl [parseCommand--check`scx_using_.] :
    < O : X@Database |
      db            : DB,
      default       : ME,
      proofStatus   : waiting,
      proofStack    : PSS,
      input         : ('check`scx_using_.['bubble[T1], 'bubble[T2]]),
      output        : nil,
      autoContext   : SW,
      spectxs       : TL-SCXS,
      casesPairs    : CPL:NsList{CasePair},
      Atts
    >
    =>
    < O : X@Database |
      db            : DB,
      default       : ME,
      proofStatus   : < initialize , initialize , false >,
      proofStack    : PSS,
      input         : nilTermList,
      output        : QL,
      autoContext   : SW,
      spectxs       : TL-SCXS,
      casesPairs    : CPL:NsList{CasePair},
      Atts
    >
    if M-WORK     := getTopM(PSS)
    /\ TL-DERS    := calcDerivatives(ME, DB)
    /\ QL-CAND    := downTerm(T1, 'nil)
    /\ RPS-CAND   := parseForSetOfTermsInModule(M-WORK, QL-CAND)
    /\ RPS-CAND   :: NsNeSet{ResultPair}
    /\ TL-CAND    := getUnwrappedTermList(RPS-CAND)
    /\ QL-COBASIS := downTerm(T2, 'nil)
    /\ RPS        := parseForSetOfTermsInModule(M-WORK, QL-COBASIS)
    /\ RPS        :: NsNeSet{ResultPair}
    /\ TL-COBASIS := getUnwrappedTermList(RPS)
    /\ SS-HIDDEN  := getSortsHidden(TL-DERS)
    /\ BOO:Bool   := checkScx(TL-CAND, TL-SCXS, TL-COBASIS, TL-DERS,
                              SS-HIDDEN, CPL:NsList{CasePair},
                              addCts(v2c(getVars((TL-CAND, TL-SCXS))), M-WORK)
                              )
    /\ QL         := (QL-CAND '\s '\g
                      if BOO:Bool
                        then 'is 'a 'special 'context
                        else 'could 'not 'be 'checked
                      fi '\o)
  .

  crl [parseCommand--add`lemma_=_.] :
    < O : X@Database |
      proofStatus : PrSt,
      proofStack  : PSS,
      input       : ('add`lemma_=_.['bubble[T1], 'bubble[T2]]),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      proofStack  : setTopM(M-WORK', PSS),
      input       : nilTermList,
      output      : QL',
      Atts
    >
    if M-WORK := getTopM(PSS)
    /\ QLT1 := downTerm(T1, 'nil)
    /\ QLT2 := downTerm(T2, 'nil)
    /\ RP1  := parseInModule(M-WORK, QLT1)
    /\ RP2  := parseInModule(M-WORK, QLT2)
    /\ RP1  :: ResultPair
    /\ RP2  :: ResultPair
    /\ T    := getUnwrappedTerm(RP1)
    /\ T'   := getUnwrappedTerm(RP2)
    /\ E    := (eq T = T' [label('lemma)] .)
    /\ M-WORK' := addEqs(E, M-WORK)
    /\ QL'  := '\b 'Lemma '\s '\o
               myOneMetaPrettyPrint(M-WORK, E) '\s '\b 'added. '\o '\n
  .

  var PSS : Stack{ProofStateUple} .
  
  rl [parseCommand--save`proof`state`.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('save`proof`state`..@Command@),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < pushProofStack , pushProofStack , false >,
      input       : nilTermList,
      Atts
    >
  .
  
  rl [parseCommand--undo`.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('undo`..@Command@),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : undo,
      input       : nilTermList,
      Atts
    >
  .
  
  crl [parseCommand--check`proof`.] :
    < O : X@Database |
      default     : MN,
      db          : DB,
      proofStatus : waiting,
      proofStack  : PSS,
      input       : ('check`proof`..@Command@),
      spectxs     : TL'',
      noSubgoals  : I-NO-SUBGOALS:Int,
      maxNoSteps  : MNS,
      Atts
    >
    =>
    < O : X@Database |
      default     : MN,
      db          : DB,
      proofStatus : (< checkCSet , checkCSet , false > ;TS; checkCSetEnd),
      proofStack  : setTopNSL(MNS, setTopM(M-WORK', PSS)),
      input       : nilTermList,
      spectxs     : TL'',
      noSubgoals  : 0,
      maxNoSteps  : MNS,
      Atts
    >
    if true = true
    /\ M-WORK  := getTopM(PSS)
    /\ TL      := calcDerivatives(MN, DB)
    /\ M       := getFlatModule(MN, DB)
    /\ M'      := addNotEqual(TL, addCoFreezingSorts(M))
    /\ ES'     := genSpeCtxHypo(TL'')
    /\ ES''    := convEqList2EqSet(getLemmas(M-WORK))
    /\ M-WORK' := addEqs((ES' ES''), M')
  .
 
  rl [parseCommand--generalize`.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('generalize`..@Command@),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < generalize , generalize , false >,
      input       : nilTermList,
      Atts
    >
  .
    
  var ES' : EquationSet .
  var CNJL' : NsList{Goal} .
  var EL' : NsList{Equation} .
  var M-WORK'' : Module .
  var TStk : TripStack .
  var VSL VSL' : NsList{NsSet{Variable}} .
  var LU                          : LogUple .
  var LUL LUL'                    : NsList{LogUple} .
  var ISS ISS'                    : NsSet{IndSource} .
  var M-LOG M-LOG' M-PRINT M-BASE : Module .
  var RL                          : RuleLabel .
  var A A' : Action .
  
  crl [pushProofStack] :
    < O : X@Database |
      proofStatus : (< pushProofStack , pushProofStack , false > ;TS; TStk),
      maxNoSteps  : MNS,
      proofStack  : PSS,
      log         : LUL,
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < addSpeCtxHypo , addSpeCtxHypo , false >,
      maxNoSteps  : MNS,
      proofStack  : (PS< user, nsnil-G, nsnil-G, noModule, nsempty-V, nsnil-IU, nsempty-IS, noAction, MNS > ;PS; PSS),
      log         : (LU< pushProofStack , noModule , nsnil-G > :LU: LUL),
      output      : QL',
      Atts
    >
    if QL' := ('\g 'Proof 'state 'saved. '\o '\n)
  .

  var NSL' : Int .
  var GL' : NsList{Goal} .
  crl [undo-pushProofStack] :
    < O : X@Database |
      proofStatus : undo,
      proofStack  : ---(PS< user, CNJL', GL', M-WORK', VSL', IUL', A', NSL' > ;PS; PSS)
                    PSS,
      log         : (LU< pushProofStack , noModule , nsnil-G > :LU: LUL),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      proofStack  : pop(PSS),
      log         : (LUL),
      Atts
    >
    if getTopCO(PSS) == user
  .

  crl [popProofStack] :
    < O : X@Database |
      db          : DB,
      default     : MN,
      proofStatus : (< popProofStack , popProofStack , false > ;TS; TStk),
      proofStack  : (PS< user, CNJL', GL', M-WORK', VSL', IUL', ISS', A', NSL' > ;PS; PSS), ***TODO-STACK
      output      : nil,
      log         : LUL,
      Atts
    >
    =>
    < O : X@Database |
      db          : DB,
      default     : MN,
      proofStatus : waiting,
      proofStack  : setTopM(M-WORK'', PSS),
      output      : QL',
      log         : (LU< popProofStack , noModule , nsnil-G > :LU: LUL),
      Atts
    >
    if M-WORK'' := calcModuleUnion(getTopM(PSS), getFlatModule(MN, DB), MN)
    /\ QL'      := ('\g 'Proof 'state 'loaded. '\o '\n)
  .

  rl [undo-popProofStack] :
    < O : X@Database |
      proofStatus : undo,
      log         : (LU< popProofStack , noModule , nsnil-G > :LU: LUL), 
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      log         : (LU< popProofStack , noModule , nsnil-G > :LU: LUL),
      output      : ('\g 'Cannot 'undo 'a 'state 'rewinding '\o '\n),
      Atts
    >
  .
  
  rl [undo-proofSucceeded] :
    < O : X@Database |
      proofStatus : undo,
      log         : (LU<proofSeparator> :LU: LUL), 
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      log         : (LU<proofSeparator> :LU: LUL),
      output      : ('\g 'Cannot 'undo 'after 'a 'successful 'proof '\o '\n),
      Atts
    >
  .

  crl [parseCommand--show`proof`.] :
    < O : X@Database |
      db            : DB,
      default       : MN,
      log           : LUL,
      proofStack    : PSS,
      simplifyRules : SRDL,
      input         : ('show`proof`..@Command@),
      output        : QL,
      Atts
    >
    =>
    < O : X@Database |
      db            : DB,
      default       : MN,
      log           : LUL,
      proofStack    : PSS,
      simplifyRules : SRDL,
      input         : nilTermList,
      output        : (showProof(LUL, M-PRINT, SRDL, getTopIUL(PSS)) QL),
      Atts
    >
    if TL-DERS   := calcDerivatives(MN, DB)
    ---M-WORK    := getTopM(PSS)
    /\ M-BASE    := getFlatModule(MN, DB)
    /\ M         := calcPrintingModule(MN, M-BASE, LUL)
    /\ M-PRINT   := addCoFreezingSorts(M)
    /\ SS-HIDDEN := getSortsHidden(TL-DERS)
  .

  crl [parseCommand--show`last`proof`.] :
    < O : X@Database |
      db            : DB,
      default       : MN,
      log           : LUL,
      proofStack    : PSS,
      simplifyRules : SRDL,
      input         : ('show`last`proof`..@Command@),
      output        : QL,
      Atts
    >
    =>
    < O : X@Database |
      db            : DB,
      default       : MN,
      log           : LUL,
      proofStack    : PSS,
      simplifyRules : SRDL,
      input         : nilTermList,
      output        : (showProof(LUL', M-PRINT, SRDL, getTopIUL(PSS)) QL),
      Atts
    >
    if TL-DERS   := calcDerivatives(MN, DB)
    /\ M-BASE    := getFlatModule(MN, DB)
    /\ M         := calcPrintingModule(MN, M-BASE, LUL)
    /\ M-PRINT   := addCoFreezingSorts(M)
    /\ LUL'      := lastProof(LUL)
    /\ SS-HIDDEN := getSortsHidden(TL-DERS)
  .
  
  
  rl [parseCommand--clear`log`.] :
    < O : X@Database |
      input         : ('clear`log`..@Command@),
      output        : nil,
      log           : LUL,
      Atts
    >
    =>
    < O : X@Database |
      input         : nilTermList,
      output        : ('\g 'The 'log 'is 'empty. '\o '\n),
      log           : LU<proofSeparator>,
      Atts
    >
  .
  
  ------------------------------------------------------------------------------
  -------------------------------- PACO ! -------------------------------------
  ------------------------------------------------------------------------------
  eq eMetaPrettyPrint(M, C:Condition) = 'nil [owise] .
  ------------------------------------------------------------------------------
  -------------------------------- PACO ! --------------------------------------
  ------------------------------------------------------------------------------

  --- Calculates the module used for printing the proof,
  --- as the union of all log modules.
  op calcPrintingModule : Header Module NsList{LogUple} -> Module .
  eq calcPrintingModule(MN, M-BASE, nsnil-LU) = M-BASE .
  ceq calcPrintingModule(MN, M-BASE, (LU< RL, M-LOG, GLL > :LU: LUL)) =
      calcModuleUnion'(
        M-LOG,
        calcPrintingModule(MN, M-BASE, LUL),
        MN
      )
    if (RL =/= eqRed and RL =/= normalize and RL =/= ccstep-atts and
        RL =/= pushProofStack and RL =/= popProofStack and RL =/= cases
        )
  .
  eq calcPrintingModule(MN, M-BASE, (LU< cistep , M-LOG , GLL, VSL > :LU: LUL)) =
      calcModuleUnion'(
        M-LOG,
        calcPrintingModule(MN, M-BASE, LUL),
        MN
      )
  .
  ceq calcPrintingModule(MN, M-BASE, (LU< RL, M-LOG, GLL > :LU: LUL)) = M'
    if (RL == ccstep-atts)
    /\ OD := getOps(M-LOG)
    /\ (op Q : TyL -> Ty [AS] .) := OD
    /\ (op Q' : TyL -> Ty [AS] .) := getOpFromOpAtts(OD)
    /\ AS' := filterIdemUnit(AS)
    /\ M-LOG' := setOps(M-LOG, (op Q : TyL -> Ty [AS'] .))
    /\ M := calcModuleUnion'(
              M-LOG',
              calcPrintingModule(MN, M-BASE, LUL),
              MN
            )
    /\ M' := addOps((op Q' : TyL -> Ty [AS'] .), M)
  .
  eq calcPrintingModule(MN, M-BASE, (LU :LU: LUL)) =
      calcPrintingModule(MN, M-BASE, LUL) [owise] .

  --- Draws an inference line.
  op drawInfLn : QidList -> QidList .
  eq drawInfLn(QL) =
     ('---------------------------------------------------------- '\s
      qid("[") QL qid("]") '\n) .

  op lastProof : NsList{LogUple} -> NsList{LogUple} .
  ceq lastProof((LUL :LU: LU<proofSeparator> :LU: LUL')) = lastProof(LUL) 
    if LUL =/= nsnil-LU
  .
  eq lastProof(LUL) = LUL [owise] .

  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  --- showProof
  ---
  --- Displays the proof as a sequence of inference rules.
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------

  op showProof : NsList{LogUple} Module SimpRlDeclList NsList{InductionUple}
                 -> QidList .
  eq showProof(nsnil-LU, M-PRINT, SRDL, IUL) = '\n .
  eq showProof((LU<proofSeparator> :LU: LUL), M-PRINT, SRDL, IUL) =
     '========================================= '\n '\n
     showProof(LUL, M-PRINT, SRDL, IUL)
  .

  ceq showProof((LU< RL, M-LOG, GLL > :LU: LUL), M-PRINT, SRDL, IUL) =
      (
        myMetaPrettyPrint(M-PRINT,
          c2v(prettyEq(convGLL2EL(GLL), IUL)), ('|||- '\s '\s)
        )
        drawInfLn(convRL2QL(RL))
        '|||- '\s '\s
        myMetaPrettyPrint(M-PRINT,
          c2v(prettyEq(E, IUL))
        )
        '\n '\n
      )
      showProof(LUL, M-PRINT, SRDL, IUL)
    if ((RL == ccstep-eq) or (RL == cases) or
        (RL == generalize) or (RL == checkcond))
    /\ E := getEqs(M-LOG)
  .

  ceq showProof((LU< RL, M-LOG, eq2goal(ceq T = T' if COND [AS] .) > :LU: LUL),
                M-PRINT, SRDL, IUL) =
      (
        if (B-IS-REDUCED:Bool)
          then
            ( '|- '\s '\s
            myMetaPrettyPrint(M-PRINT,
              c2v(prettyEq(E, IUL))
            )
            drawInfLn(convRL2QL(eqRed))
             '|||- '\s '\s
            )
          else
            ( '|- '\s '\s
            myMetaPrettyPrint(M-PRINT,
              c2v(prettyEq((ceq T = T' if COND [AS] .), IUL))
            )
            drawInfLn(convRL2QL(RL))
             '|- '\s '\s
            )
        fi

        myMetaPrettyPrint(M-PRINT,
          c2v(prettyEq(E, IUL))
        )
        '\n '\n
      )
      showProof(LUL, M-PRINT, SRDL, IUL)
    if (RL == normalize)
    /\ B-IS-REDUCED:Bool := (T == T')
    /\ E := getEqs(M-LOG)
  .
  
  --- proof : ccstep-atts
  ceq showProof((LU< RL, M-LOG, GLL > :LU: LUL), M-PRINT, SRDL, IUL) =
      (
       myMetaPrettyPrint(M-PRINT, c2v(convGLL2EL(GLL)))
       drawInfLn(convRL2QL(RL))
       eMetaPrettyPrint(M-PRINT, OD) '\n '\n '\n
      )
      showProof(LUL, M-PRINT, SRDL, IUL)
    if RL == ccstep-atts
    /\ OD := getOps(M-LOG)
  .
  
  --- proof : simplify rule
  ceq showProof((LU< RL, M-LOG, GLL > :LU: LUL), M-PRINT, SRDL, IUL) =
    (
     '|- '\s '\n myMetaPrettyPrint(M-PRINT,c2v(prettyEq(convGLL2EL(GLL), IUL)))
     drawInfLn(QSRLNF:QidList)
     '|- '\s myMetaPrettyPrint(M-PRINT, c2v(E))
     '\n '\n
    ) 
      showProof(LUL, M-PRINT, SRDL, IUL)
    if RL == simplify
    /\ E := getEqs(M-LOG)
    /\ (ceq T = T' if COND [AS] .) := E
    /\ M := addEqs((convCond2Eqs(COND)), M-PRINT)
    /\ SRDS< SR , theta? > := findSimplificationRule(M, SRDL, T, T')
    /\ (csrl (QSRLN:Qid) : (U = U') => CPTD if COND' .) := SR    
    /\ QSRLNF:QidList := 
                         if (QSRLN:Qid == 'none)
                           then convRL2QL(RL) 
                           else (convRL2QL(RL) '\s qid("[") QSRLN:Qid qid("]"))
                         fi
  .

  ceq showProof((LU< cistep , M-LOG , GLL, VSL > :LU: LUL),
        M-PRINT, SRDL, IUL) =
      (
       myMetaPrettyPrint(M-PRINT, c2v(prettyEq(convGLL2EL(GLL), IUL)), ('|||- '\s '\s))
       drawInfLn(convRL2QL(cistep))
       '|||- '\s '\s
       myMetaPrettyPrint(M-PRINT, c2v(prettyEq(EL', IUL)))
      '\n '\n
      )
      showProof(LUL, M-PRINT, SRDL, IUL)
    if EL' := convEqSet2EqList(getEqs(M-LOG))
  .
  
  --- proof : unexpected case
  eq showProof((LU :LU: LUL), M-PRINT, SRDL, IUL) = 
     showProof(LUL, M-PRINT, SRDL, IUL)
     [owise]
  .
  
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  --- showProof definition finished
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  
  
  rl [parseCommand--reduce`.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('reduce`..@Command@),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < reduce , reduce , false >,
      input       : nilTermList,
      Atts
    >
  .
  
  
  rl [parseCommand--cases`.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('cases`..@Command@),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < cases, cases, false >,
      input       : nilTermList,
      Atts
    >
  .

  rl [parseCommand--checkcond`.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('checkcond`..@Command@),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < checkcond, checkcond, false >,
      input       : nilTermList,
      Atts
    >
  .

  rl [parseCommand--ccstep`.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('ccstep`..@Command@),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < ccstep , ccstep , false >,
      input       : nilTermList,
      Atts
    >
  .
  
  rl [parseCommand--derive`.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('derive`..@Command@),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < ccstep , ccstep , false >,
      input       : nilTermList,
      Atts
    >
  .


  crl [parseCommand--cistep_.] :
    < O : X@Database |
      proofStatus : waiting,
      proofStack  : PSS,
      input       : ('cistep_.['bubble[T]]),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < cistep , cistep , false >,
      proofStack  : setTopVSL(convQidList2VarSet(QL), PSS),
      input       : nilTermList,
      Atts
    >
    if QL := downTerm(T, 'nil) 
  .
  
  rl [parseCommand--cistep`.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('cistep`..@Command@),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < cistep , cistep , false >,
      input       : nilTermList,
      Atts
    >
  .
  
  rl [parseCommand--simplify`.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('simplify`..@Command@),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < simplify , simplify , false >,
      input       : nilTermList,
      Atts
    >
  .

  rl [parseCommand--coinduction`.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('coinduction`..@Command@),
      grlz        : SW,
      noSubgoals  : I-NO-SUBGOALS:Int,
      proofStack  : PSS,
      maxNoSteps  : MNS,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : if (SW == off)
                      then < coinduction , coinduction , false >
                      else < coinduction-grlz , coinduction-grlz , false >
                    fi,
      input       : nilTermList,
      grlz        : SW,
      noSubgoals  : 0,
      proofStack  : setTopA(
                      if (SW == off)
                        then coinduction
                        else coinduction-grlz
                      fi, setTopNSL(MNS, PSS)),
      maxNoSteps  : MNS,
      Atts
    >
  .
  

  crl [parseCommand--set`induction`vars_.] :
    < O : X@Database |
      proofStatus : waiting,
      proofStack  : PSS,
      debug       : B-DBG,
      input       : ('set`induction`vars_.['bubble[T]]),
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < startInduction , startInduction , false >,
      proofStack  : setTopVSL(convQidList2VarSet(QL), PSS),
      debug       : true,
      input       : nilTermList,
      Atts
    >
    if QL := downTerm(T, 'nil)
  .
  
  crl [parseCommand--induction`on_.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('induction`on_.['bubble[T]]),
      proofStack  : PSS,
      maxNoSteps  : MNS,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < startInduction , startInduction , false >,
      input       : nilTermList,
      proofStack  : setTopVSL(convQidList2VarSet(QL), setTopNSL(MNS, PSS)),
      maxNoSteps  : MNS,
      Atts
    >
    if QL := downTerm(T, 'nil)
  .


  crl [parseCommand--induction`.] :
    < O : X@Database |
      proofStatus : waiting,
      debug       : B-DBG,
      input       : ('induction`..@Command@),
      proofStack  : PSS,
      maxNoSteps  : MNS,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : if (B-DBG == true)
                      then < induction, induction, false >
                      else < startInduction, startInduction, false >
                    fi,
      debug       : B-DBG,
      input       : nilTermList,
      proofStack  : setTopNSL(MNS, 
                      setTopVSL(if (B-DBG == true)
                                  then VSL
                                  else VSL'
                                fi, PSS)
                    ),
      maxNoSteps  : MNS,
      Atts
    >
    if VSL  := getTopVSL(PSS)
    /\ GL   := getTopGLL(PSS)
    /\ VSL' := if (VSL == nsempty-V)
                 then getAllVars(GL)
                 else VSL
               fi
***(
    /\ eq2goal(E) :G: GL := getTopGLL(PSS)
    /\ VSL' := if (VSL == nsempty-V)
                 then getVars(removeCoFreezing(c2v(E)))
                 else VSL
               fi
)
  .

  var G : Goal .
  op getAllVars : NsList{Goal} -> NsSet{Variable} .
  eq getAllVars(eq2goal(E)) = getVars(removeCoFreezing(c2v(E))) .
  eq getAllVars(G) = nsempty-V [owise] .
  ceq getAllVars(G :G: GL) = getAllVars(G) ;V; getAllVars(GL)
    if GL =/= nsnil-G
  .

  
  var ActApplied : Action .
  
  op downAction : Term -> Action .

  eq downAction('normalize.RuleLabel)     = normalize .
  eq downAction('eqRed.RuleLabel)         = eqRed .
  eq downAction('cistep.RuleLabel)        = cistep .
  eq downAction('simplify.RuleLabel)      = simplify .
  eq downAction('ccstep.RuleLabel)        = ccstep .
  eq downAction('generalize.RuleLabel)    = generalize .
  eq downAction('checkcond.RuleLabel)     = checkcond .
  eq downAction('reduce.Action)           = reduce .
  eq downAction('coinduction.Action)      = coinduction .
  eq downAction('coinduction-grlz.Action) = coinduction-grlz .
  
  eq downAction('_|>_[T1, T2]) = downAction(T1) |> downAction(T2) .
  eq downAction('_#_[T1, T2]) = downAction(T1) # downAction(T2) .
  eq downAction('_![T]) = downAction(T) ! .


  crl [parseCommand--apply_.] :
    < O : X@Database |
      proofStatus : waiting,
      input       : ('apply_.['bubble[T]]),
      proofStack  : PSS,
      maxNoSteps  : MNS,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : < ActApplied, ActApplied, false >,
      input       : nilTermList,
      proofStack  : setTopNSL(MNS, PSS),
      maxNoSteps  : MNS,
      Atts
    >
    if QL  := downTerm(T, 'nil)
    /\ RP1 := metaParse(upModule('PROOFSTATUS, false), QL, 'Action)
    /\ RP1 :: ResultPair
    /\ ActApplied := downAction(getTerm(RP1))
  .

  crl [parseCommand--apply_.-error] :
    < O : X@Database |
      input       : ('apply_.['bubble[T]]),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      input       : nilTermList,
      output      : ('Please 'make 'sure 'that 'you 'typed 'correctly
                     'and 'put 'all 'the 'needed 'brackets. '\n),
      Atts
    >
    if QL  := downTerm(T, 'nil)
    /\ RP1 := metaParse(upModule('PROOFSTATUS, false), QL, 'Action)
    /\ not(RP1 :: ResultPair)
  .
  
  rl [parseCommand--quit`proof`.] :
    < O : X@Database |
      input         : ('quit`proof`..@Command@),
      output        : nil,
      Atts
    >
    =>
    < O : X@Database |
      input         : 'initialize`..@Command@,
      output        : ('\b 'All 'hypotheses 'and 'lemmas 'gathered 'during
                       'previous 'proofs 'have 'been 'removed.
                       '\n '\o),
      Atts
    >
  .

  rl [parseCommand--show`history`.] :
    < O : X@Database |
      input       : ('show`history`..@Command@),
      Atts
    >
    =>
    < O : X@Database |
      input       : ('show`proof`..@Command@),
      Atts
    >
  .

  rl [parseCommand--set`show`details`on`.] :
    < O : X@Database |
      proofStatus : PrSt,
      showDetails : SW,
      input       : ('set`show`details`on`..@Command@),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      showDetails : on,
      input       : nilTermList,
      output      : ('\g '\n 'Details 'will 'be 'shown. '\n '\o),
      Atts
    >
  .

  rl [parseCommand--set`show`details`off`.] :
    < O : X@Database |
      proofStatus : PrSt,
      showDetails : SW,
      input       : ('set`show`details`off`..@Command@),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      showDetails : off,
      input       : nilTermList,
      output      : ('\g '\n 'Details 'will 'not 'be 'shown. '\n '\o),
      Atts
    >
  .

  rl [parseCommand--set`show`proved`properties`on`.] :
    < O : X@Database |
      proofStatus  : PrSt,
      showProvProp : SW,
      input        : ('set`show`proved`properties`on`..@Command@),
      output       : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus  : waiting,
      showProvProp : on,
      input        : nilTermList,
      output       : ('\g '\n 'Proved 'properties 'will 'be 'shown. '\n '\o),
      Atts
    >
  .
  
  rl [parseCommand--set`show`proved`properties`off`.] :
    < O : X@Database |
      proofStatus  : PrSt,
      showProvProp : SW,
      input        : ('set`show`proved`properties`off`..@Command@),
      output       : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus  : waiting,
      showProvProp : off,
      input        : nilTermList,
      output       : ('\g '\n 'Proved 'properties 'will 'not 'be 'shown. '\n '\o),
      Atts
    >
  .

  crl [parseCommand--set`auto`contexts`on`.] :
    < O : X@Database |
      proofStatus : PrSt,
      autoContext : SW,
      allContexts : SW',
      input       : ('set`auto`contexts`on`..@Command@),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      autoContext : SW'':SwitchStatus,
      allContexts : SW',
      input       : nilTermList,
      output      : QL,
      Atts
    >
    if QL := if (SW' == off)
                then ('\g '\n 'Contexts 'will 'be 'automatically 'computed. '\n '\o)
                else '\n
             fi
    /\ SW'':SwitchStatus := if (SW' == off)
                               then on
                               else SW
                            fi
  .

  rl [parseCommand--set`auto`contexts`off`.] :
    < O : X@Database |
      proofStatus : PrSt,
      autoContext : SW,
      input       : ('set`auto`contexts`off`..@Command@),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      autoContext : off,
      input       : nilTermList,
      output      : ('\g '\n 'Contexts 'will 'not 'be 'automatically 'computed. '\n '\o),
      Atts
    >
  .
  
  rl [parseCommand--set`all`contexts`special`.] :
    < O : X@Database |
      proofStatus : PrSt,
      autoContext : SW,
      allContexts : SW',
      input       : ('set`all`contexts`special`..@Command@),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      autoContext : off,
      allContexts : on,
      input       : nilTermList,
      output      : ('\g '\n 'Contexts 'will 'be 'used 'without 'verification. '\n '\o),
      Atts
    >
  .

  rl [parseCommand--set`all`scx`off`.] :
    < O : X@Database |
      proofStatus : PrSt,
      allContexts : SW,
      input       : ('set`all`scx`off`..@Command@),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      allContexts : off,
      input       : nilTermList,
      output      : ('\g '\n 'Contexts 'will 'not 'be 'used 'without 'verification. '\n '\o),
      Atts
    >
  .

  rl [parseCommand--set`auto`add`conj`on`.] :
    < O : X@Database |
      proofStatus : PrSt,
      autoAddConj : SW,
      input       : ('set`auto`add`conj`on`..@Command@),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      autoAddConj : on,
      input       : nilTermList,
      output      : ('\g '\n 'Proved 'conjectures 'will 'be 'added
                     'to 'the 'hypothesis. '\n '\o),
      Atts
    >
  .
  
  rl [parseCommand--set`auto`add`conj`off`.] :
    < O : X@Database |
      proofStatus : PrSt,
      autoAddConj : SW,
      input       : ('set`auto`add`conj`off`..@Command@),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      autoAddConj : off,
      input       : nilTermList,
      output      : ('\g '\n 'Proved 'conjectures 'will 'not 'be 'added
                     'to 'the 'hypothesis. '\n '\o),
      Atts
    >
  .
  
  
  rl [parseCommand--set`generalization`on`.] :
    < O : X@Database |
      proofStatus : PrSt,
      grlz        : SW,
      input       : ('set`generalization`on`..@Command@),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      grlz        : on,
      input       : nilTermList,
      output      : ('\g '\n 'Generalization 'will 'be
                     'automatically 'used. '\n '\o),
      Atts
    >
  .
  
  rl [parseCommand--set`generalization`off`.] :
    < O : X@Database |
      proofStatus : PrSt,
      grlz        : SW,
      input       : ('set`generalization`off`..@Command@),
      output      : nil,
      Atts
    >
    =>
    < O : X@Database |
      proofStatus : waiting,
      grlz        : off,
      input       : nilTermList,
      output      : ('\g '\n 'Generalization 'will 'not 'be 'used. '\n '\o),
      Atts
    >
  .
  
  crl [parseCommand--show`flat`module`.] :
      < O : X@Database |
      db            : DB,
      input         : ('show`flat`module`..@Command@),
      output        : nil,
      default       : ME,
      Atts
    >
    =>
    < O : X@Database |
      db            : DB,
      input         : nilTermList,
      output        : QL,
      default       : ME,
      Atts
    >
    if QL := eMetaPrettyPrint(
                getFlatModule(ME, DB), 
                getFlatCth(ME, DB)
             )
  .

endm --- CIRC-DATABASE-HANDLING


***( ===========================================================================
*
* ============================================================================ )

mod CIRC-PROVER is

  including CIRC-DATABASE-HANDLING .

  var A A' A1 A2        : Action .
  var Att Att'          : Attr .
  var AS AS' AttS       : AttrSet .
  var Atts              : AttributeSet .
  var B B-DBG           : Bool .
  var W W1 W'           : Bool .
  var X@CIRCDataBase    : CIRCDataBase .
  var DB DB'            : Database .
  var CPTD              : EqCondition .
  var COND COND'        : EqCondition .
  var E E' E1 E2        : Equation .
  var ES ES' ES''       : EquationSet .
  var IL                : ImportList .
  var N N' NSL MNS      : Int .
  var MAS               : MembAxSet .
  var M M' M'' M'''     : Module .
  var MN                : ModuleName .
  var VS VS1 VS2        : NsSet{Variable} .
  var EL EL' EL''       : NsList{Equation} .
  var EL1 EL2 EL3       : NsList{Equation} .
  var GL GL' GL''       : NsList{Goal} .
  var G                 : Goal .
  var LU LU' LU''       : LogUple .
  var O                 : Oid .
  var OD OD'            : OpDecl .
  var ODS               : OpDeclSet .
  var ODS1 ODS2 ODS3    : OpDeclSet .
  var PrSt PrSt' PrSt'' : ProofStatus .
  var Q Q' Q'' Q1 Q2 Q3 : Qid .
  var QL                : QidList .
  var QL1 QL2 QL3 QL4   : QidList .
  var CSUBST            : <Qid|Subst> .
  var RP                : ResultPair? .
  var RL                : RuleLabel .
  var SRDL SRDL' SRDL'' : SimpRlDeclList .
  var SR SR'            : SimpRlDecl .
  var S S'              : Sort .
  var SS                : SortSet .
  var STR               : String .
  var theta? theta'?    : Substitution? .
  var theta''?          : Substitution? .
  var SSDS              : SubsortDeclSet .
  var SW SW'            : SwitchStatus .
  var T T' T'' U U'     : [Term] .
  var T1 T1' T2 T3      : Term .
  var TT TT1 TT2 TT3    : Term .
  var TL TL' TL''       : TermList .
  var TL-SCXS           : TermList .
  var TStk              : TripStack .
  var Ty                : Type .
  var TyL               : TypeList .
  var V V' V1 V2        : Variable .
  var M-WORK M-WORK'    : Module .
  var M-LOG M-LOG'      : Module .
  var M-TOP M-TOP'      : Module .
  var M-FLAT            : Module .
  var M-CTH-FLAT        : Module .
  var VSL VSL' VSL0     : NsList{NsSet{Variable}} .
  var IUL               : NsList{InductionUple} .
  var LUL LUL' LUL''    : NsList{LogUple} .
  var CNJL              : NsList{Goal} .
  var USR-MSG-SCX       : QidList .

  crl [initialize] :
    < O : X@CIRCDataBase |
      db            : DB,
      autoContext   : SW,
      allContexts   : SW',
      default       : MN,
      proofStatus   : (< initialize , initialize , false > ;TS; TStk),
      proofStack    : PSS,
      debug         : B-DBG:Bool,
      ctors         : ODS,
      ssorts        : SSDS,
      uniqueNat     : UNQNAT:Nat,
      hypCounter    : N,
      noSubgoals    : I-NO-SUBGOALS:Int,
      maxNoSteps    : MNS,
      topModule     : M-TOP:Module,
      internModule  : M-INTERNAL:Module,
      flatModule    : M-FLAT:Module,
      log           : LUL,
      derivatives   : TL,
      spectxs       : TL',
      simplifyRules : SRDL,
      casesPairs    : CPL:NsList{CasePair},
      output        : nil,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      db            : DB',
      autoContext   : SW,
      allContexts   : SW',
      default       : MN,
      proofStatus   : (< initialize , noAction , true > ;TS; TStk),
      proofStack    : PS< base, nsnil-G, nsnil-G, noModule,  nsempty-V, nsnil-IU, nsempty-IS, noAction, MNS >,
      debug         : false,
      ctors         : getCtors(M-FLAT),
      ssorts        : getSubsorts(M-FLAT),
      uniqueNat     : 0,
      hypCounter    : 0,
      noSubgoals    : 0,
      maxNoSteps    : MNS,
      topModule     : M-TOP:Module,
      internModule  : M-INTERNAL:Module,
      flatModule    : M-FLAT:Module,
      log           : LU<proofSeparator>,
      derivatives   : TL-DERS,
      spectxs       : TL-SCXS,
      simplifyRules : getSimpRls(M-CTH-FLAT),
      casesPairs    : CPL':NsList{CasePair},
      output        : USR-MSG-SCX,
      Atts
    >
    if DB'                   := insertFlatModule(MN, M-FLAT:Module,
                                  insertInternalModule(MN, M-INTERNAL:Module,
                                    insertTopModule(MN, M-TOP:Module, DB)
                                  )
                                )
    /\ M-FLAT                := getFlatModule(MN, DB')
    /\ M-CTH-FLAT            := getFlatCth(MN, DB')
    /\ TL-DERS               := calcDerivatives(MN, DB')
    /\ SS-HIDDEN             := getSortsHidden(TL-DERS) /\ true
    /\ TL''                  := convSCDL2TL(M-FLAT, getSpeCtxs(M-CTH-FLAT))
    /\ CPL':NsList{CasePair} := convGEDL2CPL(getGrdEqDecl(M-CTH-FLAT)) :CP:
                                convES2CPL(getEnumSorts(M-CTH-FLAT)) :CP:
                                convCEDL2CPL(getCaseEqDecl(M-CTH-FLAT))
    /\ TL< TL-SCXS, USR-MSG-SCX > :=
         if (SW' == off)
           then calcValidScxs(TL'', M-FLAT, TL-DERS, SS-HIDDEN, CPL':NsList{CasePair}, SW)
           else TL< calcCandidateScxs(getOps(M-FLAT), M-FLAT, TL-DERS, SS-HIDDEN), '\n >
         fi
  .

  crl [addSpeCtxHypo] :
    < O : X@CIRCDataBase |
      db          : DB,
      default     : MN,
      proofStatus : (< addSpeCtxHypo , addSpeCtxHypo , false > ;TS; TStk),
      proofStack  : PSS,
      derivatives : TL,
      spectxs     : TL'',
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      db          : DB,
      default     : MN,
      proofStatus : (< addSpeCtxHypo , noAction , true > ;TS; TStk),
      proofStack  : setTopM(M-WORK', PSS),
      derivatives : TL,
      spectxs     : TL'',
      Atts
    >
    if M       := getFlatModule(MN, DB)
    /\ M'      := addNotEqual(TL, addCoFreezingSorts(M))
    /\ ES'     := genSpeCtxHypo(TL'')
    /\ M-WORK' := addEqs(ES', M')
  .

  var I-NO-SUBGOALS   : Int .
  var M-BASE M-PRINT  : Module .
  
  --- The following preconditions need to be satisfied:
  ---   no conjectures left
  ---   no goals left
  ---   empty proof stack
  ---   no proof separator at the top 
  crl [full-proof-suceeded] :
    < O : X@CIRCDataBase |
      db            : DB,
      default       : MN,
      proofStatus   : PrSt,
      proofStack    : PSS,
      output        : nil,
      noSubgoals    : I-NO-SUBGOALS,
      maxNoSteps    : MNS,
      derivatives   : TL-DERS,
      log           : LUL,
      showProvProp  : SW,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      db            : DB,
      default       : MN,
      proofStatus   : < addSpeCtxHypo , addSpeCtxHypo , false >,
      proofStack    : setTopA(noAction, setTopVSL(nsempty-V, setTopNSL(MNS, PSS))),
      output        : (QL2),
      noSubgoals    : I-NO-SUBGOALS,
      maxNoSteps    : MNS,
      derivatives   : TL-DERS,
      log           : (LU<proofSeparator> :LU: LUL),
      showProvProp  : SW,
      Atts
    >
    if not hasTopProofSeparator(LUL)
    /\ getTopCO(PSS) == base
    /\ getTopCNJL(PSS) == nsnil-G
    /\ getTopGLL(PSS) == nsnil-G
    /\ LUL' := lastProof(LU<proofSeparator> :LU: LUL)
    /\ SS-HIDDEN := getSortsHidden(TL-DERS)
    /\ M-BASE    := getFlatModule(MN, DB)
    /\ M         := calcPrintingModule(MN, M-BASE, LUL)
    /\ M-PRINT   := addCoFreezingSorts(M)
    /\ QL2  := ('\n '\g 'Proof 'succeeded. '\o '\n '\n
                '\s '\s 'Number 'of 'derived 'goals: '\s
                    '\g qid(string(I-NO-SUBGOALS, 10)) '\o '\n
                '\s '\s 'Number 'of 'proving 'steps 'performed: '\s
                    '\g (qid(string((MNS + (- getTopNSL(PSS))), 10))) '\o '\n
                '\s '\s 'Maximum 'number 'of 'proving 'steps 'is 'set 'to: '\s
                    '\g qid(string(MNS, 10)) '\o '\n '\n
                if (SW == on)
                  then '\g 'Proved 'properties: '\o '\n '\n
                       showProvedLemmas(LUL', M-PRINT, getTopIUL(PSS))
                  else '\s
                fi
                '\n
               )
    /\ (not hasCheckingCToken(PrSt))
    ---[print LUL]
  .

  --- empty proof stack => prints why it stopped
  --- nonempty proof stack, pushed by user => prints why it stopped
  --- nonempty proof stack, comming from a disjunctive goal => pops & restores
  crl [conjectures-not-proved] :
    < O : X@CIRCDataBase |
      proofStatus : PrSt,
      proofStack  : PSS,
      output      : nil,
      stopMessage : QL-SM:QidList,
      showDetails : SW,
      log         : LUL,
      Atts
    >
    =>
    if (not B-DISJUNCTION:Bool)
    then < O : X@CIRCDataBase |
           proofStatus : waiting,
           proofStack  : if B-STEPS-EXCEEDED:Bool
                           then setTopNSL(0, PSS)
                           else PSS
                         fi,
           output      : QL-MESSAGE:QidList,
           showDetails : SW,
           stopMessage : nil,
           log         : LUL,
           Atts
         >
    else < O : X@CIRCDataBase |
           proofStatus : start(getTopA(pop(PSS))),
           proofStack  : pop(PSS),
           output      : if (SW == on) then QL-MESSAGE:QidList else nil fi,
           showDetails : SW,
           stopMessage : nil,
           log         : LUL',
           Atts
         >
    fi
    if PrSt =/= waiting
    /\ NSL := getTopNSL(PSS)
    /\ B-DISJUNCTION:Bool := (getTopCO(PSS) == disjunction)
    /\ B-STEPS-EXCEEDED:Bool := NSL < 0
    /\ B-VISIBLE-FAILED:Bool := QL-SM:QidList =/= nil
    /\ B-STEPS-EXCEEDED:Bool or B-VISIBLE-FAILED:Bool
    /\ QL-MESSAGE:QidList :=
       if B-STEPS-EXCEEDED:Bool
         then ('\b 'Stopped: 'the 'number 'of 'prover 'steps 'was 'exceeded. '\o)
         else
           if B-VISIBLE-FAILED:Bool
             then QL-SM:QidList
             else nil
           fi
       fi
    /\ LUL' := removeDisjBranch(LUL)
  .
  
  op removeDisjBranch : NsList{LogUple} -> NsList{LogUple} .
  ceq removeDisjBranch(LUL :LU: LU<disjSeparator> :LU: LUL') = LUL'
    if not contains(LUL, LU<disjSeparator>)
  .
  eq removeDisjBranch(LUL) = LUL [owise] .
  
  op contains : NsList{LogUple} LogUple -> Bool .
  eq contains(LUL :LU: LU :LU: LUL', LU) = true .
  eq contains(LUL, LU) = false [owise] .

  --- The rule is fired when there are no more goals to be proved,
  --- but the list of conjectures has at least one element.
  crl [conjectures-proved] :
    < O : X@CIRCDataBase |
      db          : DB,
      default     : MN,
      proofStatus : PrSt,
      proofStack  : PSS,
      autoAddConj : SW, 
      Atts
    >
    =>
    if (not B-DISJUNCTION:Bool)
    then < O : X@CIRCDataBase |
           db          : insertFlatModule(MN, M', DB),
           default     : MN,
           proofStatus : < popProofStack , popProofStack , false >,
           proofStack  : setTopM(M', setTopCNJL(nsnil-G, PSS)),
           autoAddConj : SW, 
           Atts
         >
    else < O : X@CIRCDataBase |
           db          : insertFlatModule(MN, M', DB),
           default     : MN,
           proofStatus : start(getTopA(pop(PSS))),
           proofStack  : setTopM(M', setTopGLL(nsnil-G, pop(PSS))),
           autoAddConj : SW, 
           Atts
         >
    fi
    if CNJL := getTopCNJL(PSS)
    /\ CNJL =/= nsnil-G
    /\ getTopGLL(PSS) == nsnil-G
    /\ B-DISJUNCTION:Bool := (getTopCO(top(PSS)) == disjunction)
    /\ M    :=  getFlatModule(MN, DB)
    /\ M'   :=  if (SW == on)
                  then addTheorems(CNJL, M)
                  else M
                fi
    ---[print  "!!!!!!!!!!!!!!!!!!!!!!!! " B-DISJUNCTION:Bool "\n" PSS]
  .
  
  var PSS : Stack{ProofStateUple} .
  crl [forward] :
    < O : X@CIRCDataBase |
      proofStatus   : PrSt,
      showDetails   : SW,
      maxNoSteps    : MNS,
      proofStack    : PSS,
      output        : nil,
      log           : LUL,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus   : start(getTopA(PSS)), ---< addSpeCtxHypo , addSpeCtxHypo , false >,
      showDetails   : SW,
      maxNoSteps    : MNS,
      proofStack    : (PS< disjunction, GL, GL, getTopM(PSS), nsempty-V, nsnil-IU, nsempty-IS, getTopA(PSS), MNS > ;PS; 
                       setTopGLL(GLL, PSS)),
      output        : if SW == on then
                      ('\n '\b 'Disjunctive 'proof 'obligation: '\o '\n
                      myMetaPrettyPrint(getTopM(PSS), getTopGLL(PSS))
                      ) else nil fi,
      log           : (LU<disjSeparator> :LU: LUL),
      Atts
    >
    if CNJL := getTopCNJL(PSS)
    /\ GL :GL: GLL := getTopGLL(PSS)
    /\ GL =/= nsnil-G
    /\ GLL =/= nsnil-G
    /\ PPPP:ProofStatus := start(getTopA(PSS))
    ---[print PPPP:ProofStatus]
    ---[print LUL]
  .

  
  op showProvedLemmas : NsList{LogUple} Module  NsList{InductionUple} -> QidList .
  op showProvedLemmas : NsList{Equation} Module -> QidList .

  ceq showProvedLemmas(LUL, M-PRINT, IUL) = QL
  if EL := removeDuplicates(extractProvedLemmas(LUL, IUL))
  /\ QL := showProvedLemmas(EL, M-PRINT)
  .
  
  eq showProvedLemmas(nsnil-E, M-PRINT) = '\n .
  eq showProvedLemmas(E :E: EL, M-PRINT) =
     ('\s '\s myMetaPrettyPrint(M-PRINT, E))
     showProvedLemmas(EL, M-PRINT)
  .

  --- Extracts the equations added for the rules: ccstep-eq, addGoalEq
  op extractProvedLemmas : NsList{LogUple} NsList{InductionUple} ->
                           NsList{Equation} .

  eq extractProvedLemmas(nsnil-LU, IUL) = nsnil-E .
  eq extractProvedLemmas((LU :LU: LUL), IUL) = 
     extractProvedLemmas(LUL, IUL) [owise] .
  ceq extractProvedLemmas((LU< RL, M-LOG, GLL > :LU: LUL), IUL) =
      c2v(removeCoFreezing(prettyEq(E, IUL)))
      :E:
      extractProvedLemmas(LUL, IUL)
    if ((RL == ccstep-eq) or (RL == addGoalEq))
    /\ E := getEqs(M-LOG)
  .

  ceq extractProvedLemmas((LU< RL, M-LOG, GLL, VSL > :LU: LUL), IUL) =
      c2v(removeCoFreezing(prettyEq(E, IUL)))
      :E:
      extractProvedLemmas(LUL, IUL)
    if (RL == cistep)
    /\ E := getEqs(M-LOG)
  .


  rl [end-of-a-tactic] :
    < O : X@CIRCDataBase |
      proofStatus : < ACT:Action, noAction, BB:Bool >,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus : waiting,
      Atts
    >
  .

  rl [language-combine] :
    < O : X@CIRCDataBase |
      proofStatus : (< A', noAction, W' > ;TS; (< A, noAction, W > ;TS; TStk)),
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus : (< A, noAction, W' or W > ;TS; TStk),
      Atts
    >
  .

  ---                                  [ a1, def(a1) , 0 ]
  --- [ a, def(a) = a1 |> a2, w ]  ->  [ a , a1 |> a2, w ]
  --- [ ....................... ]      [ ............... ]
  rl [language-|>] :
    < O : X@CIRCDataBase |
      proofStatus : (< A1 |> A2, A1 |> A2, W > ;TS; TStk),
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus : (< A1, A1, false > ;TS; (< A1 |> A2, A1 |> A2, W > ;TS; TStk)),
      Atts
    >
  .

  --- [ a2, def(a2), 0 ] w1=0 [ a1,    0    , w1 ] else               
  --- [ a ,    0   , w ]  <-  [ a , a1 |> a2, w  ]  ->  [ a, 0, w w1 ]
  --- [ .............. ]      [ ................ ]      [ .......... ]
  rl [language-|>] :
    < O : X@CIRCDataBase |
      proofStatus : (< A1, noAction, W1 > ;TS; (< A1 |> A2, A1 |> A2, W > ;TS; TStk)),
      Atts
    >
    =>
    if (W1)
    then < O : X@CIRCDataBase |
           proofStatus : (< A1 |> A2, noAction, W1 or W > ;TS; TStk),
           Atts
         >
    else < O : X@CIRCDataBase |
           proofStatus : (< A2, A2, false > ;TS; (< A1 |> A2, noAction, W > ;TS; TStk)),
           Atts
         >
    fi
  .

  ---                                 [ a1, def(a1), 0 ]
  --- [ a, def(a) = a1 # a2, w ]  ->  [ a , a1 # a2, w ]
  --- [ ...................... ]      [ .............. ]
  rl [language-#] :
    < O : X@CIRCDataBase |
      proofStatus : (< A1 # A2, A1 # A2, W > ;TS; TStk),
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus : (< A1, A1, false > ;TS; (< A1 # A2, A1 # A2, W > ;TS; TStk)),
      Atts
    >
  .

  --- [ a1,    0   , w1 ] else [ a2, def(a2),  0   ]
  --- [ a , a1 # a2, w  ]  ->  [ a ,    0   , w w1 ]
  --- [ ............... ]      [ ................. ]
  rl [language-#] :
    < O : X@CIRCDataBase |
      proofStatus : (< A1, noAction, W1 > ;TS; (< A1 # A2, A1 # A2, W > ;TS; TStk)),
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus : (< A2, A2, false > ;TS; (< A1 # A2, noAction, W1 or W > ;TS; TStk)),
      Atts
    >
  .

  ---                              [ a1, def(a1), 0 ]
  --- [ a, def(a) = a1 !, w ]  ->  [ a ,  a1 !  , w ]
  --- [ ................... ]      [ .............. ]
  rl [language-!] :
    < O : X@CIRCDataBase |
      proofStatus : (< A1 !, A1 !, W > ;TS; TStk),
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus : (< A1, A1, false > ;TS; (< A1 !, A1 !, W > ;TS; TStk)),
      Atts
    >
  .

  ---              w1=0 [ a1,  0  , w1 ]
  --- [ a1, 0, w ]  <-  [ a , a1 !, w  ]  ->  [ a ,  a1 !, ww 1 ]
  --- [ ........ ]      [ ............ ]      [ ............... ]
  rl [language-!] :
    < O : X@CIRCDataBase |
      proofStatus : (< A1, noAction, W1 > ;TS; (< A1 !, A1 !, W > ;TS; TStk)),
      Atts
    >
    =>
    if (W1)
      then < O : X@CIRCDataBase |
             proofStatus : (< A1 !, A1 !, W1 or W > ;TS; TStk),
             Atts
           >
      else < O : X@CIRCDataBase |
             proofStatus : (< A1 !, noAction, W > ;TS; TStk),
             Atts
           >
    fi
  .

  var TL-DERS : TermList .
  var SS-HIDDEN : SortSet .
  crl [addGoal-equation] :
    < O : X@CIRCDataBase |
      proofStatus   : (< addGoalEq, addGoalEq, false > ;TS; TStk),
      proofStack    : PSS,
      output        : nil,
      log           : LUL,
      derivatives   : TL-DERS,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus   : waiting,
      proofStack    : setTopGLL(eq2goal(E') :G: GL,
                        setTopCNJL(eq2goal(E) :G: CNJL, setTopM(M-WORK', PSS))
                      ),
      output        : QL2,
      log           : (LU :LU: LUL),
      derivatives   : TL-DERS,
      Atts
    >
    if M-WORK := getTopM(PSS)
    /\ CNJL   := getTopCNJL(PSS)
    /\ eq2goal(E) :G: GL := getTopGLL(PSS)
    /\ VS    := getVars(E)
    /\ SS-HIDDEN := getSortsHidden(TL-DERS)
    /\ M-WORK'   := addCts(v2c(VS), M-WORK)
    /\ E'    := coFreeze(v2c(E))
    /\ M-LOG := addEqs(v2c(E), addCts(v2c(VS), emptyLogModule))
    /\ LU    := LU< addGoalEq , M-LOG , eq2goal(E') >
    /\ QL2   := ('\n '\g 'Goal 'added: '\o '\s myOneMetaPrettyPrint(M-WORK, E) '\s '\n '\n)
  .
  
  var CNJ : Goal .
  var GLL GLL' : NsList{NsList{Goal}} .
  
  crl [undo-addGoal-equation] :
    < O : X@CIRCDataBase |
      default       : MN,
      proofStatus   : undo,
      proofStack    : PSS,
      output        : nil,
      log           : (LU< addGoalEq , M-LOG , eq2goal(E') > :LU: LUL),
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      default       : MN,
      proofStatus   : waiting,
      proofStack    : setTopGLL(GL, setTopCNJL(CNJL, setTopM(M-WORK', PSS))),
      output        : QL2,
      log           : LUL,
      Atts
    >
    if CNJ :G: CNJL := getTopCNJL(PSS)
    /\ eq2goal(E) :G: GL := getTopGLL(PSS)
    /\ M-WORK  := getTopM(PSS)
    /\ M-WORK' := calcModuleDiff(M-WORK, M-LOG, MN)
    /\ QL2     := ('\n '\g 'Goal 'removed: '\o '\s myOneMetaPrettyPrint(M-WORK, E) '\s '\n '\n)
    ---[print M-WORK M-LOG M-WORK']
  .


  crl [normalize] :
    < O : X@CIRCDataBase |
      proofStatus   : (< normalize , normalize , false > ;TS; TStk),
      showDetails   : SW,
      output        : nil,
      proofStack    : PSS,
      log           : LUL,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus   : (< normalize, noAction, CanNormalize:Bool > ;TS; TStk),
      showDetails   : SW,
      output        : if (SW == on) then QL2 else nil fi,
      proofStack    : setTopGLL(eq2goal(ceq T1 = T1' if COND [AS] .) :G: GL,
                        setTopNSL(getTopNSL(PSS) + (-1), PSS)
                      ),
      log           : LUL',
      Atts
    >
    if M-WORK := getTopM(PSS)
    /\ eq2goal(ceq T = T' if COND [AS] .) :G: GL := getTopGLL(PSS)
    /\ ES    := convCond2Eqs(COND)
    /\ M'    := addEqs(ES, M-WORK)
    /\ T1    := getTerm(metaReduce(M', T))
    /\ T1'   := getTerm(metaReduce(M', T'))
    /\ CanNormalize:Bool := (T =/= T1) or (T' =/= T1')
    /\ ENorm:Equation    := (ceq T1 = T1' if COND [none] .)
    /\ M-LOG := addEqs((ceq T = T' if COND [AS] .), emptyLogModule)
    /\ LUL'  := if (CanNormalize:Bool)
                  then (LU< normalize, M-LOG, eq2goal(ENorm:Equation) > :LU: LUL)
                  else LUL
                fi
    /\ QL2   := if (CanNormalize:Bool)
                  then
                    ('\n '\b 'Goal '\o '\s
                      myOneMetaPrettyPrint(M-WORK,
                        prettyEq(ceq T = T' if COND [none] ., getTopIUL(PSS))
                      )
                      '\s '\b 'normalized 'to '\o '\n '\s '\s '\s '\s '\s
                      myOneMetaPrettyPrint(M-WORK,
                        prettyEq(ENorm:Equation, getTopIUL(PSS))
                      ) ' '\n
                    )
                  else
                    nil
                fi
  .

  crl [undo-normalize] :
    < O : X@CIRCDataBase |
      default       : MN,
      proofStatus   : undo,
      proofStack    : PSS,
      log           : (LU< normalize, M-LOG, eq2goal(E') > :LU: LUL),
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      default       : MN,
      proofStatus   : waiting,
      proofStack    : setTopGLL(GL', PSS),
      log           : LUL,
      Atts
    >
    if E1  := getEqs(M-LOG)
    /\ eq2goal(E) :G: GL := getTopGLL(PSS)
    /\ GL' := (eq2goal(E1) :G: GL)
  .

  crl [eqRed] :
    < O : X@CIRCDataBase |
      proofStatus   : (< eqRed, eqRed, false > ;TS; TStk),
      showDetails   : SW,
      output        : nil,
      proofStack    : PSS,
      log           : LUL,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus   : (< eqRed, noAction, CanReduce:Bool > ;TS; TStk),
      showDetails   : SW,
      output        : if (SW == on) then QL2 else nil fi,
      proofStack    : setTopNSL(getTopNSL(PSS) + (-1),
                        if (CanReduce:Bool) 
                          then setTopGLL(GL, PSS)
                          else setTopGLL(eq2goal(ceq T = T' if COND [AS] .) :G: GL, PSS)
                        fi
                      ),
      log           : LUL',
      Atts
    >
    if M-WORK := getTopM(PSS)
    /\ eq2goal(ceq T = T' if COND [AS] .) :G: GL := getTopGLL(PSS)
    /\ CanReduce:Bool := (T == T')
    /\ M-LOG := addEqs((ceq T = T' if COND [AS] .), emptyLogModule)
    /\ LUL'  := if (CanReduce:Bool)
                  then (LU< eqRed, M-LOG, nsnil-G > :LU: LUL)
                  else LUL
                fi
    /\ QL2   := if (CanReduce:Bool)
                then
                  ('\b 'Goal '\o '\s
                    myOneMetaPrettyPrint(M-WORK,
                      prettyEq(ceq T = T' if COND [none] ., getTopIUL(PSS))
                    ) '\s '\b 'proved 'by 'reduction. '\o '\n
                  )
                else
                  nil
                fi
  .

  crl [undo-eqRed] :
    < O : X@CIRCDataBase |
      proofStatus   : undo,
      proofStack    : PSS,
      log           : (LU< eqRed, M-LOG, nsnil-G > :LU: LUL),
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus   : waiting,
      proofStack    : setTopGLL(GL', PSS),
      log           : LUL,
      Atts
    >
    if E   := getEqs(M-LOG)
    /\ GL  := getTopGLL(PSS)
    /\ GL' := (eq2goal(E) :G: GL)
  .

--- getVarsIndFrozen
  crl [simplify-success] :
    < O : X@CIRCDataBase |
      proofStatus   : (< simplify, simplify, false > ;TS; TStk),
      simplifyRules : SRDL,
      showDetails   : SW,
      output        : nil,
      proofStack    : PSS,
      log           : LUL,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus   : if (CanSimplify:Bool)
                        then (< simplify, noAction, true > ;TS; TStk)
                        else (< simplify, noAction, false > ;TS; TStk)
                      fi,
      simplifyRules : SRDL,
      showDetails   : SW,
      output        : if (SW == on) then QL2 else nil fi,
      proofStack    : setTopM(M-WORK', setTopNSL(getTopNSL(PSS) + (-1),
                        if (CanSimplify:Bool)
                          then setTopGLL(GLL', PSS)
                          else setTopGLL((eq2goal(ceq T = T' if COND [AS] .) :G: GL), PSS)
                        fi
                      )),
      log           : LUL',
      Atts
    >
    if M-WORK := getTopM(PSS)
    /\ eq2goal(ceq T = T' if COND [AS] .) :G: GL := getTopGLL(PSS)
    /\ M'    := addEqs((convCond2Eqs(COND)), M-WORK)
    /\ SRDS< SR , theta? > := findSimplificationRule(M', SRDL, T, T')
    /\ (csrl (QSRLN:Qid) : (U = U') => CPTD if COND' .) := SR
***(
    /\ theta? := 
      metaMatchPairCond(
                   M', '#*_*#[U], '#*_*#[U'], '#*_*#[removeCoFreezing(T)], '#*_*#[removeCoFreezing(T')], coFreezeCond(COND')
                 )
)
    /\ CanSimplify:Bool := (theta? :: Substitution) and
                           (theta? =/= none) and
                           (isFunctional(theta?))
    /\ GLL := convDisjNF2goals(theta?, COND, AS, CPTD)
    /\ M-WORK' := if (CanSimplify:Bool)
                    then addCts(v2c(getVars(convGLL2EL(GLL))), M-WORK)
                    else M-WORK
                  fi
    /\ M-LOG := addEqs((ceq T = T' if COND [AS] .), emptyLogModule)
    /\ LUL'  := if (CanSimplify:Bool)
                  then (LU< simplify , M-LOG , GLL > :LU: LUL)
                  else LUL
                fi
    /\ GLL'  := distributeDisj(GLL, GL)
    /\ QL2   := if CanSimplify:Bool
                  then
                    ('\n '\b 'Goal '\o '\s
                     myOneMetaPrettyPrint(M-WORK,
                       prettyEq(ceq T = T' if COND [none] ., getTopIUL(PSS))
                     )
                     '\s '\b 'simplified 'to '\o '\n         
                     myMetaPrettyPrint(M-WORK, GLL)
                    )
                  else
                    nil
                fi
   ---[print T "\n" GLL]
  .
  
  op distributeDisj : NsList{NsList{Goal}} NsList{Goal} -> NsList{NsList{Goal}} .
  eq distributeDisj(GL', GL) = GL' :G: GL .
  ceq distributeDisj(GLL :GL: GLL', GL) =
      distributeDisj(GLL, GL) :GL: distributeDisj(GLL', GL) 
    if GLL  =/= nsnil-G
    /\ GLL' =/= nsnil-G
  .
  
  
  crl [undo-simplify] :
    < O : X@CIRCDataBase |
      default       : MN,
      proofStatus   : undo,
      proofStack    : PSS,
      log           : (LU< simplify , M-LOG , GLL > :LU: LUL),
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      default       : MN,
      proofStatus   : waiting,
      proofStack    : setTopGLL(GL', PSS),
      log           : LUL,
      Atts
    >
    if GL      := getTopGLL(PSS)
    /\ E1      := getEqs(M-LOG)
    /\ I:Int   := count(GLL)
    /\ GL'     := (eq2goal(E1) :G: remove(I:Int, GL))
  .

  crl [simplify-fail] :
    < O : X@CIRCDataBase |
      proofStatus   : (< simplify, simplify, false > ;TS; TStk),
      simplifyRules : SRDL,
      proofStack    : PSS,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus   : (< simplify, noAction, false > ;TS; TStk),
      simplifyRules : SRDL,
      proofStack    : setTopNSL(getTopNSL(PSS) + (-1), PSS),
      Atts
    >
    if M-WORK     := getTopM(PSS)
    /\ eq2goal(ceq T = T' if COND [AS] .) :G: GL := getTopGLL(PSS)
    /\ M'         := addEqs((convCond2Eqs(COND)), M-WORK)
    /\ SRDS< noSimpRule , none > := findSimplificationRule(M', SRDL, T, T')
  .


  --- When applying norm, eqRed, simplify on operational goals, fail.
  crl [normalize-eqRed-simplify-op-cases] :
    < O : X@CIRCDataBase |
      proofStatus   : (< RL, RL, false > ;TS; TStk),
      proofStack    : PSS,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus   : (< RL, noAction, false > ;TS; TStk),
      proofStack    : setTopNSL(getTopNSL(PSS) + (-1), PSS),
      Atts
    >
    if (RL == normalize or
        RL == eqRed or
        RL == simplify or
        RL == cases or
        RL == checkcond)
    /\ op2goal(OD) :G: GL := getTopGLL(PSS)
  .
  
  --- Gets the circular coinduction rule label corresponding to a provided goal .
  op getRLccstep : Goal -> RuleLabel .
  eq getRLccstep(eq2goal(E)) = ccstep-eq .
  eq getRLccstep(op2goal(OD)) = ccstep-atts .
  
  
  crl [ccstep] :
    < O : X@CIRCDataBase |
      proofStatus : (< ccstep, ccstep, false > ;TS; TStk),
      proofStack  : PSS,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus : (< RL, RL, false > ;TS; TStk),
      proofStack  : PSS,
      Atts
    >
    if G :G: GL := getTopGLL(PSS)
    /\ RL := getRLccstep(G)
  .

  crl [ccstep-eq] :
    < O : X@CIRCDataBase |
      proofStatus : (< ccstep-eq, ccstep-eq, false > ;TS; TStk),
      derivatives : TL,
      hypCounter  : N,
      showDetails : SW,
      output      : nil,
      proofStack  : PSS,
      noSubgoals  : I-NO-SUBGOALS,
      log         : LUL,
      stopMessage : nil,
      Atts
    >
    =>
    if (not CanExpand:Bool) --- non-expandable visible goal
    then < O : X@CIRCDataBase |
           proofStatus : (< ccstep, noAction, false > ;TS; TStk),
           derivatives : TL,
           hypCounter  : N,
           showDetails : SW,
           output      : nil,
           proofStack  : setTopNSL(getTopNSL(PSS) + (-1), PSS),
           noSubgoals  : I-NO-SUBGOALS,
           log         : LUL,
           stopMessage : QL2,
           Atts
         >
    else < O : X@CIRCDataBase |
           proofStatus : (< ccstep, noAction, true > ;TS; TStk),
           derivatives : TL,
           hypCounter  : (N + 1),
           showDetails : SW,
           output      : if (SW == on) then QL3 else nil fi,
           proofStack  : setTopGLL(GL :G: convEL2GL(EL'),
                           setTopM(addEqs(E1, M-WORK), setTopNSL(getTopNSL(PSS) + (-1), PSS))
                         ),
           noSubgoals  : (I-NO-SUBGOALS + count(EL')),
           log         : (LU :LU: LUL),
           stopMessage : nil,
           Atts
         >
    fi
    if M-WORK         := getTopM(PSS)
    /\ eq2goal(ceq T = T' if COND [AS] .) :G: GL := getTopGLL(PSS)
    /\ E-HYP:Equation := cleanEquations((ceq T = T' if COND [AS] .), M-WORK)
    /\ SS-HIDDEN      := getSortsHidden(TL)
    /\ EL'            := coExpand(E-HYP:Equation, rename(TL, N), M-WORK)
    /\ CanExpand:Bool := (EL' =/= nsnil-E)
    /\ E1             := orient(c2v(E-HYP:Equation), true)
    /\ M-LOG          := if CanExpand:Bool
                           then addEqs(E-HYP:Equation, emptyLogModule)
                           else emptyLogModule
                         fi
    /\ LU   := LU< ccstep-eq, M-LOG, convEL2GL(EL') >
    /\ QL2  := ('\r 'Visible 'goal '\s '\o
                myOneMetaPrettyPrint(M-WORK,
                  prettyEq(E-HYP:Equation, getTopIUL(PSS))
                )
               ' '\r 'failed 'during 'coinduction. '\o '\n '\n
               )
               /\ true
    /\ QL3  := ('\n '\b 'Hypo '\o '\s
                  myOneMetaPrettyPrint(M-WORK,
                    prettyEq(E-HYP:Equation, getTopIUL(PSS))
                  )
                  '\s '\b 'added 'and 'coexpanded 'to '\o '\n
                  myMetaPrettyPrint(M-WORK, prettyEq(EL', getTopIUL(PSS)))
               )
  .

  *** TODO-IUL
  ***(
  crl [undo-ccstep-eq] :
    < O : X@CIRCDataBase |
      default       : MN,
      workModule    : M-WORK,
      proofStatus   : undo,
      proofStack    : PSS,
      log           : (LU< ccstep-eq , M-LOG , (EL'') > :LU: LUL),
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      default       : MN,
      workModule    : M-WORK',
      proofStatus   : waiting,
      proofStack    : setTopGLL(GL', PSS),
      log           : LUL,
      Atts
    >
    if E1      := getEqs(M-LOG)
    /\ GL      := getTopGLL(PSS)
    /\ M-WORK' := calcModuleDiff(
                    M-WORK,
                    addEqs(orient(c2v(E1), true), emptyLogModule),
                    MN
                  )
    /\ I:Int   := count(EL'')
    /\ GL'     := (eq2goal(E1) :G: remove(I:Int, GL))
  .
  ***)
  
  --- For the time being, one should quit the proof after having demonstrated
  --- some properties (comm, assoc etc.) for a certain operator(function)
  crl [ccstep-atts-success] :
    < O : X@CIRCDataBase |
      proofStatus   : (< ccstep-atts, ccstep-atts, false > ;TS; TStk),
      derivatives   : TL,
      output        : nil,
      showDetails   : SW,
      hypCounter    : N,
      proofStack    : PSS,
      noSubgoals    : I-NO-SUBGOALS,
      log           : LUL,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus   : (< ccstep, noAction, true > ;TS; TStk),
      derivatives   : TL,
      output        : if (SW == on) then QLout:QidList else nil fi,
      showDetails   : SW,
      hypCounter    : (N + 1),
      proofStack    : setTopGLL(convEL2GL(EL') :G: GL,
                        setTopM(M'', setTopNSL(getTopNSL(PSS) + (-1), PSS))
                      ),
      noSubgoals    : (I-NO-SUBGOALS + count(EL')),
      log           : (LU< ccstep-atts , M-LOG , convEL2GL(EL') > :LU: LUL),
      Atts
    >
    if M-WORK               := getTopM(PSS)
    /\ op2goal(op Q : TyL -> Ty [AS] .) :G: GL := getTopGLL(PSS)
    /\ OD                   := (op Q : TyL -> Ty [AS] .)
    /\ isSatisfyingKindRestrictions(OD, M-WORK)
    /\ ODsimilar:OpDecl     := getOpFromOpAtts(OD)
    /\ M'                   := addOps(ODsimilar:OpDecl, M-WORK)
    /\ ES-HYP:EquationSet   := getEqsFromOpAtts(OD)
    /\ M''                  := addEqs(ES-HYP:EquationSet, M')
    /\ EL'                  := getGoalsFrozenFromOpAtts(OD, TL, N, M')
    /\ M-LOG                := addEqs(ES-HYP:EquationSet, addOps(OD, emptyLogModule))
    /\ QLout:QidList        := ('\n '\b 'Goal '\o '\s 'op Q ': TyL '-> Ty '\s
                                '`[ attrSet2QidList(AS) '`] '\s '.
                                '\n '\s '\s '\b 'processed 'by 'adding
                                'the 'operator '\o
                                eMetaPrettyPrint(M', ODsimilar:OpDecl) '\n
                                '\b '\s '\s 'and 'the 'hypothesis '\o '\n
                                myMetaPrettyPrint(M'', 
                                  prettyEq(eqSetToNsListEq(ES-HYP:EquationSet),
                                    getTopIUL(PSS)
                                  )
                                )
                                '\n '\b '\s '\s 'and 'coexpanding 'to '\o '\n
                                myMetaPrettyPrint(M-WORK, EL') '\n
                               )
  .

  *** TODO-IUL
  ***(
  crl [undo-ccstep-atts-success] :
    < O : X@CIRCDataBase |
      default       : MN,
      workModule    : M-WORK,
      proofStatus   : undo,
      proofStack    : PSS,
      output        : nil,
      log           : (LU< ccstep-atts , M-LOG , (EL') > :LU: LUL),
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      default       : MN,
      workModule    : M-WORK',
      proofStatus   : waiting,
      proofStack    : setTopGLL(op2goal(OD) :G: GL'', PSS),
      output        : nil,
      log           : LUL,
      Atts
    >
    if GL                 := getTopGLL(PSS)
    /\ OD                 := getOps(M-LOG)
    /\ ODsimilar:OpDecl   := getOpFromOpAtts(OD)
    /\ ES-HYP:EquationSet := getEqs(M-LOG)
    /\ M-LOG'             := addEqs(ES-HYP:EquationSet, addOps(ODsimilar:OpDecl, emptyLogModule))
    /\ M-WORK'            := calcModuleDiff(M-WORK, M-LOG', MN)
    /\ GL''               := remove(count(EL'), GL)
  .
  ***)

  crl [ccstep-atts-none] :
    < O : X@CIRCDataBase |
      proofStack : PSS,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStack : setTopGLL(GL, PSS),
      Atts
    >
    if op2goal(op Q : TyL -> Ty [none] .) :G: GL := getTopGLL(PSS)
  .

  --- TODO: placing this rule higher may result in
  ---       a bad handling of att goals
  rl [ccstep-atts-fail] :
    < O : X@CIRCDataBase |
      proofStatus   : (< ccstep-atts, ccstep-atts, false > ;TS; TStk),
      proofStack    : PSS,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus   : (< ccstep, noAction, false > ;TS; TStk),
      proofStack    : setTopNSL(getTopNSL(PSS) + (-1), PSS),
      Atts
    >
  .

  var IUL' IUL'' IUL1 IUL2 : NsList{InductionUple} .
  var IU : InductionUple .
  var V-IND-EXT V-IND-INT : Variable .
  var S1 : Sort .
  var ISS' : NsSet{IndSource} .
  var E1' E1'' : Equation .
  var B-NEW-VAR    : Bool .
  var B-VAR-EXT    : Bool .
  var NEW-SUBSORTS : SubsortDeclSet .
  var NEW-SORTS    : SortSet .
  var VS-IND-FRZN  : NsSet{Variable} .
  var N-UNQ N-UNQ' : Nat .
  var N-UNQ''      : Nat .
  var C            : Constant .
  var V''          : Variable .
  var SS-IND       : SortSet .


  --- Gets the inductive sorts, i.e. constructor sorts or their supersorts
  crl [startInduction] :
    < O : X@CIRCDataBase |
      debug       : B-DBG,
      proofStatus : < startInduction , startInduction , false >,
      proofStack  : PSS,
      ctors       : ODS,
      ssorts      : SSDS,
      uniqueNat   : N-UNQ,
      output      : nil,
      log         : LUL,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      debug       : B-DBG,
      proofStatus : if (B-DBG == true)
                      then waiting
                      else < induction, induction, false >
                    fi,
      proofStack  : setTopISS((ISS ;IS; ISS'), setTopIUL(
                      IUL', setTopVSL(VSL', setTopGLL(GL', setTopM(M'', PSS)))
                    )),
      ctors       : ODS,
      ssorts      : SSDS,
      uniqueNat   : N-UNQ',
      output      : ('\n '\b 'Induction 'started 'with 'the 'variables:
                     '\n '\o
                     printVariables(VSL') '\n
                    ),
                    --- TODO: fix log for startInduction
      log         : (LU< startInduction ,
                         addSorts(
                           NEW-SORTS,
                           addSubsorts(
                             NEW-SUBSORTS,
                             emptyLogModule
                           )
                         ) ,
                         nsnil-G
                       > :LU: LUL),
      Atts
    >
    if M-WORK       := getTopM(PSS)
    /\ IUL          := getTopIUL(PSS)
    /\ VSL          := getTopVSL(PSS)
    /\ GL           := getTopGLL(PSS)
    /\ ISS          := getTopISS(PSS)
    /\ M'           := fth 'MY-TEMP-SS-CLOSURE is nil sorts getSorts(M-WORK) .
                          SSDS none none none endfth
    /\ SS-IND       := getSuperSorts(getOpSorts(ODS), SSDS)
    /\ VSL'         := filterVariables(VSL, SS-IND)
    /\ IUL'         := genIndsUples(VSL', M', SS-IND)
    /\ GLN< GL' , N-UNQ' , ISS' > := indFreeze(GL , VSL', N-UNQ, IUL', ISS)
    ---/\ GNU:[GoalsNatUple] := indFreeze(GL , VSL', N-UNQ, IUL', ISS)
    /\ NEW-SUBSORTS := getNewSubsorts(IUL')
    /\ NEW-SORTS    := getNewSorts(IUL')
    /\ M''          := addSubsorts(
                         NEW-SUBSORTS,
                         addSorts(
                           NEW-SORTS,
                           M-WORK
                         )
                       )

     ---[print "!!!!!!!!!!!!!!!!!\n" GL "\n" GL' "\n" N-UNQ'  "\n" ISS']

---[print GNU:[GoalsNatUple] "\n" GL VSL' N-UNQ IUL' ISS]
  .

  *** TODO-IUL
  ***(
  crl [undo-startInduction] :
    < O : X@CIRCDataBase |
      default       : MN,
      proofStatus   : undo,
      proofStack    : PSS,
      indVars       : VSL,
      indUples      : IUL,
      workModule    : M-WORK,
      log           : (LU< startInduction , M-LOG , EL > :LU: LUL),
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      default       : MN,
      proofStatus   : waiting,
      proofStack    : setTopGLL(eq2goal(E1) :G: GL, PSS),
      indVars       : nsempty-V,
      indUples      : nsnil-IU,
      workModule    : M-WORK',
      log           : LUL,
      Atts
    >
    if E1      := getEqs(M-LOG)
    /\ eq2goal(E') :G: GL := getTopGLL(PSS)
    /\ M-WORK' := calcModuleDiff(M-WORK, M-LOG, MN)
  .
  ***)

  var ODS-IND : OpDeclSet .
  var ISS : NsSet{IndSource} .

  crl [cistep] :
    < O : X@CIRCDataBase |
      proofStatus : (< cistep, cistep, false > ;TS; TStk),
      ctors       : ODS,
      ssorts      : SSDS,
      uniqueNat   : N-UNQ,
      showDetails : SW,
      output      : nil,
      noSubgoals  : I-NO-SUBGOALS:Int,
      proofStack  : PSS,
      log         : LUL,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus : (< cistep, noAction, true > ;TS; TStk),
      ctors       : ODS,
      ssorts      : SSDS,
      uniqueNat   : N-UNQ'',
      showDetails : SW,
      output      : if (SW == on) then QL3 else nil fi,
      noSubgoals  : (I-NO-SUBGOALS:Int + count(EL')),
      proofStack  : setTopISS(ISS', setTopVSL(VSL',
                      setTopGLL(convEL2GL(EL'') :G: GL,
                        setTopM(M', setTopNSL(getTopNSL(PSS) + (-1), PSS))
                      )
                    )),
                       --- TODO: remove redundant code
      log         : (LU< cistep , addOps(ODS-IND, addEqs(E1'',emptyLogModule)),
                         convEL2GL(EL''), VSL > :LU: LUL),
      Atts
    >
    if M-WORK        := getTopM(PSS)
    /\ VSL           := getTopVSL(PSS)
    /\ eq2goal(ceq T = T' if COND [AS] .) :G: GL := getTopGLL(PSS)
    /\ M''           := fth 'MY-TEMP-SS-CLOSURE is nil sorts getSorts(M-WORK) .
                          SSDS none none none endfth
    /\ E1            := removeCoFreezing(c2v(ceq T = T' if COND [AS] .))
    /\ SS-IND        := getSuperSorts(getOpSorts(ODS), SSDS)
    /\ IUL           := getTopIUL(PSS)
    /\ ISS           := getTopISS(PSS)
    /\ TVSL< V , VSL' > :=    --- fails when the variable is not encountered
                        getPrioIndVar(
                          filterVariables(
                            getVars(E1),
                            getInductiveSorts(IUL)
                          ),
                          VSL,
                          IUL
                        )
    /\ V-IND-INT     := getIndVarInt(E1, V, IUL, M'')
    /\ ELN< EL' ,
         N-UNQ'' , ISS' > := indExpand(E1, V-IND-INT, N-UNQ, ODS, SSDS, IUL, ISS, SS-IND)
    /\ E1''          := orient(c2v(calcIndHypo(v2c(E1), V-IND-INT)), true)
    /\ EL''          := v2c(EL')
    /\ ODS-IND       := calcOpDeclSetDiff(
                          convCTS2ODS((v2c(getVars(EL')) ;C; v2c(getVars(E1'')))),
                          getOps(M-WORK)
                        )
    /\ M'            := addEqs(
                          E1'',
                          addOps( --- TODO: only induction variables should be added as constants
                            ODS-IND,
                            M-WORK
                          )
                        )
    /\ QL3           := ('\n '\b 'Hypo '\o
                         myOneMetaPrettyPrint(M', prettyEq(E1'', IUL)) '\n
                         '\b 'added 'and 'ind-expanded 'over '\o 
                         prettyVar(V-IND-INT, IUL) '\b 'to '\o '\n
                         myMetaPrettyPrint(M', prettyEq(EL', IUL))
                        )
    ---[print "!!!!!!!!!!!!!" ISS']
  ---[print E1 "\n" IUL "\n" VSL]
   ---[print "!!!!!!!!!!!!!!!!!!!" M']
  .

  var VSL''   : NsList{NsSet{Variable}} .

  crl [cistep-variable-not-encountered] :
    < O : X@CIRCDataBase |
      proofStatus : (< cistep, cistep, false > ;TS; TStk),
      ctors       : ODS,
      ssorts      : SSDS,
      uniqueNat   : N-UNQ,
      showDetails : SW,
      output      : nil,
      noSubgoals  : I-NO-SUBGOALS:Int,
      proofStack  : PSS,
      log         : LUL,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus : (< cistep, noAction, true > ;TS; TStk),
      ctors       : ODS,
      ssorts      : SSDS,
      uniqueNat   : N-UNQ',
      showDetails : SW,
      output      : if (SW == on) then QL3 else nil fi,
      noSubgoals  : (I-NO-SUBGOALS:Int + count(EL')),
      proofStack  : setTopISS(ISS', setTopIUL(IUL'', setTopVSL(VSL',
                      setTopGLL(convEL2GL(E1'') :G: GL,
                        setTopM(M'', setTopNSL(getTopNSL(PSS) + (-1), PSS))
                      )
                    ))),
      log         : (LU< cistep , 
		addSorts(
         NEW-SORTS,
         addSubsorts(
           NEW-SUBSORTS,
           addOps(ODS-IND, emptyLogModule)
         )
       ), convEL2GL(EL''), VSL > :LU: LUL),
      Atts
    >
    if M-WORK        := getTopM(PSS)
    /\ VSL           := getTopVSL(PSS)
    /\ IUL           := getTopIUL(PSS)
    /\ ISS           := getTopISS(PSS)
    /\ G :G: GL      := getTopGLL(PSS)
    /\ M'            := fth 'MY-TEMP-SS-CLOSURE is nil sorts getSorts(M-WORK) .
                          SSDS none none none endfth
    /\ SS-IND        := getSuperSorts(getOpSorts(ODS), SSDS)
    /\ eq2goal(E) := G
---    /\ ceq T = T' if COND [AS] . := E
    /\ E1            := removeCoFreezing(c2v(E))
--- we have no ind var in the equation
--- take those from the NsSet{IndSource} that are also in the equation
--- add them to the list of ind vars; add ind uples
    /\ EL'          := E1
    /\ EL''         := EL'
    /\ VS           := filterFromISS(getVars(E1), ISS) --- gets the new induction variables in E1 from ISS
    /\ VSL'         := VSL :VSL: VS --- add the new inductive variables TODO: check if :VSL: not needed => change indFreeze
    /\ IUL'         := genIndsUples(VS, M', SS-IND)
    /\ IUL'' := IUL' :IU: IUL
    /\ ELN< E1'' , N-UNQ' , ISS' > := indFreeze(E1, VS, N-UNQ, IUL', ISS) --- is VS ok ? shouldn't all VSL' be considered ?
    /\ NEW-SUBSORTS := getNewSubsorts(IUL')
    /\ NEW-SORTS    := getNewSorts(IUL')
    /\ M''          := addSubsorts(
                         NEW-SUBSORTS,
                         addSorts(
                           NEW-SORTS,
                           M-WORK
                         )
                       )
    /\ ODS-IND       := calcOpDeclSetDiff(
				                          convCTS2ODS( v2c(getVars(E1''))),
				                          getOps(M-WORK)
				                        )				
    /\ QL3           := nil
   ---[print  GL' "\n" N-UNQ'  "\n" ISS']
   ---[print E1 "\n" E1'' "\n" IUL' "\n" VSL' "\n" NEW-SUBSORTS "\n" NEW-SORTS "\n" ISS "\n\n" ISS']
   ---[print M'']
   ---[print "!!!!!!!!!!!!!!!!!!!!  " M'']
  .

  op filterFromISS : NsSet{Variable} NsSet{IndSource} -> NsSet{Variable} .
  ceq filterFromISS(VS, (ISS ;IS; ISS')) = filterFromISS(VS, ISS) ;V; filterFromISS(VS, ISS')
    if ISS =/= nsempty-IS
    /\ ISS' =/= nsempty-IS
  .
  eq filterFromISS((V ;V; VS), ( V ! S -o V' ) ) = V .
  eq filterFromISS(VS, ( V ! S -o V' ) ) = nsempty-V [owise] .
  
  ***(
  crl [undo-cistep] :
    < O : X@CIRCDataBase |
      default       : MN,
      workModule    : M-WORK,
      proofStatus   : undo,
      proofStack    : PSS,
      goals         : GL,
      log           : (LU< cistep , M-LOG , EL'' , VSL' > :LU: LUL),
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      default       : MN,
      workModule    : M-WORK',
      proofStatus   : waiting,
      proofStack    : setTopVSL(VSL', PSS),
      goals         : GL',
      log           : LUL,
      Atts
    >
    if E1      := getEqs(M-LOG)
    /\ VSL     := getTopVSL(PSS)
    /\ M-WORK' := calcModuleDiff(
                    M-WORK,
                    M-LOG,
                    MN
                  )
    /\ I:Int   := count(EL'')
    /\ GL'     := (eq2goal(E1) :G: remove(I:Int, GL))
  .
  ***)
  
  op trivialEq : -> Equation .
  
  eq trivialEq = (ceq 'true.Bool = 'true.Bool if nil [none] .) .
  
  crl [checkcond] :
    < O : X@CIRCDataBase |
      db            : DB,
      default       : MN,
      proofStatus   : (< checkcond, checkcond, false > ;TS; TStk),
      showDetails   : SW,
      output        : nil,
      proofStack    : PSS,
      log           : LUL,
      ctors         : ODS,
      Atts
    >
    =>
    if B-COND-IS-FALSE:Bool
      then < O : X@CIRCDataBase |
             db            : DB,
             default       : MN,
             proofStatus   : (< checkcond, noAction, true > ;TS; TStk),
             showDetails   : SW,
             output        : if (SW == on) then QL3 else nil fi,
             proofStack    : setTopGLL(eq2goal(coFreeze(trivialEq)) :G: GL,
                               setTopNSL(getTopNSL(PSS) + (-1), PSS)
                             ),
             log           : (LU :LU: LUL),
             ctors         : ODS,
             Atts
           >
      else < O : X@CIRCDataBase |
             db            : DB,
             default       : MN,
             proofStatus   : (< checkcond, noAction, false > ;TS; TStk),
             showDetails   : SW,
             output        : nil,
             proofStack    : setTopNSL(getTopNSL(PSS) + (-1), PSS),
             log           : LUL,
             ctors         : ODS,
             Atts
           >
    fi
    if M-WORK := getTopM(PSS)
    /\ eq2goal(ceq T = T' if COND [AS] .) :G: GL := getTopGLL(PSS)
    /\ E-ANALYZED:Equation := (ceq T = T' if COND [AS] .)
    /\ M := getFlatModule(MN, DB)
    /\ B-COND-IS-FALSE:Bool := isConditionFalse(COND, M-WORK, ODS)
    /\ M-LOG := if B-COND-IS-FALSE:Bool
                  then addEqs(E-ANALYZED:Equation, emptyLogModule)
                  else emptyLogModule
                fi
    /\ LU := LU< checkcond, M-LOG, convEL2GL(coFreeze(trivialEq)) >
    /\ QL3 := ('\n '\b 'Goal '\o '\s
                  myOneMetaPrettyPrint(M-WORK,
                    prettyEq(E-ANALYZED:Equation, getTopIUL(PSS))
                  )
                  '\s '\b 'holds '\s qid("(") 'false 'condition qid(")") '. '\o '\n
               )
  .
  

  var CP : CasePair .
  var CPL : NsList{CasePair} .
  crl [cases] :
    < O : X@CIRCDataBase |
      db            : DB,
      default       : MN,
      proofStatus   : (< cases, cases, false > ;TS; TStk),
      showDetails   : SW,
      output        : nil,
      proofStack    : PSS,
      noSubgoals    : I-NO-SUBGOALS,
      casesPairs    : CPL,
      log           : LUL,
      Atts
    >
    =>
    if B-CAN-ANALYZE:Bool
      then < O : X@CIRCDataBase |
             db            : DB,
             default       : MN,
             proofStatus   : (< cases, noAction, true > ;TS; TStk),
             showDetails   : SW,
             output        : if (SW == on) then QL3 else nil fi,
             proofStack    : setTopM(M-WORK',
                               setTopGLL(convEL2GL(EL'') :G: GL,
                                 setTopNSL(getTopNSL(PSS) + (-1), PSS)
                               )),
             noSubgoals    : (I-NO-SUBGOALS + count(EL'')),
             casesPairs    : CPL,
             log           : (LU :LU: LUL),
             Atts
           >
      else < O : X@CIRCDataBase |
             db            : DB,
             default       : MN,
             proofStatus   : (< cases, noAction, false > ;TS; TStk),
             showDetails   : SW,
             output        : nil,
             proofStack    : setTopNSL(getTopNSL(PSS) + (-1), PSS),
             noSubgoals    : I-NO-SUBGOALS,
             casesPairs    : CPL,
             log           : LUL,
             Atts
           >
    fi
    if M-WORK := getTopM(PSS)
    /\ IUL   := getTopIUL(PSS)
    /\ eq2goal(ceq T = T' if COND [AS] .) :G: GL := getTopGLL(PSS)
    /\ E-ANALYZED:Equation := (ceq T = T' if COND [AS] .)
    /\ M := getFlatModule(MN, DB)
    /\ M-WORK' := addCts(v2c(getVars(E-ANALYZED:Equation)), M-WORK)
    /\ EL'' := v2c(calcCases(c2v(E-ANALYZED:Equation), M, CPL, M-WORK'
       ---addCts(v2c(getVars(E-ANALYZED:Equation)), M-WORK)
    ))
    /\ B-CAN-ANALYZE:Bool := (EL'' =/= nsnil-E)
    /\ M-LOG := if B-CAN-ANALYZE:Bool
                  then addEqs(E-ANALYZED:Equation, emptyLogModule)
                  else emptyLogModule
                fi
    /\ LU := LU< cases, M-LOG, convEL2GL(EL'') >
    /\ QL3 := ('\n '\b 'Goal '\o '\s
                  myOneMetaPrettyPrint(M-WORK,
                    prettyEq(E-ANALYZED:Equation, IUL)
                  )
                  '\s '\b 'analyzed 'with '\o '\n
                  myMetaPrettyPrint(M-WORK, prettyEq(EL'', IUL))
               )
    ---[print E-ANALYZED:Equation]
  .
  
  var THETA THETA' : Substitution .
  var CS  : NsSet{Constant} .

  var T-PTRN : Term .
  var MP? : MatchPair? .
  


  --- Determines the goals resulting after the case analysis.
  --- Input: the equational goal to be replaced according to the case analysis algorithm
  ---        the module in the database (needed for extracting the inital constants)
  ---        the list of case pairs
  ---        the work module (needed for the freezing operator decl. def.)
  op calcCases : Equation Module NsList{CasePair} Module -> NsList{Equation} .
  eq calcCases(E, M, nsnil-CP, M-WORK) = nsnil-E .
  ceq calcCases(E, M, (CP :CP: CPL), M-WORK) =
    if (EL =/= nsnil-E)
      then EL
      else calcCases(E, M, CPL, M-WORK)
    fi
    if EL := calcCases'(E, M, CP, M-WORK)
  .
  

  op calcCases' : Equation Module CasePair Module -> NsList{Equation} .
  ceq calcCases'(E, M, CP, M-WORK) = EL
    if < T-PTRN | COND > := CP
    /\ (ceq T = T' if COND' [none] .) := E
    /\ THETA := if (isVariable(T-PTRN))
                  then findCasesSubst(M-WORK, T-PTRN, v2c(T), bottomXMatch, 0)
                  else findCasesSubst(M-WORK, T-PTRN, v2c(T), firstXMatch, 0)
                fi
    /\ THETA' := if (isVariable(T-PTRN))
                  then findCasesSubst(M-WORK, T-PTRN, v2c(T'), bottomXMatch, 0)
                  else findCasesSubst(M-WORK, T-PTRN, v2c(T'), firstXMatch, 0)
                fi
    /\ ((THETA =/= none) or (THETA' =/= none))
    /\ EL    := if THETA =/= none
                  then expandCases(E, THETA, COND)
                  else expandCases(E, THETA', COND)
                fi
  .
  eq calcCases'(E, M, CP, M-WORK) = nsnil-E
    [owise]
  .

  op expandCases : Equation Substitution Condition -> NsList{Equation} .
  eq expandCases(E, THETA, (COND \/ COND')) =
     expandCases(E, THETA, COND) :E:
     expandCases(E, THETA, COND')
  .
  ***(
  eq expandCases((ceq T = T' if COND [none] .), THETA, COND') =
     (ceq T = T' if COND /\ applySubstCond(COND', THETA) [none] .)
     [owise]
  .
  ***)
    
  var COND'' : EqCondition .
  ceq expandCases((ceq T = T' if COND [none] .), THETA, COND') =
     if (not B-ALREADY-FOUND:Bool)
       then (ceq T = T' if COND /\ COND'' [none] .)
       else nsnil-E
     fi
     if COND'' := applySubstCond(COND', THETA)
     /\ B-ALREADY-FOUND:Bool := isSubcond(c2v(COND''), c2v(COND))
     [ ---print COND "\n" COND'' "\n" B-ALREADY-FOUND:Bool "\n\n"
     owise]
  .
  
  op isSubcond : EqCondition EqCondition -> Bool .
  
  var COND1 COND2 COND3 COND4 : EqCondition .
  eq isSubcond(COND, COND) = true .
  ceq isSubcond(COND1 /\ COND2, COND3) = isSubcond(COND1, COND3) or isSubcond(COND2, COND3)
    if COND1 =/= nil
    /\ COND2 =/= nil
  .
  ceq isSubcond(T = T', COND1 /\ COND2) = isSubcond(T = T', COND1) or isSubcond(T = T', COND2)
    if COND1 =/= nil
    /\ COND2 =/= nil
  .
  eq isSubcond(COND, COND') = false [owise] .
  
  
  
  
  
  

  --- Replaces the current equational goal with a new set of goals (for case analysis).
  --- Input: the equational goal
  ---        the term used for building the new goals
  ---        the set of constants used for building the new goals
  --- t = t' if COND --> t = t' if COND /\ (t-th = Ci) ...
  op expandCases : Equation Term NsSet{Constant} -> NsList{Equation} .
  ceq expandCases(E, T-TH:Term, (C ;C; CS)) = E' :E: expandCases(E, T-TH:Term, CS)
    if (ceq T = T' if COND [AS] .) := E
    /\ E' := (ceq T = T' if COND /\ (T-TH:Term = C) [AS] .)
  .
  eq expandCases(E, T-TH:Term, nsempty-C) = nsnil-E .
  
  
  ---
  op getConstantsOfSort : Module Sort -> NsSet{Constant} .
  ceq getConstantsOfSort(M, S) = filterConstantsOfSort(ODS, S)
    if ODS := getOps(M)
  .
  
  ---
  op filterConstantsOfSort : OpDeclSet Sort -> NsSet{Constant} .
  eq filterConstantsOfSort(none, S) = nsempty-C .
  ceq filterConstantsOfSort((OD ODS), S) = C ;C; filterConstantsOfSort(ODS, S)
    if (op Q : nil -> S [AS] .) := OD
    /\ C := qid(string(Q) + "." + string(S))
  .
  eq filterConstantsOfSort((OD ODS), S) =
    filterConstantsOfSort(ODS, S) [owise]
  .
  


  var V-NEW : Variable .
  crl [generalize] :
    < O : X@CIRCDataBase |
      proofStatus : (< generalize , generalize , false > ;TS; TStk),
      proofStack  : PSS,
      output      : QL,
      ---goals       : (eq2goal(E) :G: GL),
      uniqueNat   : UNQNAT:Nat,
      log         : LUL,
      Atts
    >
    =>
    if CanGeneralize:Bool
      then
        < O : X@CIRCDataBase |
          proofStatus : (< generalize , noAction , true > ;TS; TStk),
          proofStack  : setTopGLL(G-FRZ:Goal :G: GL, setTopM(M-WORK', PSS)),
          output      : ('\n '\b 'Grlz '\o '\s
                          myOneMetaPrettyPrint(M-WORK, prettyEq(E, getTopIUL(PSS)))
                         '\s '\b 'to '\o '\n '\s '\s '\s '\s '\s
                          myOneMetaPrettyPrint(M-WORK', prettyEq(E', getTopIUL(PSS)))
                          '\n
                        ),
          ---goals       : (G-FRZ:Goal :G: GL),
          uniqueNat   : (UNQNAT:Nat + 1),
          log         : (LU :LU: LUL),
          Atts
        >
      else
         < O : X@CIRCDataBase |
          proofStatus : (< generalize , noAction , false > ;TS; TStk),
          proofStack  : PSS,
          output      : QL,
          ---goals       : (eq2goal(E) :G: GL),
          uniqueNat   : UNQNAT:Nat,
          log         : LUL,
          Atts
        >
    fi
    if M-WORK                       := getTopM(PSS)
    /\ eq2goal(E) :G: GL            := getTopGLL(PSS)
    /\ G-INI:Goal                   := eq2goal(removeCoFreezing(E))
    /\ (ceq T1 = T2 if COND [AS] .) := removeCoFreezing(E)
    /\ TL                           := getSubterms(T1)
    /\ TTV< T' , T'' , V-NEW >      := generalizeTerms(T1, T2, TL, M-WORK, UNQNAT:Nat)
    /\ E'                           := orient(coFreeze(ceq T' = T'' if COND [AS] .), true)
    /\ G-FRZ:Goal                   := eq2goal(v2c(E'))
    /\ CanGeneralize:Bool           := (V-NEW =/= noVar)
    /\ M-LOG          := if CanGeneralize:Bool
                           then addCts(v2c(getVars(c2v(E'))), addEqs(E, emptyLogModule))
                           else emptyLogModule
                         fi
    /\ LU   := LU< generalize, M-LOG, eq2goal(E') >
    /\ M-WORK'                      := if CanGeneralize:Bool
                                         then addCts(v2c(V-NEW), M-WORK)
                                         else M-WORK
                                       fi
                                       ---[print E']
               --- TODO: there is a problem with this UNQNAT : what if the variable exists ?
  .
  
  
  var actCheckCSet : Action .
  var QL' : QidList .
  crl [checkCSet] :
    < O : X@CIRCDataBase |
      proofStatus : (< checkCSet , checkCSet , false > ;TS; TStk),
      proofStack  : PSS,
      log         : LUL,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus : (< actCheckCSet , actCheckCSet , false > ;TS; TStk),
      proofStack  : setTopGLL(GL', PSS),
      log         : LUL,
      Atts
    >
    if GL           := getTopGLL(PSS)
    /\ GL'          := getCSet(LUL)
    /\ N            := count(GL')
    /\ actCheckCSet := checkCSet(N)
  .
    
  crl [checkCSet--EndSuccess] :
    < O : X@CIRCDataBase |
      proofStatus : (TStk ;TS; checkCSetEnd),
      proofStack  : PSS,
      output      : QL,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus : waiting,
      proofStack  : PSS,
      output      : ('\n '\g 'Check 'proof 'succeeded '\o '\n),
      Atts
    >
    if getTopGLL(PSS) == nsnil-G
  .
  
  rl [checkCSet--EndFailure] :
    < O : X@CIRCDataBase |
      proofStatus : (< A , noAction , B:Bool > ;TS; checkCSetEnd),
      ---goals       : GL,
      output      : QL,
      Atts
    >
    =>
    < O : X@CIRCDataBase |
      proofStatus : waiting,
      ---goals       : GL,
      output      : ('\n '\r 'Check 'proof 'failed '\o '\n),
      Atts
    >
  .
  

endm --- CIRC-PROVER


***( ===========================================================================
*
* ============================================================================ )

mod CIRC-INTERFACE is

  including CIRC-PROVER .
  including LOOP-MODE .

  subsort Object < State .

  op o    : -> Oid .
  op init : -> System .

  var Atts            : AttributeSet .
  var B               : Bool .
  var DB              : Database .
  var X@Database      : DatabaseClass .
  var MAS             : MembAxSet .
  var O               : Oid .
  var Q               : Qid .
  var QL QL' QL'' QL1 : QidList .
  var RP              : ResultPair? .
  var SW              : SwitchStatus .
  var MN              : ModuleName .
  
  op MAX-NO-STEPS : -> Int .
  eq MAX-NO-STEPS = 256 .

  rl [init] :
    init
    =>
    [nil,
      < o : CIRCDB |
        db            : initialDatabase, ---emptyDatabase
        default       : 'NONE,
        debug         : false,
        proofStatus   : waiting,
        ctors         : none,
        uniqueNat     : 0,
        ssorts        : none,
        derivatives   : empty,
        proofStack    : empty-PS,
        autoContext   : off,
        allContexts   : off,
        autoAddConj   : on,
        grlz          : off,
        simplifyRules : none,
        spectxs       : empty,
        hypCounter    : 0,
        input         : nilTermList,
        output        : nil,
        showDetails   : off,
        showProvProp  : on,
        noSubgoals    : 0,
        maxNoSteps    : MAX-NO-STEPS,
        topModule     : noModule,
        internModule  : noModule,
        flatModule    : noModule,
        stopMessage   : nil,
        log           : LU<proofSeparator>,
        casesPairs    : nsnil-CP
      >,
      ('\n '\t '\s '\s '\s '\s '\s '\s '\s '\s 'CIRC '1.5
       '\s '`( 'April '20th '`, '\s '2010 '`) '\n)
    ]
  .

  crl [in] :
    [ Q QL,
      < o     : CIRCDB |
        input : nilTermList,
        Atts
      >,
      QL'
    ]
    =>
    [ nil,
      < o : CIRCDB |
        input   : getTerm(RP),
        Atts
      >,
      QL'
    ]
    if RP := metaParse(CIRC-GRAMMAR, Q QL, '@Input@)
    /\ RP :: ResultPair
  .

  crl [in-error] :
    [ Q QL,
      < o : CIRCDB |
        output  : nil,
        Atts
      >,
      QL'
    ]
    =>
    [ nil,
      < o : CIRCDB |
        output  : ('\r '<CIRC> 'Warning: printSyntaxError(RP, Q QL) '\n
                  '\r 'Error: '\o 'No 'parse 'for 'input. '\n),
        Atts
      >,
      QL'
    ]
    if RP := metaParse(CIRC-GRAMMAR, Q QL, '@Input@)
    /\ not(RP :: ResultPair)
  .

  crl [out] :
    [ QL,
      < O : X@Database |
        db          : DB,
        output      : (Q QL'),
        Atts
      >,
      QL''
    ]
    => 
    [ QL,
      < O : X@Database |
        db          : DB,
        output      : nil,
        Atts
      >,
      (QL'' QL1)
    ]
    if QL1 := (Q QL')
  .

endm --- CIRC-INTERFACE

loop init .
